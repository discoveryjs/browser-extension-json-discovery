(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.discovery = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = _interopRequireDefault(require("../widget/index.js"));

var complexViews = _interopRequireWildcard(require("../views/index-complex.js"));

var _router = _interopRequireDefault(require("../core/router.js"));

var _dom = require("../core/utils/dom.js");

var _reportLink2 = require("./report-link.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var App =
/*#__PURE__*/
function (_Widget) {
  _inherits(App, _Widget);

  function App(container, options) {
    var _this;

    _classCallCheck(this, App);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this, container, options));
    _this.modelfree = Boolean(options.modelfree);

    _this.apply(complexViews);

    _this.apply(_router.default);

    _this.addBadge('Index', function () {
      return _this.setPage('default');
    }, function (host) {
      return host.pageId !== 'default' && !host.modelfree;
    });

    _this.addBadge('Make report', function () {
      return _this.setPage('report');
    }, function (host) {
      return host.pageId !== 'report' && !host.modelfree;
    });

    _this.addBadge('Reload with no cache', function () {
      return fetch('drop-cache').then(function () {
        return location.reload();
      });
    }, function (host) {
      return host.dev && !host.modelfree;
    });

    _this.addBadge('Switch model', function () {
      return location.href = '..';
    }, function () {
      return /^\/[^\/]+\//.test(location.pathname);
    });

    _this.addBadge(function (el) {
      el.classList.add('load-data-badge');
      el.innerHTML = 'Load data<input type="file" accept="application/json,.json">';
      el.lastChild.addEventListener('change', function (e) {
        return _this.loadDataFromEvent(e);
      });
    }, function () {}, function (host) {
      return host.modelfree;
    });

    if (_this.modelfree && _this.containerEl) {
      // Setup the drag&drop listeners
      _this.containerEl.addEventListener('drop', function (e) {
        return _this.loadDataFromEvent(e);
      }, true);

      _this.containerEl.addEventListener('dragover', function (e) {
        e.stopPropagation();
        e.preventDefault();
      }, true);
    }

    return _this;
  }

  _createClass(App, [{
    key: "setData",
    value: function setData(data) {
      var _this2 = this;

      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.modelfree) {
        this.pageId = 'report';
      }

      return _get(_getPrototypeOf(App.prototype), "setData", this).call(this, data, context).then(function () {
        return document.title = _this2.context.name;
      });
    }
  }, {
    key: "loadDataFromEvent",
    value: function loadDataFromEvent(event) {
      var _this3 = this;

      var source = event.dataTransfer || event.target;
      var file = source && source.files && source.files[0];
      event.stopPropagation();
      event.preventDefault();

      if (file.type !== 'application/json') {
        return;
      }

      var reader = new FileReader();

      reader.onload = function (event) {
        var data = JSON.parse(event.target.result);

        _this3.setData(data, {
          name: "Discover file: ".concat(file.name),
          createdAt: new Date(),
          data: data
        });
      };

      reader.readAsText(file);
    }
  }, {
    key: "loadDataFromUrl",
    value: function loadDataFromUrl(url, dataField) {
      var _this4 = this;

      var loadStartTime = Date.now();
      this.loadingOverlayEl.classList.remove('error', 'done');
      return fetch(url).then(function (res) {
        console.log("data loaded in ".concat(Date.now() - loadStartTime, "ms"));
        _this4.loadingOverlayEl.innerHTML = 'Processing data...';
        return res.json();
      }).then(function (res) {
        if (res.error) {
          throw new Error(res.error);
        }

        var data = dataField ? res[dataField] : res;
        var context = Object.assign({
          name: 'Discovery'
        }, dataField ? res : {
          data: res
        }, {
          createdAt: dataField && res.createdAt ? new Date(Date.parse(res.createdAt)) : new Date()
        });

        _this4.setData(data, context);

        _this4.loadingOverlayEl.classList.add('done');
      }).catch(function (e) {
        _this4.loadingOverlayEl.classList.add('error');

        _this4.loadingOverlayEl.innerHTML = '<pre>Data loading error:<br>' + e + '</pre>';
        console.error(e);
      });
    }
  }, {
    key: "setContainer",
    value: function setContainer(container) {
      _get(_getPrototypeOf(App.prototype), "setContainer", this).call(this, container);

      if (this.containerEl) {
        this.containerEl.appendChild(this.loadingOverlayEl = (0, _dom.createElement)('div', 'loading-overlay done', 'Loading...'));
      } else {
        this.loadingOverlayEl = null;
      }
    }
  }, {
    key: "setPage",
    value: function setPage(id, ref, params) {
      _get(_getPrototypeOf(App.prototype), "setPage", this).call(this, this.modelfree ? this.pageId : id, ref, params);
    }
  }, {
    key: "getPageContext",
    value: function getPageContext() {
      return _objectSpread({}, _get(_getPrototypeOf(App.prototype), "getPageContext", this).call(this), {
        modelfree: this.modelfree
      });
    }
  }, {
    key: "renderPage",
    value: function renderPage() {
      _get(_getPrototypeOf(App.prototype), "renderPage", this).call(this);

      document.title = this.getPageContext().name;
    }
  }, {
    key: "reportLink",
    value: function reportLink() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _reportLink2.reportLink.apply(this, args);
    }
  }]);

  return App;
}(_index.default);

exports.default = App;

},{"../core/router.js":4,"../core/utils/dom.js":7,"../views/index-complex.js":31,"../widget/index.js":51,"./report-link.js":2}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reportLink = reportLink;

var _report = require("../pages/report.js");

function reportLink(options) {
  if (typeof options === 'string') {
    return reportLink.call(this, {
      query: options
    });
  }

  var params = (0, _report.encodeParams)(options);
  var page = this.modelfree ? '' : 'report';
  return params.length ? "#".concat(page, "&").concat(params) : "#".concat(page);
}

},{"../pages/report.js":17}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* eslint-env browser */
var BUILDIN_NOT_FOUND = {
  name: 'not-found',
  render: function render(el, _ref) {
    var name = _ref.name;
    el.style.cssText = 'color:#a00';
    el.innerText = "Page `".concat(name, "` not found");
  }
};

var PageRenderer =
/*#__PURE__*/
function () {
  function PageRenderer(view) {
    _classCallCheck(this, PageRenderer);

    this.view = view;
    this.pages = Object.create(null);
    this.lastPage = null;
  }

  _createClass(PageRenderer, [{
    key: "define",
    value: function define(name, render, options) {
      var _this = this;

      this.pages[name] = {
        name: name,
        render: typeof render === 'function' ? render : function (el, data, context) {
          return _this.view.render(el, render, data, context);
        },
        options: options || {}
      };
    }
  }, {
    key: "render",
    value: function render(oldPageEl, name, data, context) {
      var startTime = Date.now();
      var page = this.pages[name];
      var rendered;

      if (!page) {
        page = this.pages['not-found'] || BUILDIN_NOT_FOUND;
        data = {
          name: name
        };
      }

      var _ref2 = page.options || {},
          reuseEl = _ref2.reuseEl,
          init = _ref2.init,
          keepScrollOffset = _ref2.keepScrollOffset;

      var pageChanged = this.lastPage !== name;
      var newPageEl = reuseEl && !pageChanged ? oldPageEl : document.createElement('article');
      var parentEl = oldPageEl.parentNode;
      this.lastPage = name;
      newPageEl.id = oldPageEl.id;
      newPageEl.classList.add('page', 'page-' + name);

      if (pageChanged && typeof init === 'function') {
        init(newPageEl);
      }

      try {
        rendered = page.render(newPageEl, data, context);
      } catch (e) {
        // FIXME: Should not to use a view (alert-danger) since it may to be undefined. Replace render with onError hook?
        rendered = this.view.render(newPageEl, 'alert-danger', String(e) + ' (see details in console)');
        console.error(e);
      }

      if (newPageEl !== oldPageEl) {
        parentEl.replaceChild(newPageEl, oldPageEl);
      }

      if (pageChanged || !keepScrollOffset) {
        parentEl.scrollTop = 0;
      }

      Promise.resolve(rendered).then(function () {
        return console.log('Page `' + page.name + '` rendered in ' + (Date.now() - startTime) + 'ms');
      });
      return newPageEl;
    }
  }]);

  return PageRenderer;
}();

exports.default = PageRenderer;

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-env browser */
function decodeParams() {
  var hash = location.hash.substr(1);
  var parts = hash.split('&');

  var _split = (parts.shift() || '').split(':'),
      _split2 = _slicedToArray(_split, 2),
      page = _split2[0],
      id = _split2[1];

  var params = _toConsumableArray(new URLSearchParams(parts.join('&'))).reduce(function (map, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    map[key] = value;
    return map;
  }, {});

  return {
    page: page,
    id: id,
    params: params
  };
}

function encodeParams(params) {
  return new URLSearchParams(params).toString();
}

function self(value) {
  return value;
}

function _default(discovery) {
  function updatePageFromHash() {
    var dp = decodeParams();
    discovery.pageId = dp.page || 'default';
    discovery.pageRef = dp.id;
    discovery.pageParams = discovery.getPageOption('decodeParams', self)(dp.params);
  }

  discovery.setPageParams = function (params, replace) {
    var newParams = this.getPageOption('encodeParams', encodeParams)(params || {});
    var curLocation = location.hash || '#';
    var newLocation = "#".concat(this.pageId !== 'default' ? this.pageId : '').concat(this.pageRef ? ':' + this.pageRef : '').concat(newParams ? '&' + newParams : '');

    if (newLocation !== curLocation) {
      this.pageParams = params || {};

      if (replace) {
        location.replace(newLocation);
      } else {
        location.hash = newLocation;
      }

      return true;
    }
  };

  updatePageFromHash();
  window.addEventListener('hashchange', function () {
    updatePageFromHash();
    discovery.renderPage();
  }, false);
}

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = encode;
exports.decode = decode;

/* eslint-env browser */
var chars = [];
var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');
var charIndex = b64chars.reduce(function (res, item, index) {
  res[item] = index;
  return res;
}, {});

for (var i = 0; i < 255; i++) {
  chars[i] = String.fromCharCode(i);
} // utf16 string -> utf8 string


function toUTF8(input) {
  var output = '';

  for (var _i = 0; _i < input.length; _i++) {
    var c = input.charCodeAt(_i);

    if (c < 128) {
      output += chars[c];
    } else {
      if (c < 2048) {
        output += chars[c >> 6 | 192] + chars[c & 63 | 128];
      } else {
        output += chars[c >> 12 | 224] + chars[c >> 6 & 63 | 128] + chars[c & 63 | 128];
      }
    }
  }

  return output;
} // utf16 string -> utf8 bytes array


function toUTF8Bytes(input) {
  // utf16 -> utf8
  input = toUTF8(input); // string -> array of bytes

  var output = new Array(input.length);

  for (var _i2 = 0; _i2 < input.length; _i2++) {
    output[_i2] = input.charCodeAt(_i2);
  }

  return output;
} // utf8 string -> utf16 string


function fromUTF8(input) {
  var output = '';

  for (var _i3 = 0; _i3 < input.length;) {
    var c1 = input.charCodeAt(_i3++);

    if (c1 < 128) {
      output += String.fromCharCode(c1);
    } else {
      var c2 = input.charCodeAt(_i3++);

      if (c1 & 32) {
        var c3 = input.charCodeAt(_i3++);
        output += String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
      } else {
        output += String.fromCharCode((c1 & 31) << 6 | c2 & 63);
      }
    }
  }

  return output;
} // utf8 bytes array -> utf16 string


function fromUTF8Bytes(input) {
  return fromUTF8(input.map(function (b) {
    return chars[b];
  }).join(''));
}

function encode(input) {
  var output = ''; // convert to bytes array if necessary

  if (!Array.isArray(input)) {
    input = toUTF8Bytes(input);
  }

  for (var _i4 = 0; _i4 < input.length;) {
    var chr1 = input[_i4++];
    var chr2 = input[_i4++];
    var chr3 = input[_i4++];
    var enc1 = chr1 >> 2;
    var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    var enc4 = chr3 & 63;

    if (chr2 == undefined) {
      enc3 = enc4 = 64;
    } else if (chr3 == undefined) {
      enc4 = 64;
    }

    output += b64chars[enc1] + b64chars[enc2] + b64chars[enc3] + b64chars[enc4];
  }

  return output;
}

function decode(input) {
  var output = [];
  var enc1;
  var enc2;
  var enc3;
  var enc4;
  input = input.replace(/[^a-zA-Z0-9\+\/]/g, ''); // decode

  for (var _i5 = 0; _i5 < input.length;) {
    enc1 = charIndex[input.charAt(_i5++)];
    enc2 = charIndex[input.charAt(_i5++)];
    enc3 = charIndex[input.charAt(_i5++)];
    enc4 = charIndex[input.charAt(_i5++)];
    var chr1 = enc1 << 2 | enc2 >> 4;
    var chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    var chr3 = (enc3 & 3) << 6 | enc4;
    output.push(chr1, chr2, chr3);
  }

  if (enc3 == null || enc3 == 64) {
    output.pop();
  }

  if (enc4 == null || enc4 == 64) {
    output.pop();
  } // convert to UTF8


  return fromUTF8Bytes(output);
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defined;

function defined(values, fallback) {
  for (var i = 0; i < values.length; i++) {
    if (typeof values[i] !== 'undefined') {
      return values[i];
    }
  }

  return fallback;
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createElement = createElement;
exports.createText = createText;

/* eslint-env browser */
function createElement(tag, attrs, children) {
  var el = document.createElement(tag);

  if (typeof attrs === 'string') {
    attrs = {
      class: attrs
    };
  }

  for (var attrName in attrs) {
    if (attrName.startsWith('on')) {
      el.addEventListener(attrName.substr(2), attrs[attrName]);
    } else {
      el.setAttribute(attrName, attrs[attrName]);
    }
  }

  if (Array.isArray(children)) {
    children.forEach(function (child) {
      return el.appendChild(child && child.nodeType ? child : createText(child));
    });
  } else if (typeof children === 'string') {
    el.innerHTML = children;
  }

  return el;
}

function createText(text) {
  return document.createTextNode(String(text));
}

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rawFileContentUrl = rawFileContentUrl;
exports.fetchFileContent = fetchFileContent;
exports.dropFileContentCache = dropFileContentCache;

/* eslint-env browser */
var fileContentCache = new Map();

function rawFileContentUrl(filename) {
  return 'file-source?path=' + encodeURIComponent(filename) + '&raw';
}

function fetchFileContent(filename, syntax, refs) {
  if (!fileContentCache.has(filename)) {
    fileContentCache.set(filename, fetch('file-source?path=' + encodeURIComponent(filename)).then(function (res) {
      return res.json();
    }).then(function (res) {
      return Object.assign({
        filename: filename,
        syntax: syntax,
        refs: refs
      }, res);
    }));
  }

  return fileContentCache.get(filename);
}

function dropFileContentCache() {
  fileContentCache.clear();
}

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.escapeHtml = escapeHtml;

function escapeHtml(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var base64 = _interopRequireWildcard(require("./base64.js"));

var fetch = _interopRequireWildcard(require("./fetch-file-content.js"));

var html = _interopRequireWildcard(require("./html.js"));

var _defined = _interopRequireDefault(require("./defined.js"));

var _safeFilterRx = _interopRequireDefault(require("./safe-filter-rx.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = _objectSpread({
  base64: base64
}, fetch, html, {
  defined: _defined.default,
  safeFilterRx: _safeFilterRx.default
});

exports.default = _default;

},{"./base64.js":5,"./defined.js":6,"./fetch-file-content.js":8,"./html.js":9,"./safe-filter-rx.js":11}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = safeFilterRx;

/* eslint-env browser */
function safeFilterRx(pattern) {
  try {
    return new RegExp('((?:' + pattern + ')+)', 'i');
  } catch (e) {}

  return new RegExp('((?:' + pattern.replace(/[\(\)\?\+\*\{\}\\]/g, '\\$&') + ')+)', 'i');
}

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/* eslint-env browser */
var views = new WeakMap();
var STUB_OBJECT = Object.freeze({});
var BUILDIN_FALLBACK = {
  name: 'fallback',
  render: function render(el, config) {
    el.style.cssText = 'color:#a00;border:1px dashed #a00;font-size:12px;padding:4px';
    el.innerText = config.reason;
  },
  options: STUB_OBJECT
};

function renderDom(renderer, placeholder, config, data, context) {
  var tag = renderer.options.tag;
  var el = tag === false || tag === null ? document.createDocumentFragment() : document.createElement(tag || 'div');
  return Promise.resolve(renderer.render(el, config, data, context)).then(function () {
    if (el.classList) {
      if (renderer.name) {
        el.classList.add("view-".concat(renderer.name));
      }

      if (config.className) {
        el.classList.add(config.className);
      }
    }

    placeholder.parentNode.replaceChild(el, placeholder);
  });
}

var ViewRenderer =
/*#__PURE__*/
function () {
  function ViewRenderer(host) {
    _classCallCheck(this, ViewRenderer);

    this.host = host;
    views.set(this, Object.create(null));
  }

  _createClass(ViewRenderer, [{
    key: "isDefined",
    value: function isDefined(name) {
      return name in views.get(this);
    }
  }, {
    key: "define",
    value: function define(name, customRender, options) {
      var _this = this;

      views.get(this)[name] = {
        name: name,
        render: typeof customRender === 'function' ? customRender.bind(this) : function (el, config, data, context) {
          return _this.render(el, customRender, data, context);
        },
        options: options || STUB_OBJECT
      };
    }
  }, {
    key: "render",
    value: function render(container, config, data, context) {
      var _this2 = this;

      if (!config) {
        config = 'struct';
      }

      if (Array.isArray(config)) {
        return Promise.all(config.map(function (config) {
          return _this2.render(container, config, data, context);
        }));
      }

      if (typeof config === 'string') {
        var _ref = config.match(/^(\S+?):((?:.|\s)+)$/) || [],
            _ref2 = _slicedToArray(_ref, 3),
            prefix = _ref2[1],
            query = _ref2[2];

        if (prefix) {
          config = {
            view: prefix,
            data: query
          };
        } else {
          config = {
            view: config
          };
        }
      } else if (typeof config === 'function') {
        config = {
          view: config
        };
      }

      var renderer = typeof config.view === 'function' ? {
        render: config.view,
        name: false,
        options: STUB_OBJECT
      } : views.get(this)[config.view];

      if (!renderer) {
        var errorMsg = typeof config.view === 'string' ? 'View `' + config.view + '` is not found' : 'Render is not a function';
        console.error(errorMsg, config);
        renderer = views.get(this).fallback || BUILDIN_FALLBACK;
        config = {
          reason: errorMsg
        };
      }

      if ('visible' in config === false || this.host.queryBool(config.visible, data, context)) {
        // immediately append a view insert point (a placeholder)
        var placeholder = container.appendChild(document.createComment('')); // resolve data and render a view when ready

        return Promise.resolve( // change context data if necessary
        'data' in config ? this.host.query(config.data, data, context) : data).then(function (data) {
          return renderDom(renderer, placeholder, config, data, context);
        }).catch(function (e) {
          renderDom(views.get(_this2)['alert-danger'], placeholder, {}, e);
          console.log(e);
        });
      } else {
        return Promise.resolve();
      }
    }
  }, {
    key: "renderList",
    value: function renderList(container, itemConfig, data, context, offset, limit, moreContainer) {
      var _this3 = this;

      data.slice(offset, offset + limit).forEach(function (value, sliceIndex, slice) {
        _this3.render(container, itemConfig, value, Object.assign({}, context, {
          index: offset + sliceIndex,
          array: data,
          sliceIndex: sliceIndex,
          slice: slice
        }));
      });
      this.maybeMoreButtons(container, itemConfig, data, context, offset + limit, limit, moreContainer);
    }
  }, {
    key: "maybeMoreButtons",
    value: function maybeMoreButtons(container, itemConfig, data, context, offset, limit, moreContainer) {
      var _this4 = this;

      var restCount = data.length - offset;
      var buttons = document.createDocumentFragment();

      if (restCount > limit) {
        this.renderMoreButton(buttons, 'Show ' + limit + ' more...', function () {
          return _this4.renderList(container, itemConfig, data, context, offset, limit, moreContainer);
        });
      }

      if (restCount > 0) {
        this.renderMoreButton(buttons, 'Show all the rest ' + restCount + ' items...', function () {
          return _this4.renderList(container, itemConfig, data, context, offset, Infinity, moreContainer);
        });
      }

      if (buttons.firstChild) {
        var buttonContainer = document.createElement('span');
        buttonContainer.className = 'more-buttons';
        buttonContainer.appendChild(buttons);
        (moreContainer || container).appendChild(buttonContainer);
      }
    }
  }, {
    key: "renderMoreButton",
    value: function renderMoreButton(container, caption, fn) {
      var moreButton = document.createElement('button');
      moreButton.className = 'more-button';
      moreButton.addEventListener('click', function () {
        moreButton.parentNode.remove();
        fn();
      });
      moreButton.innerHTML = caption;
      container.appendChild(moreButton);
    }
  }, {
    key: "views",
    get: function get() {
      return Object.keys(views.get(this)).sort();
    }
  }]);

  return ViewRenderer;
}();

exports.default = ViewRenderer;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Widget", {
  enumerable: true,
  get: function get() {
    return _index.default;
  }
});
Object.defineProperty(exports, "App", {
  enumerable: true,
  get: function get() {
    return _index2.default;
  }
});
Object.defineProperty(exports, "router", {
  enumerable: true,
  get: function get() {
    return _router.default;
  }
});
Object.defineProperty(exports, "utils", {
  enumerable: true,
  get: function get() {
    return _index5.default;
  }
});
exports.pages = exports.complexViews = exports.views = void 0;

var _index = _interopRequireDefault(require("./widget/index.js"));

var _index2 = _interopRequireDefault(require("./app/index.js"));

var views = _interopRequireWildcard(require("./views/index.js"));

exports.views = views;

var complexViews = _interopRequireWildcard(require("./views/index-complex.js"));

exports.complexViews = complexViews;

var pages = _interopRequireWildcard(require("./pages/index.js"));

exports.pages = pages;

var _router = _interopRequireDefault(require("./core/router.js"));

var _index5 = _interopRequireDefault(require("./core/utils/index.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./app/index.js":1,"./core/router.js":4,"./core/utils/index.js":10,"./pages/index.js":15,"./views/index-complex.js":31,"./views/index.js":32,"./widget/index.js":51}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(discovery) {
  discovery.definePage('default', {
    view: 'switch',
    content: [{
      case: '#.modelfree',
      content: [{
        view: 'h1',
        className: 'modelfree',
        content: ['text:"Discovery "', 'badge:{ text: "model free mode" }']
      }, 'html:"<p>Running in <b>model free mode</b>, because no config or no models is set up. Please, read <a href=\\"/link-to-documentation\\" href=\\"_blank\\">documention</a> to learn how to set up models."', 'html:"<p>In this mode you can load a data (JSON), via a button in top right corner or via dropping a file on the page.</p>"']
    }, {
      content: ['h1:#.name', 'struct']
    }]
  });
}

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _default.default;
  }
});
Object.defineProperty(exports, "notFound", {
  enumerable: true,
  get: function get() {
    return _notFound.default;
  }
});
Object.defineProperty(exports, "report", {
  enumerable: true,
  get: function get() {
    return _report.default;
  }
});

var _default = _interopRequireDefault(require("./default.js"));

var _notFound = _interopRequireDefault(require("./not-found.js"));

var _report = _interopRequireDefault(require("./report.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./default.js":14,"./not-found.js":16,"./report.js":17}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(discovery) {
  discovery.definePage('not-found', ['alert-warning:"Page \`" + name + "\` not found"']);
}

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeParams = encodeParams;
exports.decodeParams = decodeParams;
exports.default = _default;

var base64 = _interopRequireWildcard(require("../core/utils/base64.js"));

var _dom = require("../core/utils/dom.js");

var _html = require("../core/utils/html.js");

var _codemirror = _interopRequireDefault(require("/gen/codemirror.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// FIXME: generated file to make it local
function valueDescriptor(value) {
  if (Array.isArray(value)) {
    return "Array (".concat(value.length ? "".concat(value.length, " ").concat(value.length > 1 ? 'elements' : 'element') : 'empty', ")");
  }

  if (value && _typeof(value) === 'object') {
    var keys = Object.keys(value);
    return "Object (".concat(keys.length ? "".concat(keys.length, " ").concat(keys.length > 1 ? 'keys' : 'key') : 'empty', ")");
  }

  return "Scalar (".concat(value === 'null' ? 'null' : _typeof(value), ")");
}

function encodeSearchParamPair(name, value) {
  return encodeURIComponent(name) + '=' + encodeURIComponent(value);
}

function encodeParams(options) {
  var query = options.query,
      view = options.view,
      title = options.title,
      dzen = options.dzen,
      extra = options.extra;
  var result = [];

  if (dzen) {
    result.push('dzen');
  }

  if (title) {
    result.push(encodeSearchParamPair('title', title));
  }

  if (query) {
    result.push(encodeSearchParamPair('q', base64.encode(query)));
  }

  if (view && typeof view === 'string') {
    result.push(encodeSearchParamPair('v', base64.encode(view)));
  } else {
    if (view === true) {
      result.push('v');
    }
  }

  if (extra) {
    Object.keys(extra).sort().forEach(function (name) {
      if (name !== 'query' && name !== 'view' && name !== 'title' && name !== 'dzen') {
        result.push(encodeSearchParamPair(name, extra[name]));
      }
    });
  }

  return result.join('&');
}

function decodeParams(params) {
  var res = {
    title: params.title || '',
    query: base64.decode(params.q || ''),
    view: base64.decode(params.v || ''),
    mode: 'v' in params ? 'custom' : 'default',
    dzen: 'dzen' in params
  };
  Object.keys(params).forEach(function (name) {
    if (name !== 'q' && name !== 'v' && name !== 'title' && name !== 'dzen') {
      res[name] = params[name];
    }
  });
  return res;
}

function _default(discovery) {
  var defaultView = '{\n    view: \'list\',\n    item: \'struct\'\n}';
  var showQueryRawData = false;
  var viewMode = 'none';
  var processEditorChangeEvent = true;
  var lastQuery = {};
  var lastView = {};

  function createPageQueryEditor(textarea) {
    var liveEdit = textarea.parentNode.querySelector('.live-update');

    var editor = _codemirror.default.fromTextArea(textarea, {
      mode: 'javascript',
      theme: 'neo',
      indentUnit: 0
    });

    editor.on('change', function () {
      return processEditorChangeEvent && liveEdit.checked && applyQuery();
    });
    return editor;
  }

  function applyQuery(newQuery, newView, newTitle) {
    var titleValue = titleInputEl.value;
    var queryValue = queryEditor.getValue();
    var viewValue = viewMode === 'custom' ? viewEditor.getValue() : undefined;

    if (newTitle === undefined) {
      newTitle = titleValue;
    }

    if (newQuery === undefined) {
      newQuery = queryValue;
    }

    if (newView === undefined) {
      newView = viewValue;
    }

    processEditorChangeEvent = false;

    if (titleValue !== newTitle) {
      titleInputEl.value = newTitle;
    }

    if (queryValue !== newQuery) {
      queryEditor.setValue(newQuery);
    }

    if (viewValue !== newView) {
      viewEditor.setValue(newView);
    }

    processEditorChangeEvent = true; // update params

    return discovery.setPageParams(_objectSpread({}, discovery.pageParams, {
      title: newTitle,
      query: newQuery,
      view: newView || viewMode === 'custom'
    }), true);
  }

  function updateViewModeTabs() {
    viewSetupEl.hidden = viewMode !== 'custom';
    tabsEls.forEach(function (el) {
      if (el.dataset.mode === viewMode) {
        el.classList.add('active');
      } else {
        el.classList.remove('active');
      }
    });
  }

  function setViewMode(mode) {
    if (viewMode === mode) {
      return;
    }

    switch (mode) {
      case 'default':
        viewMode = mode;
        applyQuery();
        break;

      case 'custom':
        viewMode = mode;
        applyQuery(undefined, defaultView);
        break;

      default:
        console.log('Unknown view mode', mode);
    }

    updateViewModeTabs();
  }

  var titleInputEl;
  var timestampEl;
  var headerEl = (0, _dom.createElement)('div', 'data-query-header', [(0, _dom.createElement)('button', {
    hidden: true,
    onclick: function onclick() {
      var quote = function quote(s) {
        return s.replace(/\\/g, '\\\\').replace(/\t/g, '\\t').replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\\'');
      };

      var decode = function decode(s) {
        return base64.decode(decodeURIComponent(s || ''));
      };

      var _applyQuery = applyQuery(),
          title = _applyQuery.title,
          query = _applyQuery.query,
          view = _applyQuery.view;

      var res = {
        title: title,
        query: query,
        view: view
      };
      res.query = decode(res.query);
      res.view = decode(res.view);
      window.currentReport = "{\n".concat(Object.keys(res).map(function (k) {
        return res[k] ? "    ".concat(k, ": '").concat(quote(res[k]), "'") : false;
      }).filter(Boolean).join(',\n'), "\n}");
      console.log(window.currentReport);
    }
  }, 'as JSON'), (0, _dom.createElement)('div', {
    class: 'data-query-title',
    'data-title': '\xA0'
  }, [titleInputEl = (0, _dom.createElement)('input', {
    placeholder: 'Untitled report',
    oninput: function oninput() {
      return applyQuery();
    },
    onkeypress: function onkeypress(e) {
      if (event.charCode === 13 || event.keyCode === 13) {
        e.target.blur();
      }
    }
  }), timestampEl = (0, _dom.createElement)('span', 'timestamp', ['Data collected at ', (0, _dom.createElement)('span', 'datetime data-time'), ' | View built at ', (0, _dom.createElement)('span', 'datetime view-time')])]), (0, _dom.createElement)('div', 'data-query-view-options', [(0, _dom.createElement)('button', {
    class: 'toggle-fullscreen',
    title: 'Toggle fullscreen mode',
    onclick: function onclick(e) {
      e.target.blur();
      discovery.setPageParams(_objectSpread({}, discovery.pageParams, {
        dzen: !discovery.pageParams.dzen
      }));
    }
  }, 'Toggle fullscreen mode')])]);
  var queryEditorEl;
  var filterEl = (0, _dom.createElement)('div', 'filter', [queryEditorEl = (0, _dom.createElement)('textarea', {
    placeholder: 'Query'
  }), (0, _dom.createElement)('div', 'editor-toolbar', [(0, _dom.createElement)('span', 'syntax-hint', 'Use <a href="https://github.com/lahmatiy/jora" target="_blank">jora</a> syntax for queries'), (0, _dom.createElement)('label', null, [(0, _dom.createElement)('input', {
    class: 'live-update',
    type: 'checkbox',
    checked: true,
    onchange: function onchange(e) {
      if (e.target.checked) {
        applyQuery();
      }
    }
  }), ' process on input']), (0, _dom.createElement)('div', 'buttons', [(0, _dom.createElement)('button', {
    onclick: function onclick() {
      lastQuery = {};
      applyQuery();
      discovery.renderPage();
    }
  }, 'Process')])])]);
  var queryResultEl = (0, _dom.createElement)('div', 'data-query-result');
  var contentEl;
  var viewSetupEl;
  var viewEditorEl;
  var tabsEls;
  var dataViewEl = (0, _dom.createElement)('div', 'data-view', [(0, _dom.createElement)('div', 'view-switcher', [(0, _dom.createElement)('div', 'tabs', tabsEls = [(0, _dom.createElement)('div', {
    class: 'tab',
    'data-mode': 'default',
    onclick: function onclick() {
      return setViewMode('default');
    }
  }, 'Default'), (0, _dom.createElement)('div', {
    class: 'tab',
    'data-mode': 'custom',
    onclick: function onclick() {
      return setViewMode('custom');
    }
  }, 'Custom')]), viewSetupEl = (0, _dom.createElement)('div', {
    class: 'query-view-setup',
    hidden: true
  }, [viewEditorEl = (0, _dom.createElement)('textarea', {
    placeholder: 'View'
  }), (0, _dom.createElement)('div', 'editor-toolbar', [(0, _dom.createElement)('div', 'editor-toolbar-view-dict', [(0, _dom.createText)('Available views: '), (0, _dom.createElement)('span', 'editor-toolbar-view-list', discovery.view.views.map(function (name) {
    return "<span class=\"view\">".concat(name, "</span>");
  }).join(', '))]), (0, _dom.createElement)('label', null, [(0, _dom.createElement)('input', {
    class: 'live-update',
    type: 'checkbox',
    checked: true,
    onchange: function onchange(e) {
      if (e.target.checked) {
        applyQuery();
      }
    }
  }), ' build on input']), (0, _dom.createElement)('div', 'buttons', [(0, _dom.createElement)('button', {
    onclick: function onclick() {
      lastView = {};
      applyQuery();
      discovery.renderPage();
    }
  }, 'Build')])])])]), contentEl = (0, _dom.createElement)('div', 'content')]);
  var queryEditor = createPageQueryEditor(queryEditorEl);
  var viewEditor = createPageQueryEditor(viewEditorEl);
  discovery.definePage('report', function (el, data, context) {
    var pageTitle = context.params.title;
    var pageQuery = context.params.query;
    var pageView = context.params.view;
    var queryTime;
    var view = null;
    var results = null;
    setViewMode(context.params.mode);

    if (applyQuery(pageQuery, pageView, pageTitle)) {
      return;
    }

    titleInputEl.parentNode.dataset.title = pageTitle || titleInputEl.placeholder; // zero timeout, like a setImmediate()

    Promise.resolve().then(function () {
      queryEditor.refresh();
      viewEditor.refresh();
    });

    if (lastQuery.data === data && lastQuery.query === pageQuery && lastQuery.context === context) {
      results = lastQuery.results;
    } else {
      try {
        queryTime = Date.now();
        results = discovery.query(pageQuery, data, context);
        queryTime = Date.now() - queryTime;
        dataViewEl.hidden = false;
      } catch (e) {
        lastQuery = {};
        queryResultEl.innerHTML = '<div class="error">' + (0, _html.escapeHtml)(e.message) + '</div>';
        dataViewEl.hidden = true;
        return;
      }

      lastQuery = {
        data: data,
        query: pageQuery,
        context: context,
        results: results
      };
      timestampEl.querySelector('.data-time').innerText = context.createdAt.toLocaleString().replace(',', '');
      queryResultEl.innerHTML = '';
      discovery.view.render(queryResultEl, {
        view: 'expand',
        title: "html:\"".concat(valueDescriptor(results), " in ").concat(parseInt(queryTime, 10), "ms\""),
        expanded: showQueryRawData,
        onToggle: function onToggle(state) {
          return showQueryRawData = state;
        }
      }, results);
    }

    if (!pageView && viewMode === 'default') {
      pageView = Array.isArray(results) ? defaultView : '{ view: "struct", expanded: 1 }';
    }

    if (lastView.data !== results || lastView.view !== pageView) {
      contentEl.innerHTML = '';

      try {
        view = Function('return ' + (pageView ? '0,' + pageView : 'null'))();
        discovery.view.render(contentEl, view, results, context);
      } catch (e) {
        view = {
          view: 'fallback',
          reason: e.message
        };
        discovery.view.render(contentEl, function (el) {
          el.innerHTML = '<div class="error">' + (0, _html.escapeHtml)(String(e)) + '<br>(see details in console)</div>';
          console.error(e);
        });
      }

      timestampEl.querySelector('.view-time').innerText = new Date().toLocaleString().replace(',', '');
      lastView = {
        data: results,
        view: pageView
      };
    }
  }, {
    keepScrollOffset: true,
    reuseEl: true,
    init: function init(el) {
      [headerEl, filterEl, queryResultEl, dataViewEl].forEach(function (child) {
        el.appendChild(child);
      });
    },
    encodeParams: encodeParams,
    decodeParams: decodeParams
  });
}

},{"../core/utils/base64.js":5,"../core/utils/dom.js":7,"../core/utils/html.js":9,"/gen/codemirror.js":52}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  function render(el, config, data, context) {
    var content = config.content;
    discovery.view.render(el, content || 'text', data, context);
  }

  discovery.view.define('alert', render);
  discovery.view.define('alert-success', render);
  discovery.view.define('alert-danger', render);
  discovery.view.define('alert-warning', render);
}

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function maybeFix(el, type, value) {
  if (!value) {
    return;
  }

  var prefixEl = el.appendChild(document.createElement('span'));
  prefixEl.className = type;
  prefixEl.innerText = value;
}

function _default(discovery) {
  function render(el, config, data, context) {
    var content = config.content;

    var _ref = data || {},
        color = _ref.color,
        text = _ref.text,
        href = _ref.href,
        prefix = _ref.prefix,
        postfix = _ref.postfix;

    el.style.backgroundColor = color;

    if (href) {
      el.href = href;
    }

    maybeFix(el, 'prefix', prefix);

    if (content) {
      discovery.view.render(el, content, data, context);
    } else {
      el.appendChild(document.createTextNode(String(text)));
    }

    maybeFix(el, 'postfix', postfix);
  }

  discovery.view.define('badge', render, {
    tag: 'a'
  });
  discovery.view.define('pill-badge', render, {
    tag: 'a'
  });
}

},{}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('block', function (el, config, data, context) {
    var content = config.content;
    discovery.view.render(el, content, data, context);
  });
}

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _highcharts = _interopRequireDefault(require("/gen/highcharts.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('chart', function (el, config, data, context) {
    var options = config.options;
    var label = '<b>{point.y}</b> ({point.percentage:.1f}%)';

    if (!Array.isArray(data)) {
      data = data ? [data] : [];
    }

    if (data[0] && !data[0].data) {
      data = [{
        data: data
      }];
    }

    try {
      _highcharts.default.chart(el, _highcharts.default.merge({
        chart: {
          type: 'pie',
          height: '60%'
        },
        title: {
          text: undefined
        },
        credits: {
          enabled: false
        },
        tooltip: {
          pointFormat: label
        },
        plotOptions: {
          pie: {
            cursor: 'pointer',
            dataLabels: {
              format: '{point.name}  ' + label,
              useHTMsL: true
            }
          }
        },
        series: data
      }, options));
    } catch (e) {
      discovery.view.render(el, {
        view: 'fallback',
        reason: e.message
      }, data, context);
    }
  });
}

},{"/gen/highcharts.js":53}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _defined = _interopRequireDefault(require("../core/utils/defined.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _default(discovery) {
  discovery.view.define('checkbox', function (el, config, data, context) {
    var name = config.name,
        checked = config.checked,
        readonly = config.readonly,
        content = config.content,
        onInit = config.onInit,
        onChange = config.onChange;
    var inputEl = el.appendChild(document.createElement('input'));
    var renderContent = null;
    inputEl.type = 'checkbox';
    inputEl.checked = (0, _defined.default)([discovery.queryBool(checked, data, context), context[name]], false);
    inputEl.readOnly = readonly;
    inputEl.addEventListener('click', function (e) {
      if (readonly) {
        e.preventDefault();
      }
    });
    inputEl.addEventListener('change', function () {
      if (typeof onChange === 'function') {
        onChange(inputEl.checked, name);

        if (renderContent !== null) {
          renderContent();
        }
      }
    });

    if (typeof onInit === 'function') {
      onInit(inputEl.checked, name);
    }

    if (content) {
      var contentEl = el.appendChild(document.createElement('span'));

      renderContent = function renderContent() {
        var localContext = name ? Object.assign({}, context, _defineProperty({}, name, inputEl.checked)) : context;
        contentEl.innerHTML = '';
        discovery.view.render(contentEl, content, data, localContext);
      };

      renderContent();
    }
  }, {
    tag: 'label'
  });
}

},{"../core/utils/defined.js":6}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('content-filter', function (el, config, data, context) {
    var _config$name = config.name,
        name = _config$name === void 0 ? 'filter' : _config$name,
        _config$type = config.type,
        type = _config$type === void 0 ? 'regexp' : _config$type,
        placeholder = config.placeholder,
        content = config.content;
    discovery.view.render(el, {
      view: 'context',
      modifiers: {
        view: 'input',
        name: name,
        type: type,
        placeholder: placeholder || 'Filter'
      },
      content: {
        view: 'block',
        className: 'content',
        content: content
      }
    }, data, context);
  });
}

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('context', function (el, config, data, context) {
    function renderContent() {
      var container = contentStartMarker.parentNode;
      var cursor = contentEndMarker.previousSibling; // clear old content
      // TODO: replace for Range

      while (cursor && cursor !== contentStartMarker) {
        cursor = cursor.previousSibling;
        container.removeChild(cursor.nextSibling);
      } // render new content


      var buffer = document.createDocumentFragment();
      discovery.view.render(buffer, content, data, localContext).then(function () {
        return contentEndMarker.parentNode.insertBefore(buffer, contentEndMarker);
      });
    }

    function updateContext(value, name) {
      if (name) {
        Object.assign(localContext, _defineProperty({}, name, value));

        if (inited) {
          renderContent();
        }
      }
    }

    var localContext = Object.assign({}, context);
    var contentStartMarker = null;
    var contentEndMarker = null;
    var inited = false;
    var _config$modifiers = config.modifiers,
        modifiers = _config$modifiers === void 0 ? [] : _config$modifiers;
    var content = config.content;

    if (!Array.isArray(modifiers)) {
      modifiers = [modifiers];
    }

    var awaitRender = discovery.view.render(el, modifiers.map(function (item) {
      return Object.assign({
        onInit: updateContext,
        onChange: updateContext
      }, item);
    }), data, context);
    contentStartMarker = el.appendChild(document.createComment('context view content start'));
    contentEndMarker = el.appendChild(document.createComment('context view content end'));
    awaitRender.then(function () {
      inited = true;
      renderContent();
    });
  }, {
    tag: false
  });
}

},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('expand', function (el, config, data, context) {
    function renderState() {
      if (contentEl) {
        contentEl.remove();
        contentEl = null;
      }

      if (expanded) {
        el.classList.add('expanded');
        contentEl = document.createElement('div');
        discovery.view.render(contentEl, content, data, context);
        el.appendChild(contentEl);
      } else {
        el.classList.remove('expanded');
      }
    }

    var expanded = config.expanded,
        title = config.title,
        content = config.content,
        onToggle = config.onToggle;
    var headerEl = el.appendChild(document.createElement('div'));
    var titleEl = headerEl.appendChild(document.createElement('div'));
    var triggerEl = headerEl.appendChild(document.createElement('div'));
    var contentEl = null;
    expanded = discovery.queryBool(expanded, data, context);
    headerEl.className = 'header';
    triggerEl.className = 'trigger';
    headerEl.addEventListener('click', function () {
      expanded = !expanded;
      renderState();

      if (typeof onToggle === 'function') {
        onToggle(expanded);
      }
    });
    discovery.view.render(titleEl, title || {
      view: 'text',
      data: '"No title"'
    }, data, context);
    renderState();
  });
}

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('fallback', function (el, config, data, context) {
    var reason = config.reason;
    var headerEl = el.appendChild(document.createElement('div'));
    var contentEl = el.appendChild(document.createElement('div'));
    headerEl.className = 'header';
    headerEl.innerText = 'Fallback view' + (reason ? '  ' + reason : '');
    contentEl.className = 'content';
    discovery.view.render(contentEl, 'struct', data, context);
  });
}

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  function render(el, config, data, context) {
    var content = config.content;
    discovery.view.render(el, content || 'text', data, context);
  }

  discovery.view.define('header', render, {
    tag: 'h2'
  });
  discovery.view.define('h1', render, {
    tag: 'h1'
  });
  discovery.view.define('h2', render, {
    tag: 'h2'
  });
  discovery.view.define('h3', render, {
    tag: 'h3'
  });
}

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('hstack', function (el, config, data, context) {
    var content = config.content;
    discovery.view.render(el, content, data, context);
  });
}

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('html', function (el, config, data) {
    el.innerHTML = data;
  }, {
    tag: 'span'
  });
}

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var base64 = _interopRequireWildcard(require("../core/utils/base64.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('image-preview', function (el, config, data) {
    var _ref = data || {},
        content = _ref.content,
        binary = _ref.binary,
        mime = _ref.mime;

    el.hidden = true;

    if (/^image\//i.test(mime)) {
      el.hidden = false;

      if (!binary) {
        content = base64.encode(content);
      }

      el.innerHTML = "<img src=\"data:".concat(mime, ";base64,").concat(content, "\">");
    }
  });
}

},{"../core/utils/base64.js":5}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "chart", {
  enumerable: true,
  get: function get() {
    return _chart.default;
  }
});
Object.defineProperty(exports, "source", {
  enumerable: true,
  get: function get() {
    return _source.default;
  }
});

var _chart = _interopRequireDefault(require("./chart.js"));

var _source = _interopRequireDefault(require("./source.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./chart.js":21,"./source.js":39}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "alerts", {
  enumerable: true,
  get: function get() {
    return _alerts.default;
  }
});
Object.defineProperty(exports, "badges", {
  enumerable: true,
  get: function get() {
    return _badges.default;
  }
});
Object.defineProperty(exports, "block", {
  enumerable: true,
  get: function get() {
    return _block.default;
  }
});
Object.defineProperty(exports, "checkbox", {
  enumerable: true,
  get: function get() {
    return _checkbox.default;
  }
});
Object.defineProperty(exports, "contentFilter", {
  enumerable: true,
  get: function get() {
    return _contentFilter.default;
  }
});
Object.defineProperty(exports, "context", {
  enumerable: true,
  get: function get() {
    return _context.default;
  }
});
Object.defineProperty(exports, "expand", {
  enumerable: true,
  get: function get() {
    return _expand.default;
  }
});
Object.defineProperty(exports, "fallback", {
  enumerable: true,
  get: function get() {
    return _fallback.default;
  }
});
Object.defineProperty(exports, "headers", {
  enumerable: true,
  get: function get() {
    return _headers.default;
  }
});
Object.defineProperty(exports, "hstack", {
  enumerable: true,
  get: function get() {
    return _hstack.default;
  }
});
Object.defineProperty(exports, "html", {
  enumerable: true,
  get: function get() {
    return _html.default;
  }
});
Object.defineProperty(exports, "imagePreview", {
  enumerable: true,
  get: function get() {
    return _imagePreview.default;
  }
});
Object.defineProperty(exports, "indicator", {
  enumerable: true,
  get: function get() {
    return _indicator.default;
  }
});
Object.defineProperty(exports, "input", {
  enumerable: true,
  get: function get() {
    return _input.default;
  }
});
Object.defineProperty(exports, "link", {
  enumerable: true,
  get: function get() {
    return _link.default;
  }
});
Object.defineProperty(exports, "listItem", {
  enumerable: true,
  get: function get() {
    return _listItem.default;
  }
});
Object.defineProperty(exports, "lists", {
  enumerable: true,
  get: function get() {
    return _lists.default;
  }
});
Object.defineProperty(exports, "section", {
  enumerable: true,
  get: function get() {
    return _section.default;
  }
});
Object.defineProperty(exports, "struct", {
  enumerable: true,
  get: function get() {
    return _struct.default;
  }
});
Object.defineProperty(exports, "switch", {
  enumerable: true,
  get: function get() {
    return _switch.default;
  }
});
Object.defineProperty(exports, "tableCell", {
  enumerable: true,
  get: function get() {
    return _tableCell.default;
  }
});
Object.defineProperty(exports, "tableRow", {
  enumerable: true,
  get: function get() {
    return _tableRow.default;
  }
});
Object.defineProperty(exports, "table", {
  enumerable: true,
  get: function get() {
    return _table.default;
  }
});
Object.defineProperty(exports, "tab", {
  enumerable: true,
  get: function get() {
    return _tab.default;
  }
});
Object.defineProperty(exports, "tabs", {
  enumerable: true,
  get: function get() {
    return _tabs.default;
  }
});
Object.defineProperty(exports, "text", {
  enumerable: true,
  get: function get() {
    return _text.default;
  }
});
Object.defineProperty(exports, "textMatch", {
  enumerable: true,
  get: function get() {
    return _textMatch.default;
  }
});
Object.defineProperty(exports, "tocItem", {
  enumerable: true,
  get: function get() {
    return _tocItem.default;
  }
});
Object.defineProperty(exports, "tocSection", {
  enumerable: true,
  get: function get() {
    return _tocSection.default;
  }
});

var _alerts = _interopRequireDefault(require("./alerts.js"));

var _badges = _interopRequireDefault(require("./badges.js"));

var _block = _interopRequireDefault(require("./block.js"));

var _checkbox = _interopRequireDefault(require("./checkbox.js"));

var _contentFilter = _interopRequireDefault(require("./content-filter.js"));

var _context = _interopRequireDefault(require("./context.js"));

var _expand = _interopRequireDefault(require("./expand.js"));

var _fallback = _interopRequireDefault(require("./fallback.js"));

var _headers = _interopRequireDefault(require("./headers.js"));

var _hstack = _interopRequireDefault(require("./hstack.js"));

var _html = _interopRequireDefault(require("./html.js"));

var _imagePreview = _interopRequireDefault(require("./image-preview.js"));

var _indicator = _interopRequireDefault(require("./indicator.js"));

var _input = _interopRequireDefault(require("./input.js"));

var _link = _interopRequireDefault(require("./link.js"));

var _listItem = _interopRequireDefault(require("./list-item.js"));

var _lists = _interopRequireDefault(require("./lists.js"));

var _section = _interopRequireDefault(require("./section.js"));

var _struct = _interopRequireDefault(require("./struct.js"));

var _switch = _interopRequireDefault(require("./switch.js"));

var _tableCell = _interopRequireDefault(require("./table-cell.js"));

var _tableRow = _interopRequireDefault(require("./table-row.js"));

var _table = _interopRequireDefault(require("./table.js"));

var _tab = _interopRequireDefault(require("./tab.js"));

var _tabs = _interopRequireDefault(require("./tabs.js"));

var _text = _interopRequireDefault(require("./text.js"));

var _textMatch = _interopRequireDefault(require("./text-match.js"));

var _tocItem = _interopRequireDefault(require("./toc-item.js"));

var _tocSection = _interopRequireDefault(require("./toc-section.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./alerts.js":18,"./badges.js":19,"./block.js":20,"./checkbox.js":22,"./content-filter.js":23,"./context.js":24,"./expand.js":25,"./fallback.js":26,"./headers.js":27,"./hstack.js":28,"./html.js":29,"./image-preview.js":30,"./indicator.js":33,"./input.js":34,"./link.js":35,"./list-item.js":36,"./lists.js":37,"./section.js":38,"./struct.js":40,"./switch.js":41,"./tab.js":42,"./table-cell.js":43,"./table-row.js":44,"./table.js":45,"./tabs.js":46,"./text-match.js":47,"./text.js":48,"./toc-item.js":49,"./toc-section.js":50}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('indicator', function (el, config, data, context) {
    var value = config.value,
        label = config.label;

    var _ref = data || {},
        href = _ref.href;

    var valueEl = el.appendChild(document.createElement('div'));
    var labelEl = el.appendChild(document.createElement('div'));
    valueEl.className = 'value';
    discovery.view.render(valueEl, value || 'text:value', data, context);
    labelEl.className = 'label';
    discovery.view.render(labelEl, label || 'text:label', data, context);

    if (href) {
      el.href = href;
    }
  }, {
    tag: 'a'
  });
}

},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _defined = _interopRequireDefault(require("../core/utils/defined.js"));

var _safeFilterRx = _interopRequireDefault(require("../core/utils/safe-filter-rx.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-env browser */
function _default(discovery) {
  var factories = {
    regexp: function regexp(value) {
      return value ? (0, _safeFilterRx.default)(value) : null;
    },
    string: function string(value) {
      return value;
    }
  };
  discovery.view.define('input', function (el, config, data, context) {
    var name = config.name,
        value = config.value,
        _config$type = config.type,
        type = _config$type === void 0 ? 'regexp' : _config$type,
        placeholder = config.placeholder,
        onInit = config.onInit,
        onChange = config.onChange;
    var factory = factories[type] || factories.string;
    var inputEl = el.appendChild(document.createElement('input'));
    var lastInput = (0, _defined.default)([value, context[name]], '');
    inputEl.value = lastInput;
    inputEl.placeholder = (placeholder || '') + (factory !== factories.string ? ' (' + type + ')' : '');
    inputEl.addEventListener('input', function () {
      var newInput = inputEl.value.trim();

      if (lastInput !== newInput) {
        lastInput = newInput;

        if (typeof onChange === 'function') {
          onChange(factory(newInput), name);
        }
      }
    });

    if (typeof onInit === 'function') {
      onInit(factory(inputEl.value.trim()), name);
    }
  });
}

},{"../core/utils/defined.js":6,"../core/utils/safe-filter-rx.js":11}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('link', function (el, config, data, context) {
    var content = config.content;

    var _ref = data || {},
        href = _ref.href,
        text = _ref.text,
        external = _ref.external;

    el.href = href;

    if (external) {
      el.setAttribute('target', '_blank');
    }

    if (content) {
      discovery.view.render(el, content, data, context);
    } else {
      el.appendChild(document.createTextNode(String(text)));
    }
  }, {
    tag: 'a'
  });
}

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('list-item', function (el, config, data, context) {
    var content = config.content;
    discovery.view.render(el, content, data, context);
  }, {
    tag: 'li'
  });
}

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  function render(el, config, data, context) {
    var _config$item = config.item,
        item = _config$item === void 0 ? 'text' : _config$item,
        configLimit = config.limit,
        emptyText = config.emptyText;
    var limit = isNaN(configLimit) ? 25 : parseInt(configLimit, 10);

    if (emptyText !== false && emptyText !== '') {
      el.setAttribute('emptyText', emptyText || 'Empty list');
    }

    if (!Array.isArray(data) && data) {
      data = [data];
    }

    if (Array.isArray(data)) {
      discovery.view.renderList(el, {
        view: 'list-item',
        content: item
      }, data, context, 0, limit);
    }
  }

  discovery.view.define('list', render);
  discovery.view.define('inline-list', render);
  discovery.view.define('comma-list', render);
  discovery.view.define('ol', render, {
    tag: 'ol'
  });
  discovery.view.define('ul', render, {
    tag: 'ul'
  });
}

},{}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('section', function (el, config, data, context) {
    var header = config.header,
        content = config.content;
    discovery.view.render(el, [{
      view: 'header',
      content: header
    }, content], data, context);
  });
}

},{}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _hitext = _interopRequireDefault(require("/gen/hitext.js"));

var _hitextPrismjs = _interopRequireDefault(require("/gen/hitext-prismjs.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-env browser */
var mimeToSyntax = {
  'application/javascript': 'javascript',
  'application/x-httpd-php': 'php',
  'application/xml': 'xml',
  'application/json': 'json',
  'text/html': 'html',
  'text/css': 'css',
  'text/stylus': 'stylus',
  'text/yaml': 'yaml',
  'image/svg+xml': 'svg'
};

var printer = _hitext.default.printer.html.fork(_hitextPrismjs.default.printer.html).fork({
  hooks: Object.assign({}, _hitext.default.printer.html.hooks, {
    error: {
      open: function open() {
        return '<span class="spotlight spotlight-error">';
      },
      close: function close() {
        return '</span>';
      }
    },
    link: {
      open: function open(href) {
        return '<a href="#' + href + '" class="spotlight">';
      },
      close: function close() {
        return '</a>';
      }
    },
    ignore: {
      open: function open() {
        return '<span class="spotlight spotlight-ignore">';
      },
      close: function close() {
        return '</span>';
      }
    }
  })
});

function _default(discovery) {
  discovery.view.define('source', function (el, config, data) {
    var mime = data.mime,
        binary = data.binary,
        size = data.size,
        content = data.content,
        error = data.error,
        disabled = data.disabled;
    var syntax = data.syntax,
        refs = data.refs;

    if (disabled) {
      el.classList.add('disabled');
      el.innerText = error;
      return;
    }

    if (error) {
      el.classList.add('error');
      el.innerText = error;
      return;
    }

    if (!syntax && mime in mimeToSyntax) {
      syntax = mimeToSyntax[mime];
    }

    if (!Array.isArray(refs)) {
      refs = [];
    }

    if (binary) {
      el.innerHTML = 'Binary content' + (typeof size === 'number' ? ' (' + size + ' bytes)' : '');
    } else {
      el.innerHTML = '<div class="lines">' + content.split(/\r\n?|\n/g).map(function (_, idx) {
        return '<span>' + (idx + 1) + '</span>';
      }).join('') + '</div>' + _hitext.default.decorate(content, [function (source, addRange) {
        if (syntax) {
          (0, _hitextPrismjs.default)(syntax || 'extend')(source, addRange);
        }
      }, function (source, addRange) {
        return refs.forEach(function (ref) {
          if (ref.range) {
            addRange(ref.ignore || !ref.resolved ? 'ignore' : ref.broken ? 'error' : 'link', ref.range[0], ref.range[1], 'file:' + ref.resolved // FIXME: should not use a view reference here
            );
          }
        });
      }], printer);
    }
  });
}

},{"/gen/hitext-prismjs.js":54,"/gen/hitext.js":55}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _html = require("../core/utils/html.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hasOwnProperty = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var collapseEl = document.createElement('span');
var LIST_ITEM_LIMIT = 50;
var ARRAY_ITEM_LIMIT = 4;
var OBJECT_KEYS_LIMIT = 4;
collapseEl.className = 'struct-collapse-value';

function token(type, str) {
  return "<span class=\"".concat(type, "\">").concat(str, "</span>");
}

function more(num) {
  return token('more', '' + num + ' more');
}

function value2htmlString(value, linear, deep) {
  switch (_typeof(value)) {
    case 'boolean':
    case 'undefined':
      return token('keyword', value);

    case 'number':
    case 'bigint':
      return token('number', value);

    case 'string':
      return token('string', (0, _html.escapeHtml)(JSON.stringify(value)));

    case 'symbol':
      return token('symbol', value);

    case 'function':
      return 'n';

    case 'object':
      {
        if (value === null) {
          return token('keyword', 'null');
        }

        if (Array.isArray(value)) {
          var content = value.slice(0, ARRAY_ITEM_LIMIT).map(function (val) {
            return value2htmlString(val, !deep, deep);
          }).join(', ');
          return '[' + content + (value.length > ARRAY_ITEM_LIMIT ? ', ' + more(value.length - ARRAY_ITEM_LIMIT) + ' ' : '') + ']';
        } // NOTE: constructor check and instanceof doesn't work here,
        // because value comes from sandbox


        if (toString.call(value) === '[object Date]') {
          return token('Date', value);
        }

        if (toString.call(value) === '[object RegExp]') {
          return token('RegExp', value);
        }

        if (!linear) {
          var res = [];
          var limit = OBJECT_KEYS_LIMIT;

          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              if (limit > 0) {
                res.push(token('property', key) + ': ' + value2htmlString(value[key], !deep, deep));
              }

              limit--;
            }
          }

          if (limit < 0) {
            res.push(more(Math.abs(limit)));
          }

          return res.length ? '{ ' + res.join(', ') + ' }' : '{}';
        } else {
          for (var _key in value) {
            if (hasOwnProperty.call(value, _key)) {
              return '{}';
            }
          }

          return '{}';
        }
      }

    default:
      return 'unknown type `' + _typeof(value) + '`';
  }
}

function getValueType(value) {
  if (Array.isArray(value)) {
    return 'array';
  }

  if (value && toString.call(value) === '[object Object]') {
    return 'object';
  }

  return 'other';
}

function isValueExpandable(value) {
  var type = getValueType(value);
  return type === 'array' && value.length > 0 || type === 'object' && Object.keys(value).length > 0;
}

function appendText(el, text) {
  el.appendChild(document.createTextNode(text));
}

function _default(discovery) {
  function maybeExpand(el, value) {
    if (isValueExpandable(value)) {
      el.classList.add('struct-expand-value');
      elementDataMap.set(el, value);
      return true;
    }
  }

  function collapseValue(el) {
    var data = elementDataMap.get(el);

    if (isValueExpandable(data)) {
      el.classList.add('struct-expand-value');
    }

    el.innerHTML = value2htmlString(data);
  }

  function expandValue(el, expandLimit) {
    var data = elementDataMap.get(el);
    el.classList.remove('struct-expand-value');

    switch (getValueType(data)) {
      case 'array':
        el.innerHTML = '';
        appendText(el, '[');
        el.appendChild(collapseEl.cloneNode(true));
        render(el, data, false, expandLimit, function (key, value) {
          return '<span class="value">' + value2htmlString(value) + '</span>';
        });
        appendText(el, ']');
        break;

      case 'object':
        el.innerHTML = '';
        appendText(el, '{');
        el.appendChild(collapseEl.cloneNode(true));
        render(el, data, true, expandLimit, function (key, value) {
          return '<span class="label">' + '\xA0 \xA0 <span class="property">' + (0, _html.escapeHtml)(key) + '</span>:\xA0' + '</span>' + '<span class="value">' + value2htmlString(value) + '</span>';
        });
        appendText(el, '}');
        break;
    }
  }

  function render(container, data, keys, expandLimit, fn) {
    discovery.view.render(container, {
      view: 'list',
      limit: LIST_ITEM_LIMIT,
      item: function item(el, config, key, _ref) {
        var index = _ref.index,
            array = _ref.array;
        var value = keys ? data[key] : key;
        el.className = 'entry-line';
        el.innerHTML = fn(keys ? key : index, value);

        if (maybeExpand(el.lastChild, value) && expandLimit > 1) {
          expandValue(el.lastChild, expandLimit - 1);
        }

        if (index !== array.length - 1) {
          el.appendChild(document.createTextNode(','));
        }
      }
    }, keys ? Object.keys(data) : data);
  }

  var elementDataMap = new WeakMap();

  var clickHandler = function clickHandler(e) {
    var cursor = e.target;

    while (cursor && cursor.classList) {
      if (cursor.classList.contains('struct-expand-value')) {
        expandValue(cursor, 1);
        break;
      }

      if (cursor.classList.contains('struct-collapse-value')) {
        collapseValue(cursor.parentNode);
        break;
      }

      cursor = cursor.parentNode;
    }
  }; // single event handler for all `struct` view instances


  document.addEventListener('click', clickHandler, false);
  discovery.view.define('struct', function (el, config, data) {
    var expanded = config.expanded;
    elementDataMap.set(el, data);

    if (expanded && isValueExpandable(data)) {
      expandValue(el, expanded);
    } else {
      collapseValue(el);
    }
  });
  return function () {
    document.removeEventListener('click', clickHandler, false);
  };
}

},{"../core/utils/html.js":9}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('switch', function (el, config, data, context) {
    var content = config.content;
    var renderContent = 'alert-warning:"No case choosen"';

    if (Array.isArray(content)) {
      for (var i = 0; i < content.length; i++) {
        if (content[i] && discovery.queryBool(content[i].case || true, data, context)) {
          renderContent = content[i].content;
          break;
        }
      }
    }

    discovery.view.render(el, renderContent, data, context);
  }, {
    tag: false
  });
}

},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('tab', function (el, config, data, context) {
    var content = config.content,
        active = config.active,
        onClick = config.onClick;
    var text = data.text,
        value = data.value;

    if (typeof onClick === 'function') {
      el.addEventListener('click', function () {
        return onClick(value);
      });
    }

    if (active) {
      el.classList.add('active');
    }

    if (content) {
      discovery.view.render(el, content, data, context);
    } else {
      el.innerText = text || value;
    }
  });
}

},{}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */
function defaultCellRender(el, data) {
  if (Array.isArray(data)) {
    el.className = 'details complex';
    el.innerText = data.length ? '[]' : '[]';
    return;
  }

  if (data && _typeof(data) === 'object') {
    el.className = 'details complex';

    for (var k in data) {
      if (Object.prototype.hasOwnProperty.call(data, k)) {
        el.innerText = '{}';
        return;
      }
    }

    el.innerText = '{}';
    return;
  }

  if (data === undefined) {
    el.innerText = '';
    return;
  }

  if (typeof data === 'number') {
    el.className = 'number';
  }

  el.innerText = data;
}

function _default(discovery) {
  discovery.view.define('table-cell', function (el, config, data, context) {
    var content = config.content,
        details = config.details;

    if (details) {
      el.className = 'details';
    }

    if (content) {
      discovery.view.render(el, content, data, context);
    } else {
      defaultCellRender(el, data);
    }

    if (el.classList.contains('details')) {
      el.addEventListener('click', function (e) {
        var node = e.target;

        if (node === el) {
          var rowEl = node.parentNode;
          var bodyEl = rowEl.parentNode;
          var currentDetailsEl = Array.from(bodyEl.querySelectorAll('.view-table-cell.details-expanded')).find(function (td) {
            return td.parentNode.parentNode === bodyEl;
          });
          var detailsEl = null;

          if (currentDetailsEl) {
            var currentDetailsRowEl = currentDetailsEl.parentNode;
            currentDetailsEl.classList.remove('details-expanded');

            if (currentDetailsEl === el) {
              rowEl.parentNode.removeChild(rowEl.nextSibling);
              return;
            }

            if (currentDetailsRowEl !== rowEl) {
              currentDetailsRowEl.parentNode.removeChild(currentDetailsRowEl.nextSibling);
            } else {
              detailsEl = rowEl.nextSibling.firstChild;
              detailsEl.innerHTML = '';
            }
          }

          if (detailsEl === null) {
            detailsEl = rowEl.parentNode.insertBefore(document.createElement('tr'), rowEl.nextSibling).appendChild(document.createElement('td'));
            detailsEl.parentNode.className = 'view-table-cell-details-content';
            detailsEl.colSpan = 1000;
          }

          el.classList.add('details-expanded');
          discovery.view.render(detailsEl, details || {
            view: 'struct',
            expanded: true
          }, data, context);
        }
      });
    }
  }, {
    tag: 'td'
  });
}

},{}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('table-row', function (el, config, data, context) {
    var cols = config.cols;

    if (Array.isArray(cols)) {
      cols.forEach(function (col, index) {
        return discovery.view.render(el, col, data, Object.assign({}, context, {
          colIndex: index
        }));
      });
    }
  }, {
    tag: 'tr'
  });
}

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */
var hasOwnProperty = Object.prototype.hasOwnProperty;

function configFromName(name) {
  return {
    header: name,
    view: 'table-cell',
    data: function data(obj) {
      return obj[name];
    }
  };
}

function resolveColConfig(config) {
  return typeof config === 'string' ? {
    data: function data(_data) {
      return _data;
    },
    content: config
  } : Object.assign({
    data: function data(_data2) {
      return _data2;
    }
  }, config);
}

function _default(discovery) {
  discovery.view.define('table', function (el, config, data, context) {
    var limit = isNaN(config.limit) ? 25 : parseInt(config.limit, 10);
    var cols = config.cols;
    var colsMap = cols && _typeof(cols) === 'object' ? cols : {};
    var scalarCol = false;

    if (!Array.isArray(data) && data) {
      data = [data];
    }

    var headEl = el.appendChild(document.createElement('thead'));
    var bodyEl = el.appendChild(document.createElement('tbody'));
    var moreEl = el.appendChild(document.createElement('tbody')).appendChild(document.createElement('tr')).appendChild(document.createElement('td'));

    if (Array.isArray(cols)) {
      cols = cols.map(function (def, idx) {
        return typeof def === 'string' ? configFromName(def) : Object.assign({
          header: 'col' + idx,
          view: 'table-cell',
          data: function data(_data3) {
            return _data3;
          }
        }, def);
      });
    } else if (Array.isArray(data)) {
      var colNames = new Set();
      cols = [];
      data.forEach(function (item) {
        if (item && _typeof(item) === 'object') {
          for (var key in item) {
            colNames.add(key);
          }
        } else {
          scalarCol = true;
        }
      });
      Object.keys(colsMap).forEach(function (name) {
        return colNames.add(name);
      });

      if (scalarCol) {
        cols.push({
          header: '[value]',
          view: 'table-cell',
          data: function data(_data4) {
            return String(_data4);
          }
        });
      }

      colNames.forEach(function (name) {
        return cols.push(Object.assign(configFromName(name), hasOwnProperty.call(colsMap, name) ? resolveColConfig(colsMap[name]) : null));
      });
    } else {
      console.warn('config.cols and data is not an array, no way to build a table');
      return;
    }

    cols.forEach(function (col) {
      return headEl.appendChild(document.createElement('th')).innerText = col.header;
    });
    moreEl.colSpan = 1000;
    discovery.view.renderList(bodyEl, {
      view: 'table-row',
      cols: cols
    }, data, context, 0, limit, moreEl);
  });
}

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('tabs', function (el, config, data, context) {
    function renderContent(value) {
      currentValue = value;

      if (Array.isArray(tabs)) {
        tabsEl.innerHTML = '';
        tabs.forEach(function (tab) {
          return discovery.view.render(tabsEl, {
            view: 'tab',
            active: tab.value === currentValue,
            onClick: renderContent
          }, tab, context);
        });
      }

      contentEl.innerHTML = '';
      discovery.view.render(contentEl, content, data, Object.assign({}, context, _defineProperty({}, name, value)));
    }

    var tabsEl = el.appendChild(document.createElement('div'));
    var contentEl = el.appendChild(document.createElement('div'));
    var content = config.content;
    var name = config.name,
        tabs = config.tabs;
    var currentValue;
    tabsEl.className = 'view-tabs-buttons';
    contentEl.className = 'view-tabs-content';

    if (typeof name !== 'string') {
      name = 'filter';
    }

    if (Array.isArray(tabs)) {
      tabs = tabs.map(function (tab) {
        var type = _typeof(tab);

        if (type === 'string' || type === 'number' || type === 'boolean') {
          tab = {
            value: tab
          };
        }

        if (currentValue === undefined || tab.active) {
          currentValue = tab.value;
        }

        return tab;
      });

      if ('value' in config && tabs.some(function (tab) {
        return tab.value === config.value;
      })) {
        currentValue = config.value;
      }
    } else {
      tabs = [];
    }

    renderContent(currentValue);
  });
}

},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
var toString = Object.prototype.toString;

function _default(discovery) {
  var matchWrapperEl = document.createElement('span');
  matchWrapperEl.className = 'view-text-match';
  discovery.view.define('text-match', function (el, config, data) {
    var text = data.text,
        match = data.match;
    var parts = toString.call(match) === '[object RegExp]' ? String(text).split(match) : [String(text)];
    parts.forEach(function (text, idx) {
      if (text !== '') {
        var container = el;

        if (idx % 2) {
          container = container.appendChild(matchWrapperEl.cloneNode());
        }

        container.appendChild(document.createTextNode(text));
      }
    });
  }, {
    tag: false
  });
}

},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('text', function (el, config, data) {
    el.appendChild(document.createTextNode(String(data)));
  }, {
    tag: false
  });
}

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('toc-item', function (el, config, data, context) {
    discovery.view.render(el, [{
      view: 'link',
      data: '{ href, text: caption, match }',
      content: 'text-match'
    }, {
      view: 'pill-badge',
      className: 'item-error-label',
      visible: 'errors',
      data: '{ text: errors.size() }'
    }], data, context);
  });
}

},{}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

/* eslint-env browser */
function _default(discovery) {
  discovery.view.define('toc-section', function (el, config, data, context) {
    var header = config.header,
        content = config.content;
    discovery.view.render(el, [{
      view: 'block',
      className: 'header',
      content: header
    }, {
      view: 'block',
      className: 'content',
      content: content
    }], data, context);
  }, {
    tag: 'section'
  });
}

},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _view = _interopRequireDefault(require("../core/view.js"));

var _page = _interopRequireDefault(require("../core/page.js"));

var views = _interopRequireWildcard(require("../views/index.js"));

var pages = _interopRequireWildcard(require("../pages/index.js"));

var _dom = require("../core/utils/dom.js");

var fetchFileApi = _interopRequireWildcard(require("../core/utils/fetch-file-content.js"));

var _jora = _interopRequireDefault(require("/gen/jora.js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// FIXME: generated file to make it local
var hasOwnProperty = Object.prototype.hasOwnProperty;

function _apply(fn, host) {
  if (typeof fn === 'function') {
    fn.call(window, host);
  }
}

function equal(a, b) {
  if (a === b) {
    return true;
  }

  for (var key in a) {
    if (hasOwnProperty.call(a, key)) {
      if (!hasOwnProperty.call(b, key) || a[key] !== b[key]) {
        return false;
      }
    }
  }

  for (var _key in b) {
    if (hasOwnProperty.call(b, _key)) {
      if (!hasOwnProperty.call(a, _key) || a[_key] !== b[_key]) {
        return false;
      }
    }
  }

  return true;
}

var Widget =
/*#__PURE__*/
function () {
  function Widget(container, options) {
    _classCallCheck(this, Widget);

    Object.assign(this, fetchFileApi);
    this.options = options || {};
    this.dev = Boolean(this.options.dev);
    this.view = new _view.default(this);
    this.page = new _page.default(this.view);
    this.badges = [];

    this.prepare = function (data) {
      return data;
    };

    this.pageId = 'default';
    this.pageRef = null;
    this.pageParams = {};
    this.scheduledRenderPage = null;
    this.containerEl = null;
    this.pageContentEl = null;
    this.sidebarEl = null;
    this.badgesEl = null;
    this.queryExtensions = {
      query: this.query,
      pick: function pick(current, key) {
        return current ? current[key || 0] : undefined;
      }
    };
    this.apply(views);
    this.apply(pages);
    this.setContainer(container);
  }

  _createClass(Widget, [{
    key: "apply",
    value: function apply(extensions) {
      var _this = this;

      if (Array.isArray(extensions)) {
        extensions.forEach(function (extension) {
          return _apply(extension, _this);
        });
      } else if (typeof extensions === 'function') {
        _apply(extensions, this);
      } else if (extensions) {
        this.apply(Object.values(extensions));
      } else {
        console.error('Bad type of extension:', extensions);
      }
    } //
    // Data
    //

  }, {
    key: "setPrepare",
    value: function setPrepare(fn) {
      if (typeof fn !== 'function') {
        throw new Error('An argument should be a function');
      }

      this.prepare = fn;
    }
  }, {
    key: "setData",
    value: function setData(data) {
      var _this2 = this;

      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var preparePromise = Promise.resolve(this.prepare(data, function (value) {
        return data = value;
      })).then(function () {
        if (_this2.preparePromise !== preparePromise) {
          return;
        }

        _this2.data = data;
        _this2.context = context;

        _this2.renderSidebar();

        _this2.renderPage();
      });
      this.preparePromise = preparePromise;
      return preparePromise;
    } //
    // Data query
    //

  }, {
    key: "query",
    value: function query(_query, data, context) {
      switch (_typeof(_query)) {
        case 'function':
          return _query(data, context);

        case 'string':
          return (0, _jora.default)(_query, this.queryExtensions)(data, context);

        default:
          return _query;
      }
    }
  }, {
    key: "queryBool",
    value: function queryBool() {
      try {
        return _jora.default.buildin.bool(this.query.apply(this, arguments));
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "addQueryHelpers",
    value: function addQueryHelpers(extensions) {
      Object.assign(this.queryExtensions, extensions);
    } //
    // UI
    //

  }, {
    key: "setContainer",
    value: function setContainer(container) {
      var _this3 = this;

      this.containerEl = container;

      if (this.containerEl) {
        this.containerEl.classList.add('discovery');
        this.containerEl.appendChild(this.sidebarEl = (0, _dom.createElement)('nav', 'discovery-sidebar'));
        this.containerEl.appendChild((0, _dom.createElement)('main', 'discovery-content', [this.badgesEl = (0, _dom.createElement)('div', 'discovery-content-badges'), this.pageContentEl = (0, _dom.createElement)('article')]));
        this.badges.forEach(function (badge) {
          return _this3.badgesEl.appendChild(badge.el);
        });
      } else {
        this.sidebarEl = null;
        this.badgesEl = null;
        this.pageContentEl = null;
      }
    }
  }, {
    key: "addBadge",
    value: function addBadge(caption, action, visible) {
      var badge = {
        el: document.createElement('div'),
        visible: typeof visible === 'function' ? visible : function () {
          return true;
        }
      };
      badge.el.className = 'badge';
      badge.el.addEventListener('click', action);
      badge.el.hidden = !badge.visible(this);

      if (typeof caption === 'function') {
        caption(badge.el);
      } else {
        badge.el.innerHTML = caption;
      }

      if (this.badgesEl) {
        this.badgesEl.appendChild(badge.el);
      }

      this.badges.push(badge);
      return badge;
    }
  }, {
    key: "getSidebarContext",
    value: function getSidebarContext() {
      return this.context;
    }
  }, {
    key: "renderSidebar",
    value: function renderSidebar() {
      if (this.view.isDefined('sidebar')) {
        var t = Date.now();
        this.view.render(this.sidebarEl, 'sidebar', this.data, this.getSidebarContext()).then(function () {
          return console.log('[Discovery] renderSidebar', Date.now() - t);
        });
      }
    }
  }, {
    key: "getPageContext",
    value: function getPageContext() {
      return _objectSpread({
        page: this.pageId,
        id: this.pageRef,
        params: this.pageParams,
        dev: this.dev
      }, this.context);
    }
  }, {
    key: "getPageOption",
    value: function getPageOption(name, fallback) {
      var page = this.page.pages[this.pageId];
      return page && name in page.options ? page.options[name] : fallback;
    }
  }, {
    key: "setPage",
    value: function setPage(id, ref, params) {
      this.pageId = id || 'default';
      this.pageRef = ref;
      this.setPageParams(params);
      this.scheduleRenderPage();
    }
  }, {
    key: "setPageParams",
    value: function setPageParams(params) {
      if (!equal(params, this.pageParams)) {
        this.pageParams = params || {};
        this.scheduleRenderPage();
        return true;
      }
    }
  }, {
    key: "definePage",
    value: function definePage() {
      var _this$page;

      (_this$page = this.page).define.apply(_this$page, arguments);
    }
  }, {
    key: "scheduleRenderPage",
    value: function scheduleRenderPage() {
      var _this4 = this;

      if (!this.scheduledRenderPage) {
        this.scheduledRenderPage = setTimeout(function () {
          return _this4.renderPage();
        }, 0);
      }
    }
  }, {
    key: "renderPage",
    value: function renderPage() {
      var _this5 = this;

      if (this.scheduledRenderPage) {
        this.scheduledRenderPage = clearTimeout(this.scheduledRenderPage);
      }

      this.pageContentEl = this.page.render(this.pageContentEl, this.pageId, this.data, this.getPageContext());
      this.badges.forEach(function (badge) {
        return badge.el.hidden = !badge.visible(_this5);
      });

      if (this.pageParams.dzen) {
        this.containerEl.dataset.dzen = true;
      } else {
        delete this.containerEl.dataset.dzen;
      }
    }
  }]);

  return Widget;
}();

exports.default = Widget;

},{"../core/page.js":3,"../core/utils/dom.js":7,"../core/utils/fetch-file-content.js":8,"../core/view.js":12,"../pages/index.js":15,"../views/index.js":32,"/gen/jora.js":56}],52:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = {};
var _module = undefined;
var CodeMirror;

var _define = function define() {
  var fn = arguments[arguments.length - 1];
  CodeMirror = fn();
  _define = undefined;
};

_define.amd = true; // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE
// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  (typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object' && typeof _module !== 'undefined' ? _module.exports = factory() : typeof _define === 'function' && _define.amd ? _define(factory) : global.CodeMirror = factory();
})(void 0, function () {
  'use strict'; // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var userAgent = navigator.userAgent;
  var platform = navigator.platform;
  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);
  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
  var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.

  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);
  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);

  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }

  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X


  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;

  function classTest(cls) {
    return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
  }

  var rmClass = function rmClass(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);

    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }

    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);

    if (className) {
      e.className = className;
    }

    if (style) {
      e.style.cssText = style;
    }

    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i = 0; i < content.length; ++i) {
        e.appendChild(content[i]);
      }
    }

    return e;
  } // wrapper for elt, which removes the elt from the accessibility tree


  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }

  var range;

  if (document.createRange) {
    range = function range(node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function range(node, start, end) {
      var r = document.body.createTextRange();

      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }

      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      {
        child = child.parentNode;
      }

    if (parent.contains) {
      return parent.contains(child);
    }

    do {
      if (child.nodeType == 11) {
        child = child.host;
      }

      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;

    try {
      activeElement = document.activeElement;
    } catch (e) {
      activeElement = document.body || null;
    }

    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }

    return activeElement;
  }

  function addClass(node, cls) {
    var current = node.className;

    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }

  function joinClasses(a, b) {
    var as = a.split(" ");

    for (var i = 0; i < as.length; i++) {
      if (as[i] && !classTest(as[i]).test(b)) {
        b += " " + as[i];
      }
    }

    return b;
  }

  var selectInput = function selectInput(node) {
    node.select();
  };

  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    {
      selectInput = function selectInput(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie) // Suppress mysterious IE10 errors
    {
      selectInput = function selectInput(node) {
        try {
          node.select();
        } catch (_e) {}
      };
    }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }

  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }

    for (var prop in obj) {
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
        target[prop] = obj[prop];
      }
    }

    return target;
  } // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.


  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);

      if (end == -1) {
        end = string.length;
      }
    }

    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);

      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i);
      }

      n += nextTab - i;
      n += tabSize - n % tabSize;
      i = nextTab + 1;
    }
  }

  var Delayed = function Delayed() {
    this.id = null;
  };

  Delayed.prototype.set = function (ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i) {
      if (array[i] == elt) {
        return i;
      }
    }

    return -1;
  } // Number of pixels added to scroller and sizer to hide scrollbar


  var scrollerGap = 30; // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.

  var Pass = {
    toString: function toString() {
      return "CodeMirror.Pass";
    }
  }; // Reused option objects for setSelection & friends

  var sel_dontScroll = {
    scroll: false
  };
  var sel_mouse = {
    origin: "*mouse"
  };
  var sel_move = {
    origin: "+move"
  }; // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.

  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);

      if (nextTab == -1) {
        nextTab = string.length;
      }

      var skipped = nextTab - pos;

      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }

      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;

      if (col >= goal) {
        return pos;
      }
    }
  }

  var spaceStrs = [""];

  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }

    return spaceStrs[n];
  }

  function lst(arr) {
    return arr[arr.length - 1];
  }

  function map(array, f) {
    var out = [];

    for (var i = 0; i < array.length; i++) {
      out[i] = f(array[i], i);
    }

    return out;
  }

  function insertSorted(array, value, score) {
    var pos = 0,
        priority = score(value);

    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }

    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;

    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }

    if (props) {
      copyObj(props, inst);
    }

    return inst;
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }

  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }

    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }

    return helper.test(ch);
  }

  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }

    return true;
  } // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.


  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.


  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }

    return pos;
  } // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.


  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;

    for (;;) {
      if (from == to) {
        return from;
      }

      var midF = (from + to) / 2,
          mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);

      if (mid == from) {
        return pred(mid) ? from : to;
      }

      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  } // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.


  function Display(place, doc, input) {
    var d = this;
    this.input = input; // Covers bottom-right square when both scrollbars are present.

    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true"); // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.

    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true"); // Will contain the actual code, positioned to cover the viewport.

    d.lineDiv = eltP("div", null, "CodeMirror-code"); // Elements are added to these to represent selection and cursors.

    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors"); // A visibility: hidden element used to find the size of things.

    d.measure = elt("div", null, "CodeMirror-measure"); // When lines outside of the viewport are measured, they are drawn in this.

    d.lineMeasure = elt("div", null, "CodeMirror-measure"); // Wraps everything that needs to exist inside the vertically-padded coordinate system

    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines"); // Moved around its parent to cover visible view.

    d.mover = elt("div", [lines], null, "position: relative"); // Set to the height of the document, allowing scrolling.

    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.

    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"); // Will contain the gutters, if any.

    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null; // Actual scrollable element.

    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1"); // The element in which the editor lives.

    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)

    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }

    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }

    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    } // Current rendered range (may be bigger than the view window).


    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.

    d.view = [];
    d.renderedView = null; // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.

    d.externalMeasured = null; // Empty space (in pixels) above the view

    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)

    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.

    d.alignWidgets = false;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.

    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false; // Used for measuring wheel scrolling granularity

    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.

    d.shift = false; // Used to track whether anything happened since the context menu
    // was opened.

    d.selForContextMenu = null;
    d.activeTouch = null;
    input.init(d);
  } // Find the line object corresponding to the given line number.


  function getLine(doc, n) {
    n -= doc.first;

    if (n < 0 || n >= doc.size) {
      throw new Error("There is no line " + (n + doc.first) + " in the document.");
    }

    var chunk = doc;

    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i],
            sz = child.chunkSize();

        if (n < sz) {
          chunk = child;
          break;
        }

        n -= sz;
      }
    }

    return chunk.lines[n];
  } // Get the part of a document between two positions, as an array of
  // strings.


  function getBetween(doc, start, end) {
    var out = [],
        n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;

      if (n == end.line) {
        text = text.slice(0, end.ch);
      }

      if (n == start.line) {
        text = text.slice(start.ch);
      }

      out.push(text);
      ++n;
    });
    return out;
  } // Get the lines between from and to, as array of strings.


  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    }); // iter aborts when callback returns truthy value

    return out;
  } // Update the height of a line, propagating the height change
  // upwards to parent nodes.


  function updateLineHeight(line, height) {
    var diff = height - line.height;

    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  } // Given a line object, find its line number by walking up through
  // its parent links.


  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }

    var cur = line.parent,
        no = indexOf(cur.lines, line);

    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) {
          break;
        }

        no += chunk.children[i].chunkSize();
      }
    }

    return no + cur.first;
  } // Find the line at the given vertical position, using the height
  // information in the document tree.


  function _lineAtHeight(chunk, h) {
    var n = chunk.first;

    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1],
            ch = child.height;

        if (h < ch) {
          chunk = child;
          continue outer;
        }

        h -= ch;
        n += child.chunkSize();
      }

      return n;
    } while (!chunk.lines);

    var i = 0;

    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i],
          lh = line.height;

      if (h < lh) {
        break;
      }

      h -= lh;
    }

    return n + i;
  }

  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  } // A Pos instance represents a position within the text.


  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;

    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }

    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  } // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.


  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }

  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }

  function copyPos(x) {
    return Pos(x.line, x.ch);
  }

  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }

  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  } // Most of the external API clips given positions to make sure they
  // actually exist within the document.


  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }

  function _clipPos(doc, pos) {
    if (pos.line < doc.first) {
      return Pos(doc.first, 0);
    }

    var last = doc.first + doc.size - 1;

    if (pos.line > last) {
      return Pos(last, getLine(doc, last).text.length);
    }

    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }

  function clipToLen(pos, linelen) {
    var ch = pos.ch;

    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }

  function clipPosArray(doc, array) {
    var out = [];

    for (var i = 0; i < array.length; i++) {
      out[i] = _clipPos(doc, array[i]);
    }

    return out;
  } // Optimize some code when these features are not used.


  var sawReadOnlySpans = false;
  var sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  } // TEXTMARKER SPANS


  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  } // Search an array of spans for a span matching the given marker.


  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];

        if (span.marker == marker) {
          return span;
        }
      }
    }
  } // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).


  function removeMarkedSpan(spans, span) {
    var r;

    for (var i = 0; i < spans.length; ++i) {
      if (spans[i] != span) {
        (r || (r = [])).push(spans[i]);
      }
    }

    return r;
  } // Add a span to a line.


  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  } // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).


  function markedSpansBefore(old, startCh, isInsert) {
    var nw;

    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);

        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }

    return nw;
  }

  function markedSpansAfter(old, endCh, isInsert) {
    var nw;

    if (old) {
      for (var i = 0; i < old.length; ++i) {
        var span = old[i],
            marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);

        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
        }
      }
    }

    return nw;
  } // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.


  function stretchSpansOverChange(doc, change) {
    if (change.full) {
      return null;
    }

    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;

    if (!oldFirst && !oldLast) {
      return null;
    }

    var startCh = change.from.ch,
        endCh = change.to.ch,
        isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides

    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends

    var sameLine = change.text.length == 1,
        offset = lst(change.text).length + (sameLine ? startCh : 0);

    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];

        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);

          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }

    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];

        if (span$1.to != null) {
          span$1.to += offset;
        }

        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);

          if (!found$1) {
            span$1.from = offset;

            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        } else {
          span$1.from += offset;

          if (sameLine) {
            (first || (first = [])).push(span$1);
          }
        }
      }
    } // Make sure we didn't create any zero-length spans


    if (first) {
      first = clearEmptySpans(first);
    }

    if (last && last != first) {
      last = clearEmptySpans(last);
    }

    var newMarkers = [first];

    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2,
          gapMarkers;

      if (gap > 0 && first) {
        for (var i$2 = 0; i$2 < first.length; ++i$2) {
          if (first[i$2].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
          }
        }
      }

      for (var i$3 = 0; i$3 < gap; ++i$3) {
        newMarkers.push(gapMarkers);
      }

      newMarkers.push(last);
    }

    return newMarkers;
  } // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.


  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];

      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i--, 1);
      }
    }

    if (!spans.length) {
      return null;
    }

    return spans;
  } // Used to 'clip' out readOnly ranges when making a change.


  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;

          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });

    if (!markers) {
      return null;
    }

    var parts = [{
      from: from,
      to: to
    }];

    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i],
          m = mk.find(0);

      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];

        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }

        var newParts = [j, 1],
            dfrom = cmp(p.from, m.from),
            dto = cmp(p.to, m.to);

        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({
            from: p.from,
            to: m.from
          });
        }

        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({
            from: m.to,
            to: p.to
          });
        }

        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }

    return parts;
  } // Connect or disconnect spans from a line.


  function detachMarkedSpans(line) {
    var spans = line.markedSpans;

    if (!spans) {
      return;
    }

    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.detachLine(line);
    }

    line.markedSpans = null;
  }

  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }

    for (var i = 0; i < spans.length; ++i) {
      spans[i].marker.attachLine(line);
    }

    line.markedSpans = spans;
  } // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.


  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }

  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  } // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.


  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;

    if (lenDiff != 0) {
      return lenDiff;
    }

    var aPos = a.find(),
        bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);

    if (fromCmp) {
      return -fromCmp;
    }

    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);

    if (toCmp) {
      return toCmp;
    }

    return b.id - a.id;
  } // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.


  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;

    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];

        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }

    return found;
  }

  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }

  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans,
        found;

    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];

        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }

    return found;
  } // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.


  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
    var line = getLine(doc, lineNo$$1);
    var sps = sawCollapsedSpans && line.markedSpans;

    if (sps) {
      for (var i = 0; i < sps.length; ++i) {
        var sp = sps[i];

        if (!sp.marker.collapsed) {
          continue;
        }

        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);

        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }

        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  } // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).


  function visualLine(line) {
    var merged;

    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }

    return line;
  }

  function visualLineEnd(line) {
    var merged;

    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }

    return line;
  } // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.


  function visualLineContinued(line) {
    var merged, lines;

    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }

    return lines;
  } // Get the line number of the start of the visual line that the
  // given line number is part of.


  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN),
        vis = visualLine(line);

    if (line == vis) {
      return lineN;
    }

    return lineNo(vis);
  } // Get the line number of the start of the next visual line after
  // the given line.


  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) {
      return lineN;
    }

    var line = getLine(doc, lineN),
        merged;

    if (!lineIsHidden(doc, line)) {
      return lineN;
    }

    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }

    return lineNo(line) + 1;
  } // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.


  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;

    if (sps) {
      for (var sp = void 0, i = 0; i < sps.length; ++i) {
        sp = sps[i];

        if (!sp.marker.collapsed) {
          continue;
        }

        if (sp.from == null) {
          return true;
        }

        if (sp.marker.widgetNode) {
          continue;
        }

        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
  }

  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }

    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }

    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];

      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
        return true;
      }
    }
  } // Find the height above the given line.


  function _heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0,
        chunk = lineObj.parent;

    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];

      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }

    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];

        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }

    return h;
  } // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.


  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }

    var len = line.text.length,
        merged,
        cur = line;

    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }

    cur = line;

    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }

    return len;
  } // Find the longest line in the document.


  function findMaxLine(cm) {
    var d = cm.display,
        doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);

      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  } // BIDI HELPERS


  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }

    var found = false;

    for (var i = 0; i < order.length; ++i) {
      var part = order[i];

      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }

    if (!found) {
      f(from, to, "ltr");
    }
  }

  var bidiOther = null;

  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;

    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];

      if (cur.from < ch && cur.to > ch) {
        return i;
      }

      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }

      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i;
        } else {
          bidiOther = i;
        }
      }
    }

    return found != null ? found : bidiOther;
  } // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.
  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals
  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.


  var bidiOrdering = function () {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6f9

    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

    function charType(code) {
      if (code <= 0xf7) {
        return lowTypes.charAt(code);
      } else if (0x590 <= code && code <= 0x5f4) {
        return "R";
      } else if (0x600 <= code && code <= 0x6f9) {
        return arabicTypes.charAt(code - 0x600);
      } else if (0x6ee <= code && code <= 0x8ac) {
        return "r";
      } else if (0x2000 <= code && code <= 0x200b) {
        return "w";
      } else if (code == 0x200c) {
        return "b";
      } else {
        return "L";
      }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/,
        isStrong = /[LRr]/,
        countsAsLeft = /[Lb1n]/,
        countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;
      this.to = to;
    }

    return function (str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }

      var len = str.length,
          types = [];

      for (var i = 0; i < len; ++i) {
        types.push(charType(str.charCodeAt(i)));
      } // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.


      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];

        if (type == "m") {
          types[i$1] = prev;
        } else {
          prev = type;
        }
      } // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.


      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];

        if (type$1 == "1" && cur == "r") {
          types[i$2] = "n";
        } else if (isStrong.test(type$1)) {
          cur = type$1;

          if (type$1 == "r") {
            types[i$2] = "R";
          }
        }
      } // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.


      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];

        if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
          types[i$3] = "1";
        } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
          types[i$3] = prev$1;
        }

        prev$1 = type$2;
      } // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.


      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];

        if (type$3 == ",") {
          types[i$4] = "N";
        } else if (type$3 == "%") {
          var end = void 0;

          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}

          var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";

          for (var j = i$4; j < end; ++j) {
            types[j] = replace;
          }

          i$4 = end - 1;
        }
      } // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.


      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];

        if (cur$1 == "L" && type$4 == "1") {
          types[i$5] = "L";
        } else if (isStrong.test(type$4)) {
          cur$1 = type$4;
        }
      } // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.


      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = void 0;

          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}

          var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? before ? "L" : "R" : outerType;

          for (var j$1 = i$6; j$1 < end$1; ++j$1) {
            types[j$1] = replace$1;
          }

          i$6 = end$1 - 1;
        }
      } // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.


      var order = [],
          m;

      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;

          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}

          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7,
              at = order.length;

          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}

          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j$2));
              }

              var nstart = j$2;

              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}

              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              pos = j$2;
            } else {
              ++j$2;
            }
          }

          if (pos < i$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i$7));
          }
        }
      }

      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }

        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order;
    };
  }(); // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.


  function getOrder(line, direction) {
    var order = line.order;

    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }

    return order;
  } // EVENT HANDLING
  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.


  var noHandlers = [];

  var on = function on(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers || (emitter._handlers = {});
      map$$1[type] = (map$$1[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers;
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map$$1 = emitter._handlers,
          arr = map$$1 && map$$1[type];

      if (arr) {
        var index = indexOf(arr, f);

        if (index > -1) {
          map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }

  function signal(emitter, type
  /*, values...*/
  ) {
    var handlers = getHandlers(emitter, type);

    if (!handlers.length) {
      return;
    }

    var args = Array.prototype.slice.call(arguments, 2);

    for (var i = 0; i < handlers.length; ++i) {
      handlers[i].apply(null, args);
    }
  } // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.


  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = {
        type: e,
        preventDefault: function preventDefault() {
          this.defaultPrevented = true;
        }
      };
    }

    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;

    if (!arr) {
      return;
    }

    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);

    for (var i = 0; i < arr.length; ++i) {
      if (indexOf(set, arr[i]) == -1) {
        set.push(arr[i]);
      }
    }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0;
  } // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.


  function eventMixin(ctor) {
    ctor.prototype.on = function (type, f) {
      on(this, type, f);
    };

    ctor.prototype.off = function (type, f) {
      off(this, type, f);
    };
  } // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.


  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }

  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }

  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }

  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }

  function e_target(e) {
    return e.target || e.srcElement;
  }

  function e_button(e) {
    var b = e.which;

    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }

    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }

    return b;
  } // Detect drag-and-drop


  var dragAndDrop = function () {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) {
      return false;
    }

    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var zwspSupported;

  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200B");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));

      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }

    var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  } // Feature-detect IE's crummy client rect reporting for bidi text


  var badBidiRects;

  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }

    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);

    if (!r0 || r0.left == r0.right) {
      return false;
    } // Safari returns null in some cases (#2780)


    return badBidiRects = r1.right - r0.right < 3;
  } // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.


  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0,
        result = [],
        l = string.length;

    while (pos <= l) {
      var nl = string.indexOf("\n", pos);

      if (nl == -1) {
        nl = string.length;
      }

      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");

      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }

    return result;
  } : function (string) {
    return string.split(/\r\n?|\n/);
  };
  var hasSelection = window.getSelection ? function (te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function (te) {
    var range$$1;

    try {
      range$$1 = te.ownerDocument.selection.createRange();
    } catch (e) {}

    if (!range$$1 || range$$1.parentElement() != te) {
      return false;
    }

    return range$$1.compareEndPoints("StartToEnd", range$$1) != 0;
  };

  var hasCopyEvent = function () {
    var e = elt("div");

    if ("oncopy" in e) {
      return true;
    }

    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();

  var badZoomedRects = null;

  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }

    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  } // Known modes, by name and by MIME


  var modes = {};
  var mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)

  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }

    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  } // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.


  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];

      if (typeof found == "string") {
        found = {
          name: found
        };
      }

      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json");
    }

    if (typeof spec == "string") {
      return {
        name: spec
      };
    } else {
      return spec || {
        name: "null"
      };
    }
  } // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.


  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];

    if (!mfactory) {
      return getMode(options, "text/plain");
    }

    var modeObj = mfactory(options, spec);

    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];

      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) {
          continue;
        }

        if (modeObj.hasOwnProperty(prop)) {
          modeObj["_" + prop] = modeObj[prop];
        }

        modeObj[prop] = exts[prop];
      }
    }

    modeObj.name = spec.name;

    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }

    if (spec.modeProps) {
      for (var prop$1 in spec.modeProps) {
        modeObj[prop$1] = spec.modeProps[prop$1];
      }
    }

    return modeObj;
  } // This can be used to attach properties to mode objects from
  // outside the actual mode definition.


  var modeExtensions = {};

  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) {
      return state;
    }

    if (mode.copyState) {
      return mode.copyState(state);
    }

    var nstate = {};

    for (var n in state) {
      var val = state[n];

      if (val instanceof Array) {
        val = val.concat([]);
      }

      nstate[n] = val;
    }

    return nstate;
  } // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.


  function innerMode(mode, state) {
    var info;

    while (mode.innerMode) {
      info = mode.innerMode(state);

      if (!info || info.mode == mode) {
        break;
      }

      state = info.state;
      mode = info.mode;
    }

    return info || {
      mode: mode,
      state: state
    };
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  } // STRING STREAM
  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.


  var StringStream = function StringStream(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {
    return this.pos >= this.string.length;
  };

  StringStream.prototype.sol = function () {
    return this.pos == this.lineStart;
  };

  StringStream.prototype.peek = function () {
    return this.string.charAt(this.pos) || undefined;
  };

  StringStream.prototype.next = function () {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };

  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;

    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }

    if (ok) {
      ++this.pos;
      return ch;
    }
  };

  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;

    while (this.eat(match)) {}

    return this.pos > start;
  };

  StringStream.prototype.eatSpace = function () {
    var this$1 = this;
    var start = this.pos;

    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this$1.pos;
    }

    return this.pos > start;
  };

  StringStream.prototype.skipToEnd = function () {
    this.pos = this.string.length;
  };

  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);

    if (found > -1) {
      this.pos = found;
      return true;
    }
  };

  StringStream.prototype.backUp = function (n) {
    this.pos -= n;
  };

  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }

    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };

  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };

  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function cased(str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };

      var substr = this.string.substr(this.pos, pattern.length);

      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }

        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);

      if (match && match.index > 0) {
        return null;
      }

      if (match && consume !== false) {
        this.pos += match[0].length;
      }

      return match;
    }
  };

  StringStream.prototype.current = function () {
    return this.string.slice(this.start, this.pos);
  };

  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;

    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };

  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };

  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  };

  var SavedContext = function SavedContext(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function Context(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);

    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }

    return line;
  };

  Context.prototype.baseToken = function (n) {
    var this$1 = this;

    if (!this.baseTokens) {
      return null;
    }

    while (this.baseTokens[this.baseTokenPos] <= n) {
      this$1.baseTokenPos += 2;
    }

    var type = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type && type.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  };

  Context.prototype.nextLine = function () {
    this.line++;

    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc, copyState(doc.mode, saved), line);
    }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  }; // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.


  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen],
        lineClasses = {}; // Compute the base array of styles

    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
      return st.push(end, style);
    }, lineClasses, forceToEnd);
    var state = context.state; // Run overlays, adjust style array.

    var loop = function loop(o) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o],
          i = 1,
          at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i; // Ensure there's a token end at the current position, and that i points at it

        while (at < end) {
          var i_end = st[i];

          if (i_end > end) {
            st.splice(i, 1, end, st[i + 1], i_end);
          }

          i += 2;
          at = Math.min(end, i_end);
        }

        if (!style) {
          return;
        }

        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) {
      loop(o);
    }

    return {
      styles: st,
      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
    };
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);

      if (resetState) {
        context.state = resetState;
      }

      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;

      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }

      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }

    return line.styles;
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc,
        display = cm.display;

    if (!doc.mode.startState) {
      return new Context(doc, true, n);
    }

    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });

    if (precise) {
      doc.modeFrontier = context.line;
    }

    return context;
  } // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.


  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;

    if (text == "") {
      callBlankLine(mode, context.state);
    }

    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }

    if (!mode.innerMode) {
      return;
    }

    var inner = innerMode(mode, state);

    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }

      var style = mode.token(stream, state);

      if (stream.pos > stream.start) {
        return style;
      }
    }

    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  var Token = function Token(stream, type, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  }; // Utility for getTokenAt and getLineTokens


  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc,
        mode = doc.mode,
        style;
    pos = _clipPos(doc, pos);
    var line = getLine(doc, pos.line),
        context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context),
        tokens;

    if (asArray) {
      tokens = [];
    }

    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);

      if (asArray) {
        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
      }
    }

    return asArray ? tokens : new Token(stream, style, context.state);
  }

  function extractLineClasses(type, output) {
    if (type) {
      for (;;) {
        var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);

        if (!lineClass) {
          break;
        }

        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
        var prop = lineClass[1] ? "bgClass" : "textClass";

        if (output[prop] == null) {
          output[prop] = lineClass[2];
        } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
          output[prop] += " " + lineClass[2];
        }
      }
    }

    return type;
  } // Run the given mode's parser over a line, calling f for each token.


  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;

    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }

    var curStart = 0,
        curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context),
        style;
    var inner = cm.options.addModeClass && [null];

    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }

    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;

        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }

        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }

      if (inner) {
        var mName = inner[0].name;

        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }

      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }

        curStyle = style;
      }

      stream.start = stream.pos;
    }

    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  } // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.


  function findStartLine(cm, n, precise) {
    var minindent,
        minline,
        doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);

    for (var search = n; search > lim; --search) {
      if (search <= doc.first) {
        return doc.first;
      }

      var line = getLine(doc, search - 1),
          after = line.stateAfter;

      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
        return search;
      }

      var indented = countColumn(line.text, null, cm.options.tabSize);

      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }

    return minline;
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);

    if (doc.highlightFrontier < n - 10) {
      return;
    }

    var start = doc.first;

    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter; // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this

      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }

    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  } // LINE DATA STRUCTURE
  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).


  var Line = function Line(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () {
    return lineNo(this);
  };

  eventMixin(Line); // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.

  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;

    if (line.stateAfter) {
      line.stateAfter = null;
    }

    if (line.styles) {
      line.styles = null;
    }

    if (line.order != null) {
      line.order = null;
    }

    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;

    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  } // Detach a line from the document tree and its markers.


  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  } // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.


  var styleToClassCache = {};
  var styleToClassCacheWithMode = {};

  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) {
      return null;
    }

    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
  } // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.


  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"),
      content: content,
      col: 0,
      pos: 0,
      cm: cm,
      trailingSpace: false,
      splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
    };
    lineView.measure = {}; // Iterate over the logical lines that make up this visual line.

    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line,
          order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.

      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }

      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));

      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }

        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      } // Ensure at least a single node is present, for measuring.


      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      } // Store the map and a cache object for the current logical line


      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    } // See issue #2901


    if (webkit) {
      var last = builder.content.lastChild;

      if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);

    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  } // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.


  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) {
      return;
    }

    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars,
        mustWrap = false;
    var content;

    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);

      if (ie && ie_version < 9) {
        mustWrap = true;
      }

      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;

      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;

        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));

          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }

          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }

        if (!m) {
          break;
        }

        pos += skipped + 1;
        var txt$1 = void 0;

        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize,
              tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);

          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt$1]));
          } else {
            content.appendChild(txt$1);
          }

          builder.col += 1;
        }

        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }

    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;

    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";

      if (startStyle) {
        fullStyle += startStyle;
      }

      if (endStyle) {
        fullStyle += endStyle;
      }

      var token = elt("span", [content], fullStyle, css);

      if (title) {
        token.title = title;
      }

      return builder.content.appendChild(token);
    }

    builder.content.appendChild(content);
  }

  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }

    var spaceBefore = trailingBefore,
        result = "";

    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);

      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
        ch = "\xA0";
      }

      result += ch;
      spaceBefore = ch == " ";
    }

    return result;
  } // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.


  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos,
          end = start + text.length;

      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = void 0;

        for (var i = 0; i < order.length; i++) {
          part = order[i];

          if (part.to > start && part.from <= start) {
            break;
          }
        }

        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, title, css);
        }

        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;

    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }

    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }

      widget.setAttribute("cm-marker", marker.id);
    }

    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }

    builder.pos += size;
    builder.trailingSpace = false;
  } // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.


  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans,
        allText = line.text,
        at = 0;

    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
      }

      return;
    }

    var len = allText.length,
        pos = 0,
        i = 1,
        text = "",
        style,
        css;
    var nextChange = 0,
        spanStyle,
        spanEndStyle,
        spanStartStyle,
        title,
        collapsed;

    for (;;) {
      if (nextChange == pos) {
        // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [],
            endStyles = void 0;

        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j],
              m = sp.marker;

          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }

            if (m.className) {
              spanStyle += " " + m.className;
            }

            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }

            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }

            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }

            if (m.title && !title) {
              title = m.title;
            }

            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }

        if (endStyles) {
          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
            if (endStyles[j$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j$1];
            }
          }
        }

        if (!collapsed || collapsed.from == pos) {
          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
          }
        }

        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);

          if (collapsed.to == null) {
            return;
          }

          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }

      if (pos >= len) {
        break;
      }

      var upto = Math.min(len, nextChange);

      while (true) {
        if (text) {
          var end = pos + text.length;

          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }

          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }

          pos = end;
          spanStartStyle = "";
        }

        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  } // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.


  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line; // Continuing lines, if any

    this.rest = visualLineContinued(line); // Number of logical lines in this visual line

    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  } // Create a range of LineView objects for the given lines.


  function buildViewArray(cm, from, to) {
    var array = [],
        nextPos;

    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }

    return array;
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks,
        i = 0;

    do {
      for (; i < callbacks.length; i++) {
        callbacks[i].call(null);
      }

      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];

        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i < callbacks.length);
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;

    if (!group) {
      return;
    }

    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.

  function signalLater(emitter, type
  /*, values...*/
  ) {
    var arr = getHandlers(emitter, type);

    if (!arr.length) {
      return;
    }

    var args = Array.prototype.slice.call(arguments, 2),
        list;

    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }

    var loop = function loop(i) {
      list.push(function () {
        return arr[i].apply(null, args);
      });
    };

    for (var i = 0; i < arr.length; ++i) {
      loop(i);
    }
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;

    for (var i = 0; i < delayed.length; ++i) {
      delayed[i]();
    }
  } // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.


  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];

      if (type == "text") {
        updateLineText(cm, lineView);
      } else if (type == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type == "class") {
        updateLineClasses(cm, lineView);
      } else if (type == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }

    lineView.changes = null;
  } // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div


  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");

      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }

      lineView.node.appendChild(lineView.text);

      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }

    return lineView.node;
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;

    if (cls) {
      cls += " CodeMirror-linebackground";
    }

    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  } // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.


  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;

    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }

    return buildLineContent(cm, lineView);
  } // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.


  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);

    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }

    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;

    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);

    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }

    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }

    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }

    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }

    var markers = lineView.line.gutterMarkers;

    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);

      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }

      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
      }

      if (markers) {
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k],
              found = markers.hasOwnProperty(id) && markers[id];

          if (found) {
            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
      }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }

    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;

      if (node.className == "CodeMirror-linewidget") {
        lineView.node.removeChild(node);
      }
    }

    insertLineWidgets(cm, lineView, dims);
  } // Build a line's DOM representation from scratch


  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;

    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }

    if (built.textClass) {
      lineView.textClass = built.textClass;
    }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  } // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.


  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);

    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++) {
        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
      }
    }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }

    var wrap = ensureLineWrapped(lineView);

    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i],
          node = elt("div", [widget.node], "CodeMirror-linewidget");

      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }

      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);

      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }

      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";

      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }

      node.style.width = width + "px";
    }

    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";

      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }

    var cm = widget.doc.cm;

    if (!cm) {
      return 0;
    }

    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";

      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }

      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }

      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }

    return widget.height = widget.node.parentNode.offsetHeight;
  } // Return true when the given mouse event happened in a widget


  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  } // POSITION MEASUREMENT


  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }

  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }

  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }

    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {
      left: parseInt(style.paddingLeft),
      right: parseInt(style.paddingRight)
    };

    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }

    return data;
  }

  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }

  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }

  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  } // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.


  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);

    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];

      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();

        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i],
              next = rects[i + 1];

          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }

      heights.push(rect.bottom - rect.top);
    }
  } // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)


  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return {
        map: lineView.measure.map,
        cache: lineView.measure.cache
      };
    }

    for (var i = 0; i < lineView.rest.length; i++) {
      if (lineView.rest[i] == line) {
        return {
          map: lineView.measure.maps[i],
          cache: lineView.measure.caches[i]
        };
      }
    }

    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
      if (lineNo(lineView.rest[i$1]) > lineN) {
        return {
          map: lineView.measure.maps[i$1],
          cache: lineView.measure.caches[i$1],
          before: true
        };
      }
    }
  } // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.


  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  } // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.


  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  } // Find a line view that corresponds to the given line number.


  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }

    var ext = cm.display.externalMeasured;

    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  } // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.


  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);

    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }

    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line,
      view: view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  } // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).


  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }

    var key = ch + (bias || ""),
        found;

    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }

      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }

      found = measureCharInner(cm, prepared, ch, bias);

      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }

    return {
      left: found.left,
      right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    };
  }

  var nullRect = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };

  function nodeAndOffsetInLineMap(map$$1, ch, bias) {
    var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,
    // or closest to, the target character.

    for (var i = 0; i < map$$1.length; i += 3) {
      mStart = map$$1[i];
      mEnd = map$$1[i + 1];

      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;

        if (ch >= mEnd) {
          collapse = "right";
        }
      }

      if (start != null) {
        node = map$$1[i + 2];

        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }

        if (bias == "left" && start == 0) {
          while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
            node = map$$1[(i -= 3) + 2];
            collapse = "left";
          }
        }

        if (bias == "right" && start == mEnd - mStart) {
          while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
            node = map$$1[(i += 3) + 2];
            collapse = "right";
          }
        }

        break;
      }
    }

    return {
      node: node,
      start: start,
      end: end,
      collapse: collapse,
      coverStart: mStart,
      coverEnd: mEnd
    };
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;

    if (bias == "left") {
      for (var i = 0; i < rects.length; i++) {
        if ((rect = rects[i]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
        if ((rect = rects[i$1]).left != rect.right) {
          break;
        }
      }
    }

    return rect;
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node,
        start = place.start,
        end = place.end,
        collapse = place.collapse;
    var rect;

    if (node.nodeType == 3) {
      // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) {
        // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }

        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }

        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }

        if (rect.left || rect.right || start == 0) {
          break;
        }

        end = start;
        start = start - 1;
        collapse = "right";
      }

      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      // If it is a widget, simply get the box for the whole widget.
      if (start > 0) {
        collapse = bias = "right";
      }

      var rects;

      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }

    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];

      if (rSpan) {
        rect = {
          left: rSpan.left,
          right: rSpan.left + charWidth(cm.display),
          top: rSpan.top,
          bottom: rSpan.bottom
        };
      } else {
        rect = nullRect;
      }
    }

    var rtop = rect.top - prepared.rect.top,
        rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;

    for (; i < heights.length - 1; i++) {
      if (mid < heights[i]) {
        break;
      }
    }

    var top = i ? heights[i - 1] : 0,
        bot = heights[i];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top: top,
      bottom: bot
    };

    if (!rect.left && !rect.right) {
      result.bogus = true;
    }

    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;
      result.rbottom = rbot;
    }

    return result;
  } // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.


  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }

    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX,
      right: rect.right * scaleX,
      top: rect.top * scaleY,
      bottom: rect.bottom * scaleY
    };
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;

      if (lineView.rest) {
        for (var i = 0; i < lineView.rest.length; i++) {
          lineView.measure.caches[i] = {};
        }
      }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);

    for (var i = 0; i < cm.display.view.length; i++) {
      clearLineMeasurementCacheFor(cm.display.view[i]);
    }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;

    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }

    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
    }

    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
  }

  function pageScrollY() {
    if (chrome && android) {
      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
    }

    return window.pageYOffset || (document.documentElement || document.body).scrollTop;
  }

  function widgetTopHeight(lineObj) {
    var height = 0;

    if (lineObj.widgets) {
      for (var i = 0; i < lineObj.widgets.length; ++i) {
        if (lineObj.widgets[i].above) {
          height += widgetHeight(lineObj.widgets[i]);
        }
      }
    }

    return height;
  } // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".


  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;
      rect.bottom += height;
    }

    if (context == "line") {
      return rect;
    }

    if (!context) {
      context = "local";
    }

    var yOff = _heightAtLine(lineObj);

    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }

    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff;
      rect.right += xOff;
    }

    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  } // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.


  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }

    var left = coords.left,
        top = coords.top; // First move into "page" coordinate system

    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {
      left: left - lineSpaceBox.left,
      top: top - lineSpaceBox.top
    };
  }

  function _charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }

    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  } // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.


  function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);

    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }

    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);

      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }

      return intoCoordSystem(cm, lineObj, m, context);
    }

    var order = getOrder(lineObj, cm.doc.direction),
        ch = pos.ch,
        sticky = pos.sticky;

    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }

    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos],
          right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert);
    }

    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");

    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }

    return val;
  } // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.


  function estimateCoords(cm, pos) {
    var left = 0;
    pos = _clipPos(cm.doc, pos);

    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }

    var lineObj = getLine(cm.doc, pos.line);
    var top = _heightAtLine(lineObj) + paddingTop(cm.display);
    return {
      left: left,
      right: left,
      top: top,
      bottom: top + lineObj.height
    };
  } // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.


  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;

    if (outside) {
      pos.outside = true;
    }

    return pos;
  } // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).


  function _coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;

    if (y < 0) {
      return PosWithInfo(doc.first, 0, null, true, -1);
    }

    var lineN = _lineAtHeight(doc, y),
        last = doc.first + doc.size - 1;

    if (lineN > last) {
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1);
    }

    if (x < 0) {
      x = 0;
    }

    var lineObj = getLine(doc, lineN);

    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));

      if (!collapsed) {
        return found;
      }

      var rangeEnd = collapsed.find(1);

      if (rangeEnd.line == lineN) {
        return rangeEnd;
      }

      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function (ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return {
      begin: begin,
      end: end
    };
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }

    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  } // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.


  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }

  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
    // Move y into line-local coordinate space
    y -= _heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.

    var widgetHeight$$1 = widgetTopHeight(lineObj);
    var begin = 0,
        end = lineObj.text.length,
        ltr = true;
    var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.

    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
      ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range

      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    } // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.


    var chAround = null,
        boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight$$1;
      box.bottom += widgetHeight$$1;

      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }

      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }

      return true;
    }, begin, end);
    var baseX,
        sticky,
        outside = false; // If a box around the coordinates was found, use that

    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x,
          atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      } // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates


      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before"; // Now get accurate coordinates for this place, in order to get a
      // base X position

      var coords = _cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);

      baseX = coords.left;
      outside = y < coords.top || y >= coords.bottom;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX);
  }

  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i],
          ltr = part.level != 1;
      return boxIsAfter(_cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
    }, 0, order.length - 1);
    var part = order[index]; // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.

    if (index > 0) {
      var ltr = part.level != 1;

      var start = _cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);

      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }

    return part;
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;

    if (/\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }

    var part = null,
        closestDist = null;

    for (var i = 0; i < order.length; i++) {
      var p = order[i];

      if (p.from >= end || p.to <= begin) {
        continue;
      }

      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after

      var dist = endX < x ? x - endX + 1e9 : endX - x;

      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }

    if (!part) {
      part = order[order.length - 1];
    } // Clip the part to the wrapped line.


    if (part.from < begin) {
      part = {
        from: begin,
        to: part.to,
        level: part.level
      };
    }

    if (part.to > end) {
      part = {
        from: part.from,
        to: end,
        level: part.level
      };
    }

    return part;
  }

  var measureText; // Compute the default text height.

  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }

    if (measureText == null) {
      measureText = elt("pre"); // Measure a bunch of lines, for browsers that compute
      // fractional heights.

      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }

      measureText.appendChild(document.createTextNode("x"));
    }

    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;

    if (height > 3) {
      display.cachedTextHeight = height;
    }

    removeChildren(display.measure);
    return height || 1;
  } // Compute the default character width.


  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }

    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(),
        width = (rect.right - rect.left) / 10;

    if (width > 2) {
      display.cachedCharWidth = width;
    }

    return width || 10;
  } // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.


  function getDimensions(cm) {
    var d = cm.display,
        left = {},
        width = {};
    var gutterLeft = d.gutters.clientLeft;

    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[cm.options.gutters[i]] = n.clientWidth;
    }

    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.


  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  } // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).


  function estimateHeight(cm) {
    var th = textHeight(cm.display),
        wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }

      var widgetsHeight = 0;

      if (line.widgets) {
        for (var i = 0; i < line.widgets.length; i++) {
          if (line.widgets[i].height) {
            widgetsHeight += line.widgets[i].height;
          }
        }
      }

      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc,
        est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);

      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  } // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.


  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;

    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }

    var x,
        y,
        space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.

    try {
      x = e.clientX - space.left;
      y = e.clientY - space.top;
    } catch (e) {
      return null;
    }

    var coords = _coordsChar(cm, x, y),
        line;

    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }

    return coords;
  } // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.


  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }

    n -= cm.display.viewFrom;

    if (n < 0) {
      return null;
    }

    var view = cm.display.view;

    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;

      if (n < 0) {
        return i;
      }
    }
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;
    var doc = cm.doc,
        result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) {
        continue;
      }

      var range$$1 = doc.sel.ranges[i];

      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) {
        continue;
      }

      var collapsed = range$$1.empty();

      if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range$$1.head, curFragment);
      }

      if (!collapsed) {
        drawSelectionRange(cm, range$$1, selFragment);
      }
    }

    return result;
  } // Draws a cursor for the given range


  function drawSelectionCursor(cm, head, output) {
    var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  } // Draws the given range as a highlighted selection


  function drawSelectionRange(cm, range$$1, output) {
    var display = cm.display,
        doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display),
        leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }

      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;

      function coords(ch, bias) {
        return _charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop];
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");
        var openStart = fromArg == null && from == 0,
            openEnd = toArg == null && to == lineLen;
        var first = i == 0,
            last = !order || i == order.length - 1;

        if (toPos.top - fromPos.top <= 3) {
          // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          // Multiple lines
          var topLeft, topRight, botLeft, botRight;

          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }

          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);

          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }

          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }

        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }

        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }

        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return {
        start: start,
        end: end
      };
    }

    var sFrom = range$$1.from(),
        sTo = range$$1.to();

    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line),
          toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;

      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }

      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }

    output.appendChild(fragment);
  } // Cursor-blinking


  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }

    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";

    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function () {
        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) {
      cm.display.input.focus();
      onFocus(cm);
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
    }

    if (cm.options.readOnly == "nocursor") {
      return;
    }

    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused"); // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)

      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();

        if (webkit) {
          setTimeout(function () {
            return cm.display.input.reset(true);
          }, 20);
        } // Issue #1730

      }

      cm.display.input.receivedFocus();
    }

    restartBlink(cm);
  }

  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }

    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  } // Read the actual heights of the rendered lines, and update their
  // stored heights to match.


  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;

    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i],
          height = void 0;

      if (cur.hidden) {
        continue;
      }

      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }

      var diff = cur.line.height - height;

      if (height < 2) {
        height = textHeight(display);
      }

      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);

        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
    }
  } // Read and store the height of line widgets associated with the
  // given line.


  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i = 0; i < line.widgets.length; ++i) {
        var w = line.widgets[i],
            parent = w.node.parentNode;

        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  } // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.


  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = _lineAtHeight(doc, top),
        to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).


    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line,
          ensureTo = viewport.ensure.to.line;

      if (ensureFrom < from) {
        from = ensureFrom;
        to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }

    return {
      from: from,
      to: Math.max(to, from + 1)
    };
  } // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.


  function alignHorizontally(cm) {
    var display = cm.display,
        view = display.view;

    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }

    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth,
        left = comp + "px";

    for (var i = 0; i < view.length; i++) {
      if (!view[i].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i].gutter) {
            view[i].gutter.style.left = left;
          }

          if (view[i].gutterBackground) {
            view[i].gutterBackground.style.left = left;
          }
        }

        var align = view[i].alignable;

        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }

    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  } // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.


  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }

    var doc = cm.doc,
        last = lineNumberFor(cm.options, doc.first + doc.size - 1),
        display = cm.display;

    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth,
          padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }

    return false;
  } // SCROLLING THINGS INTO VIEW
  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.


  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }

    var display = cm.display,
        box = display.sizer.getBoundingClientRect(),
        doScroll = null;

    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
      doScroll = false;
    }

    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  } // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).


  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }

    var rect;

    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }

    for (var limit = 0; limit < 5; limit++) {
      var changed = false;

      var coords = _cursorCoords(cm, pos);

      var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop,
          startLeft = cm.doc.scrollLeft;

      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);

        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }

      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);

        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }

      if (!changed) {
        break;
      }
    }

    return rect;
  } // Scroll a given set of coordinates into view (immediately).


  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);

    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }

    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  } // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.


  function calculateScrollPos(cm, rect) {
    var display = cm.display,
        snapMargin = textHeight(cm.display);

    if (rect.top < 0) {
      rect.top = 0;
    }

    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm),
        result = {};

    if (rect.bottom - rect.top > screen) {
      rect.bottom = rect.top + screen;
    }

    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin,
        atBottom = rect.bottom > docBottom - snapMargin;

    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);

      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = rect.right - rect.left > screenw;

    if (tooWide) {
      rect.right = rect.left + screenw;
    }

    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }

    return result;
  } // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).


  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }

    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  } // Make sure that at the end of the operation the current cursor is
  // shown.


  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {
      from: cur,
      to: cur,
      margin: cm.options.cursorScrollMargin
    };
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }

    if (x != null) {
      cm.curOp.scrollLeft = x;
    }

    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }

  function scrollToRange(cm, range$$1) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range$$1;
  } // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.


  function resolveScrollToPos(cm) {
    var range$$1 = cm.curOp.scrollToPos;

    if (range$$1) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range$$1.from),
          to = estimateCoords(cm, range$$1.to);
      scrollToCoordsRange(cm, from, to, range$$1.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  } // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.


  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }

    if (!gecko) {
      updateDisplaySimple(cm, {
        top: val
      });
    }

    setScrollTop(cm, val, true);

    if (gecko) {
      updateDisplaySimple(cm);
    }

    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);

    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }

    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);

    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  } // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.


  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);

    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }

    cm.doc.scrollLeft = val;
    alignHorizontally(cm);

    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }

    cm.display.scrollbars.setScrollLeft(val);
  } // SCROLLBARS
  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.


  function measureForScrollbars(cm) {
    var d = cm.display,
        gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth,
      clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }

  var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert);
    place(horiz);
    on(vert, "scroll", function () {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });
    this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).

    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.

      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }

      this.checkedZeroWidth = true;
    }

    return {
      right: needsV ? sWidth : 0,
      bottom: needsH ? sWidth : 0
    };
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }

    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }

    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";

    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);

      if (elt$$1 != bar) {
        bar.style.pointerEvents = "none";
      } else {
        delay.set(1000, maybeDisable);
      }
    }

    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function NullScrollbars() {};

  NullScrollbars.prototype.update = function () {
    return {
      bottom: 0,
      right: 0
    };
  };

  NullScrollbars.prototype.setScrollLeft = function () {};

  NullScrollbars.prototype.setScrollTop = function () {};

  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }

    var startWidth = cm.display.barWidth,
        startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);

    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }

      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;
      startHeight = cm.display.barHeight;
    }
  } // Re-synchronize the fake scrollbars with the actual size of the
  // content.


  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }

    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }

  var scrollbarModel = {
    "native": NativeScrollbars,
    "null": NullScrollbars
  };

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();

      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus

      on(node, "mousedown", function () {
        if (cm.state.focused) {
          setTimeout(function () {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);

    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  } // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.


  var nextOpId = 0; // Start a new operation.

  function _startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,
      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height,
      // Used to detect need to update scrollbar
      forceUpdate: false,
      // Used to force a redraw
      updateInput: null,
      // Whether to reset the input textarea
      typing: false,
      // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,
      // Accumulated changes, for firing change events
      cursorActivityHandlers: null,
      // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0,
      // Tracks which cursorActivity handlers have been called already
      selectionChanged: false,
      // Whether the selection needs to be redrawn
      updateMaxLine: false,
      // Set when the widest line needs to be determined anew
      scrollLeft: null,
      scrollTop: null,
      // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,
      // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId // Unique ID

    };
    pushOperation(cm.curOp);
  } // Finish an operation, updating the display and signalling delayed events


  function _endOperation(cm) {
    var op = cm.curOp;
    finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++) {
        group.ops[i].cm.curOp = null;
      }

      endOperations(group);
    });
  } // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.


  function endOperations(group) {
    var ops = group.ops;

    for (var i = 0; i < ops.length; i++) // Read DOM
    {
      endOperation_R1(ops[i]);
    }

    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    {
      endOperation_W1(ops[i$1]);
    }

    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    {
      endOperation_R2(ops[i$2]);
    }

    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    {
      endOperation_W2(ops[i$3]);
    }

    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    {
      endOperation_finish(ops[i$4]);
    }
  }

  function endOperation_R1(op) {
    var cm = op.cm,
        display = cm.display;
    maybeClipScrollbars(cm);

    if (op.updateMaxLine) {
      findMaxLine(cm);
    }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
      top: op.scrollTop,
      ensure: op.scrollToPos
    }, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm,
        display = cm.display;

    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }

    op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing

    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";

      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }

      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();

    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }

    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }

    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }

    if (op.selectionChanged) {
      restartBlink(cm);
    }

    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }

    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }

  function endOperation_finish(op) {
    var cm = op.cm,
        display = cm.display,
        doc = cm.doc;

    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    } // Abort mouse wheel delta measurement, when scrolling explicitly


    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    } // Propagate the scroll position to the actual DOM scroller


    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }

    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    } // If we need to scroll a specific position into view, do so.


    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    } // Fire events for markers that are hidden/unidden by editing or
    // undoing


    var hidden = op.maybeHiddenMarkers,
        unhidden = op.maybeUnhiddenMarkers;

    if (hidden) {
      for (var i = 0; i < hidden.length; ++i) {
        if (!hidden[i].lines.length) {
          signal(hidden[i], "hide");
        }
      }
    }

    if (unhidden) {
      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
        if (unhidden[i$1].lines.length) {
          signal(unhidden[i$1], "unhide");
        }
      }
    }

    if (display.wrapper.offsetHeight) {
      doc.scrollTop = cm.display.scroller.scrollTop;
    } // Fire change events, and delayed event handlers


    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }

    if (op.update) {
      op.update.finish();
    }
  } // Run the given function in an operation


  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }

    _startOperation(cm);

    try {
      return f();
    } finally {
      _endOperation(cm);
    }
  } // Wraps a function in an operation. Returns the wrapped function.


  function operation(cm, f) {
    return function () {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }

      _startOperation(cm);

      try {
        return f.apply(cm, arguments);
      } finally {
        _endOperation(cm);
      }
    };
  } // Used to add methods to editor and doc instances, wrapping them in
  // operations.


  function methodOp(f) {
    return function () {
      if (this.curOp) {
        return f.apply(this, arguments);
      }

      _startOperation(this);

      try {
        return f.apply(this, arguments);
      } finally {
        _endOperation(this);
      }
    };
  }

  function docMethodOp(f) {
    return function () {
      var cm = this.cm;

      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }

      _startOperation(cm);

      try {
        return f.apply(this, arguments);
      } finally {
        _endOperation(cm);
      }
    };
  } // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.


  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }

    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }

    if (!lendiff) {
      lendiff = 0;
    }

    var display = cm.display;

    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) {
      // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) {
      // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);

      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);

      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);

      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;

    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  } // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"


  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display,
        ext = cm.display.externalMeasured;

    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }

    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }

    var lineView = display.view[findViewIndex(cm, line)];

    if (lineView.node == null) {
      return;
    }

    var arr = lineView.changes || (lineView.changes = []);

    if (indexOf(arr, type) == -1) {
      arr.push(type);
    }
  } // Clear the view.


  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN),
        diff,
        view = cm.display.view;

    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return {
        index: index,
        lineN: newN
      };
    }

    var n = cm.display.viewFrom;

    for (var i = 0; i < index; i++) {
      n += view[i].size;
    }

    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }

        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }

      oldN += diff;
      newN += diff;
    }

    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }

      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }

    return {
      index: index,
      lineN: newN
    };
  } // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.


  function adjustView(cm, from, to) {
    var display = cm.display,
        view = display.view;

    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }

      display.viewFrom = from;

      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }

    display.viewTo = to;
  } // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).


  function countDirtyView(cm) {
    var view = cm.display.view,
        dirty = 0;

    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];

      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }

    return dirty;
  } // HIGHLIGHT WORKER


  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;

    if (doc.highlightFrontier >= cm.display.viewTo) {
      return;
    }

    var end = +new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];
    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) {
        // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);

        if (resetState) {
          context.state = resetState;
        }

        line.styles = highlighted.styles;
        var oldCls = line.styleClasses,
            newCls = highlighted.classes;

        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }

        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);

        for (var i = 0; !ischange && i < oldStyles.length; ++i) {
          ischange = oldStyles[i] != line.styles[i];
        }

        if (ischange) {
          changedLines.push(context.line);
        }

        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }

        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }

      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);

    if (changedLines.length) {
      runInOp(cm, function () {
        for (var i = 0; i < changedLines.length; i++) {
          regLineChange(cm, changedLines[i], "text");
        }
      });
    }
  } // DISPLAY DRAWING


  var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {
    var display = cm.display;
    this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)

    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type)) {
      this.events.push(arguments);
    }
  };

  DisplayUpdate.prototype.finish = function () {
    var this$1 = this;

    for (var i = 0; i < this.events.length; i++) {
      signal.apply(null, this$1.events[i]);
    }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;

    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }

    var active = activeElt();

    if (!active || !contains(cm.display.lineDiv, active)) {
      return null;
    }

    var result = {
      activeElt: active
    };

    if (window.getSelection) {
      var sel = window.getSelection();

      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }

    return result;
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
      return;
    }

    snapshot.activeElt.focus();

    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(),
          range$$1 = document.createRange();
      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range$$1.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range$$1);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  } // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.


  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display,
        doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    } // Bail out if the visible area is already rendered and nothing changed.


    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    } // Compute a suitable new viewport (from & to)


    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);

    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc.first, display.viewFrom);
    }

    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }

    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);
    display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position

    cm.display.mover.style.top = display.viewOffset + "px";
    var toUpdate = countDirtyView(cm);

    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    } // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.


    var selSnapshot = selectionSnapshot(cm);

    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }

    patchDisplay(cm, display.updateLineNumbers, update.dims);

    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }

    display.renderedView = display.view; // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.

    restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll
    // width and height.

    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;
    return true;
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null) {
          viewport = {
            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
          };
        } // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.


        update.visible = visibleLines(cm.display, cm.doc, viewport);

        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      }

      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }

      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);

    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;
      cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);

    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  } // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.


  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display,
        lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv,
        cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit

      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = "none";
      } else {
        node.parentNode.removeChild(node);
      }

      return next;
    }

    var view = display.view,
        lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.

    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];

      if (lineView.hidden) {} else if (!lineView.node || lineView.node.parentNode != container) {
        // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        // Already drawn
        while (cur != lineView.node) {
          cur = rm(cur);
        }

        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;

        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }

          updateLineForChanges(cm, lineView, lineN, dims);
        }

        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }

        cur = lineView.node.nextSibling;
      }

      lineN += lineView.size;
    }

    while (cur) {
      cur = rm(cur);
    }
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  } // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.


  function updateGutters(cm) {
    var gutters = cm.display.gutters,
        specs = cm.options.gutters;
    removeChildren(gutters);
    var i = 0;

    for (; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));

      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }

    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  } // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.


  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");

    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  } // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.


  var wheelSamples = 0;
  var wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).

  if (ie) {
    wheelPixelsPerUnit = -.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX,
        dy = e.wheelDeltaY;

    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }

    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }

    return {
      x: dx,
      y: dy
    };
  }

  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e),
        dx = delta.x,
        dy = delta.y;
    var display = cm.display,
        scroll = display.scroller; // Quit if there's nothing to scroll here

    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;

    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    } // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.


    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    } // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.


    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
      }

      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)

      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }

      display.wheelStartX = null; // Abort measurement, if in progress

      return;
    } // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).


    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop,
          bot = top + display.wrapper.clientHeight;

      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }

      updateDisplaySimple(cm, {
        top: top,
        bottom: bot
      });
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) {
            return;
          }

          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;

          if (!sample) {
            return;
          }

          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  } // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).


  var Selection = function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () {
    return this.ranges[this.primIndex];
  };

  Selection.prototype.equals = function (other) {
    var this$1 = this;

    if (other == this) {
      return true;
    }

    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }

    for (var i = 0; i < this.ranges.length; i++) {
      var here = this$1.ranges[i],
          there = other.ranges[i];

      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }

    return true;
  };

  Selection.prototype.deepCopy = function () {
    var this$1 = this;
    var out = [];

    for (var i = 0; i < this.ranges.length; i++) {
      out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
    }

    return new Selection(out, this.primIndex);
  };

  Selection.prototype.somethingSelected = function () {
    var this$1 = this;

    for (var i = 0; i < this.ranges.length; i++) {
      if (!this$1.ranges[i].empty()) {
        return true;
      }
    }

    return false;
  };

  Selection.prototype.contains = function (pos, end) {
    var this$1 = this;

    if (!end) {
      end = pos;
    }

    for (var i = 0; i < this.ranges.length; i++) {
      var range = this$1.ranges[i];

      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
        return i;
      }
    }

    return -1;
  };

  var Range = function Range(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };

  Range.prototype.from = function () {
    return minPos(this.anchor, this.head);
  };

  Range.prototype.to = function () {
    return maxPos(this.anchor, this.head);
  };

  Range.prototype.empty = function () {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  }; // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).


  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);

    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i],
          prev = ranges[i - 1];

      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()),
            to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;

        if (i <= primIndex) {
          --primIndex;
        }

        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }

    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  } // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).


  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }

    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  } // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.


  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }

    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
        ch = pos.ch;

    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }

    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
    }

    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  } // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".


  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0),
        newPrev = oldPrev;

    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;

      if (hint == "around") {
        var range = doc.sel.ranges[i],
            inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }

    return new Selection(out, doc.sel.primIndex);
  } // Used to get the editor into a consistent state again when options change.


  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }

      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;

    if (cm.curOp) {
      regChange(cm);
    }
  } // DOCUMENT DATA STRUCTURE
  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.


  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  } // Perform a change on the document data structure.


  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }

    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight$$1);
      signalLater(line, "change", line, change);
    }

    function linesFor(start, end) {
      var result = [];

      for (var i = start; i < end; ++i) {
        result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
      }

      return result;
    }

    var from = change.from,
        to = change.to,
        text = change.text;
    var firstLine = getLine(doc, from.line),
        lastLine = getLine(doc, to.line);
    var lastText = lst(text),
        lastSpans = spansFor(text.length - 1),
        nlines = to.line - from.line; // Adjust the line structure

    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);

      if (nlines) {
        doc.remove(from.line, nlines);
      }

      if (added.length) {
        doc.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);

      if (nlines > 1) {
        doc.remove(from.line + 1, nlines - 1);
      }

      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  } // Call f for all linked documents.


  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) {
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];

          if (rel.doc == skip) {
            continue;
          }

          var shared = sharedHist && rel.sharedHist;

          if (sharedHistOnly && !shared) {
            continue;
          }

          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
      }
    }

    propagate(doc, null, true);
  } // Attach a document to an editor.


  function attachDoc(cm, doc) {
    if (doc.cm) {
      throw new Error("This document is already in use.");
    }

    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);

    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }

    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = [];
    this.undone = [];
    this.undoDepth = Infinity; // Used to track when changes can be merged into a single undo
    // event

    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method

    this.generation = this.maxGeneration = startGen || 1;
  } // Create a history change event from an updateDoc-style change
  // object.


  function historyChangeFromChange(doc, change) {
    var histChange = {
      from: copyPos(change.from),
      to: changeEnd(change),
      text: getBetween(doc, change.from, change.to)
    };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  } // Pop all selection events off the end of a history array. Stop at
  // a change event.


  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);

      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  } // Find the top change event in the history. Pop off selection
  // events that are in the way.


  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  } // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.


  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(),
        cur;
    var last;

    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);

      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);

      if (!before || !before.ranges) {
        pushSelectionToHistory(doc.sel, hist.done);
      }

      cur = {
        changes: [historyChangeFromChange(doc, change)],
        generation: hist.generation
      };
      hist.done.push(cur);

      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();

        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }

    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) {
      signal(doc, "historyAdded");
    }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  } // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).


  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history,
        origin = options && options.origin; // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.

    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }

    hist.lastSelTime = +new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;

    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);

    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  } // Used to store marked span information in the history.


  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id],
        n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      }

      ++n;
    });
  } // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.


  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }

    var out;

    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i);
        }
      } else if (out) {
        out.push(spans[i]);
      }
    }

    return !out ? spans : out.length ? out : null;
  } // Retrieve and filter the old marked spans stored in a change event.


  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];

    if (!found) {
      return null;
    }

    var nw = [];

    for (var i = 0; i < change.text.length; ++i) {
      nw.push(removeClearedSpans(found[i]));
    }

    return nw;
  } // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).


  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);

    if (!old) {
      return stretched;
    }

    if (!stretched) {
      return old;
    }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i],
          stretchCur = stretched[i];

      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];

          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }

          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }

    return old;
  } // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two


  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];

    for (var i = 0; i < events.length; ++i) {
      var event = events[i];

      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }

      var changes = event.changes,
          newChanges = [];
      copy.push({
        changes: newChanges
      });

      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j],
            m = void 0;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });

        if (newGroup) {
          for (var prop in change) {
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
      }
    }

    return copy;
  } // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.
  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.


  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;

      if (other) {
        var posBefore = cmp(head, anchor) < 0;

        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }

      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  } // Extend the primary selection range, discard the rest.


  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) {
      extend = doc.cm && (doc.cm.display.shift || doc.extend);
    }

    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  } // Extend all selections (pos is an array of selections with length
  // equal the number of selections)


  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
    }

    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  } // Updates a single range in the selection.


  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  } // Reset the selection to a single range.


  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  } // Give beforeSelectionChange handlers a change to influence a
  // selection update.


  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function update(ranges) {
        var this$1 = this;
        this.ranges = [];

        for (var i = 0; i < ranges.length; i++) {
          this$1.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));
        }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);

    if (doc.cm) {
      signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    }

    if (obj.ranges != sel.ranges) {
      return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done,
        last = lst(done);

    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  } // Set a new selection.


  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc, sel, options);
    }

    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm) {
      ensureCursorVisible(doc.cm);
    }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) {
      return;
    }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }

    signalLater(doc, "cursorActivity", doc);
  } // Verify that the selection does not partially select any atomic
  // marked ranges.


  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  } // Return a selection that does not partially select any atomic
  // ranges.


  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;

    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);

      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) {
          out = sel.ranges.slice(0, i);
        }

        out[i] = new Range(newAnchor, newHead);
      }
    }

    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);

    if (line.markedSpans) {
      for (var i = 0; i < line.markedSpans.length; ++i) {
        var sp = line.markedSpans[i],
            m = sp.marker;

        if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");

            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i;
                continue;
              }
            }
          }

          if (!m.atomic) {
            continue;
          }

          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1),
                diff = void 0;

            if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft) {
              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
            }

            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc, near, pos, dir, mayClear);
            }
          }

          var far = m.find(dir < 0 ? -1 : 1);

          if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) {
            far = movePos(doc, far, dir, far.line == pos.line ? line : null);
          }

          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
        }
      }
    }

    return pos;
  } // Ensure a given position is not inside an atomic range.


  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);

    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0);
    }

    return found;
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) {
        return _clipPos(doc, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  } // UPDATING
  // Allow "beforeChange" event handlers to influence a change


  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function cancel() {
        return obj.canceled = true;
      }
    };

    if (update) {
      obj.update = function (from, to, text, origin) {
        if (from) {
          obj.from = _clipPos(doc, from);
        }

        if (to) {
          obj.to = _clipPos(doc, to);
        }

        if (text) {
          obj.text = text;
        }

        if (origin !== undefined) {
          obj.origin = origin;
        }
      };
    }

    signal(doc, "beforeChange", doc, obj);

    if (doc.cm) {
      signal(doc.cm, "beforeChange", doc.cm, obj);
    }

    if (obj.canceled) {
      return null;
    }

    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  } // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.


  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) {
        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      }

      if (doc.cm.state.suppressEdits) {
        return;
      }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);

      if (!change) {
        return;
      }
    } // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.


    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);

    if (split) {
      for (var i = split.length - 1; i >= 0; --i) {
        makeChangeInner(doc, {
          from: split[i].from,
          to: split[i].to,
          text: i ? [""] : change.text,
          origin: change.origin
        });
      }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }

    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }

      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  } // Revert a change stored in a document's history.


  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;

    if (suppress && !allowSelectionOnly) {
      return;
    }

    var hist = doc.history,
        event,
        selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone,
        dest = type == "undo" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)

    var i = 0;

    for (; i < source.length; i++) {
      event = source[i];

      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
        break;
      }
    }

    if (i == source.length) {
      return;
    }

    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();

      if (event.ranges) {
        pushSelectionToHistory(event, dest);

        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {
            clearRedo: false
          });
          return;
        }

        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return;
      } else {
        break;
      }
    } // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).


    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({
      changes: antiChanges,
      generation: hist.generation
    });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function loop(i) {
      var change = event.changes[i];
      change.origin = type;

      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {};
      }

      antiChanges.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));

      if (!i && doc.cm) {
        doc.cm.scrollIntoView({
          from: change.from,
          to: changeEnd(change)
        });
      }

      var rebased = []; // Propagate to the linked documents

      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }

        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop(i$1);
      if (returned) return returned.v;
    }
  } // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.


  function shiftDoc(doc, distance) {
    if (distance == 0) {
      return;
    }

    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);

    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);

      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc.cm, l, "gutter");
      }
    }
  } // More lower-level change function, handling only a single document
  // (not linked ones).


  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }

    if (change.from.line > doc.lastLine()) {
      return;
    } // Clip the change to the size of this doc


    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }

    var last = doc.lastLine();

    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) {
      selAfter = computeSelAfterChange(doc, change);
    }

    if (doc.cm) {
      makeChangeSingleDocInEditor(doc.cm, change, spans);
    } else {
      updateDoc(doc, change, spans);
    }

    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  } // Handle the interaction of a change to a document with the editor
  // that this document is part of.


  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc,
        display = cm.display,
        from = change.from,
        to = change.to;
    var recomputeMaxLength = false,
        checkWidthStart = from.line;

    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);

        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });

      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display

    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }

    var changesHandler = hasHandler(cm, "changes"),
        changeHandler = hasHandler(cm, "change");

    if (changeHandler || changesHandler) {
      var obj = {
        from: from,
        to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };

      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }

      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }

    cm.display.selForContextMenu = null;
  }

  function _replaceRange(doc, code, from, to, origin) {
    if (!to) {
      to = from;
    }

    if (cmp(to, from) < 0) {
      var assign;
      assign = [to, from], from = assign[0], to = assign[1];
    }

    if (typeof code == "string") {
      code = doc.splitLines(code);
    }

    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    });
  } // Rebasing/resetting history to deal with externally-sourced changes


  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  } // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.


  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i],
          ok = true;

      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i] = sub.deepCopy();
          sub.copied = true;
        }

        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }

        continue;
      }

      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];

        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }

      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line,
        to = change.to.line,
        diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  } // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.


  function changeLine(doc, handle, changeType, op) {
    var no = handle,
        line = handle;

    if (typeof handle == "number") {
      line = getLine(doc, clipLine(doc, handle));
    } else {
      no = lineNo(handle);
    }

    if (no == null) {
      return null;
    }

    if (op(line, no) && doc.cm) {
      regLineChange(doc.cm, no, changeType);
    }

    return line;
  } // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html


  function LeafChunk(lines) {
    var this$1 = this;
    this.lines = lines;
    this.parent = null;
    var height = 0;

    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this$1;
      height += lines[i].height;
    }

    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function removeInner(at, n) {
      var this$1 = this;

      for (var i = at, e = at + n; i < e; ++i) {
        var line = this$1.lines[i];
        this$1.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }

      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function collapse(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));

      for (var i = 0; i < lines.length; ++i) {
        lines[i].parent = this$1;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function iterN(at, n, op) {
      var this$1 = this;

      for (var e = at + n; at < e; ++at) {
        if (op(this$1.lines[at])) {
          return true;
        }
      }
    }
  };

  function BranchChunk(children) {
    var this$1 = this;
    this.children = children;
    var size = 0,
        height = 0;

    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this$1;
    }

    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function chunkSize() {
      return this.size;
    },
    removeInner: function removeInner(at, n) {
      var this$1 = this;
      this.size -= n;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();

        if (at < sz) {
          var rm = Math.min(n, sz - at),
              oldHeight = child.height;
          child.removeInner(at, rm);
          this$1.height -= oldHeight - child.height;

          if (sz == rm) {
            this$1.children.splice(i--, 1);
            child.parent = null;
          }

          if ((n -= rm) == 0) {
            break;
          }

          at = 0;
        } else {
          at -= sz;
        }
      } // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.


      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function collapse(lines) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        this$1.children[i].collapse(lines);
      }
    },
    insertInner: function insertInner(at, lines, height) {
      var this$1 = this;
      this.size += lines.length;
      this.height += height;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();

        if (at <= sz) {
          child.insertInner(at, lines, height);

          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;

            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this$1.children.splice(++i, 0, leaf);
              leaf.parent = this$1;
            }

            child.lines = child.lines.slice(0, remaining);
            this$1.maybeSpill();
          }

          break;
        }

        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function maybeSpill() {
      if (this.children.length <= 10) {
        return;
      }

      var me = this;

      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);

        if (!me.parent) {
          // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }

        sibling.parent = me.parent;
      } while (me.children.length > 10);

      me.parent.maybeSpill();
    },
    iterN: function iterN(at, n, op) {
      var this$1 = this;

      for (var i = 0; i < this.children.length; ++i) {
        var child = this$1.children[i],
            sz = child.chunkSize();

        if (at < sz) {
          var used = Math.min(n, sz - at);

          if (child.iterN(at, used, op)) {
            return true;
          }

          if ((n -= used) == 0) {
            break;
          }

          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  }; // Line widgets are block elements displayed above or below a line.

  var LineWidget = function LineWidget(doc, node, options) {
    var this$1 = this;

    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this$1[opt] = options[opt];
        }
      }
    }

    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var this$1 = this;
    var cm = this.doc.cm,
        ws = this.line.widgets,
        line = this.line,
        no = lineNo(line);

    if (no == null || !ws) {
      return;
    }

    for (var i = 0; i < ws.length; ++i) {
      if (ws[i] == this$1) {
        ws.splice(i--, 1);
      }
    }

    if (!ws.length) {
      line.widgets = null;
    }

    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));

    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
    var this$1 = this;
    var oldH = this.height,
        cm = this.doc.cm,
        line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;

    if (!diff) {
      return;
    }

    if (!lineIsHidden(this.doc, line)) {
      updateLineHeight(line, line.height + diff);
    }

    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };

  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;

    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }

    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);

      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      }

      widget.line = line;

      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = _heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));

        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }

        cm.curOp.forceUpdate = true;
      }

      return true;
    });

    if (cm) {
      signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    }

    return widget;
  } // TEXTMARKERS
  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.
  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).


  var nextMarkerId = 0;

  var TextMarker = function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  }; // Clear the marker.


  TextMarker.prototype.clear = function () {
    var this$1 = this;

    if (this.explicitlyCleared) {
      return;
    }

    var cm = this.doc.cm,
        withOp = cm && !cm.curOp;

    if (withOp) {
      _startOperation(cm);
    }

    if (hasHandler(this, "clear")) {
      var found = this.find();

      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }

    var min = null,
        max = null;

    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);

      if (cm && !this$1.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }

        if (span.from != null) {
          min = lineNo(line);
        }
      }

      line.markedSpans = removeMarkedSpan(line.markedSpans, span);

      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }

    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
        var visual = visualLine(this$1.lines[i$1]),
            len = lineLength(visual);

        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }

    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }

    this.lines.length = 0;
    this.explicitlyCleared = true;

    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;

      if (cm) {
        reCheckSelection(cm.doc);
      }
    }

    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }

    if (withOp) {
      _endOperation(cm);
    }

    if (this.parent) {
      this.parent.clear();
    }
  }; // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).


  TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;

    if (side == null && this.type == "bookmark") {
      side = 1;
    }

    var from, to;

    for (var i = 0; i < this.lines.length; ++i) {
      var line = this$1.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this$1);

      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);

        if (side == -1) {
          return from;
        }
      }

      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);

        if (side == 1) {
          return to;
        }
      }
    }

    return from && {
      from: from,
      to: to
    };
  }; // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.


  TextMarker.prototype.changed = function () {
    var this$1 = this;
    var pos = this.find(-1, true),
        widget = this,
        cm = this.doc.cm;

    if (!pos || !cm) {
      return;
    }

    runInOp(cm, function () {
      var line = pos.line,
          lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);

      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }

      cm.curOp.updateMaxLine = true;

      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;

        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }

      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;

      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }

    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);

    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and

  function _markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) {
      return markTextShared(doc, from, to, options, type);
    } // Ensure we are in an operation.


    if (doc.cm && !doc.cm.curOp) {
      return operation(doc.cm, _markText)(doc, from, to, options, type);
    }

    var marker = new TextMarker(doc, type),
        diff = cmp(from, to);

    if (options) {
      copyObj(options, marker, false);
    } // Don't connect empty markers unless clearWhenEmpty is false


    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }

    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");

      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }

      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }

    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }

      seeCollapsedSpans();
    }

    if (marker.addToHistory) {
      addChangeToHistory(doc, {
        from: from,
        to: to,
        origin: "markText"
      }, doc.sel, NaN);
    }

    var curLine = from.line,
        cm = doc.cm,
        updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }

      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }

      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
      ++curLine;
    }); // lineIsHidden depends on the presence of the spans, so needs a second pass

    if (marker.collapsed) {
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line)) {
          updateLineHeight(line, 0);
        }
      });
    }

    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function () {
        return marker.clear();
      });
    }

    if (marker.readOnly) {
      seeReadOnlySpans();

      if (doc.history.done.length || doc.history.undone.length) {
        doc.clearHistory();
      }
    }

    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }

    if (cm) {
      // Sync editor state
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }

      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) {
        for (var i = from.line; i <= to.line; i++) {
          regLineChange(cm, i, "text");
        }
      }

      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }

      signalLater(cm, "markerAdded", cm, marker);
    }

    return marker;
  } // SHARED TEXTMARKERS
  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.


  var SharedTextMarker = function SharedTextMarker(markers, primary) {
    var this$1 = this;
    this.markers = markers;
    this.primary = primary;

    for (var i = 0; i < markers.length; ++i) {
      markers[i].parent = this$1;
    }
  };

  SharedTextMarker.prototype.clear = function () {
    var this$1 = this;

    if (this.explicitlyCleared) {
      return;
    }

    this.explicitlyCleared = true;

    for (var i = 0; i < this.markers.length; ++i) {
      this$1.markers[i].clear();
    }

    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [_markText(doc, from, to, options, type)],
        primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }

      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));

      for (var i = 0; i < doc.linked.length; ++i) {
        if (doc.linked[i].isParent) {
          return;
        }
      }

      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
      return m.parent;
    });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i],
          pos = marker.find();
      var mFrom = doc.clipPos(pos.from),
          mTo = doc.clipPos(pos.to);

      if (cmp(mFrom, mTo)) {
        var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);

        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function loop(i) {
      var marker = markers[i],
          linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) {
        return linked.push(d);
      });

      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];

        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) {
      loop(i);
    }
  }

  var nextDocId = 0;

  var Doc = function Doc(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }

    if (firstLine == null) {
      firstLine = 0;
    }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") {
      text = this.splitLines(text);
    }

    updateDoc(this, {
      from: start,
      to: start,
      text: text
    });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function iter(from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },
    // Non-public interface for adding and removing lines.
    insert: function insert(at, lines) {
      var height = 0;

      for (var i = 0; i < lines.length; ++i) {
        height += lines[i].height;
      }

      this.insertInner(at - this.first, lines, height);
    },
    remove: function remove(at, n) {
      this.removeInner(at - this.first, n);
    },
    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.
    getValue: function getValue(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);

      if (lineSep === false) {
        return lines;
      }

      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function (code) {
      var top = Pos(this.first, 0),
          last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code),
        origin: "setValue",
        full: true
      }, true);

      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }

      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function replaceRange(code, from, to, origin) {
      from = _clipPos(this, from);
      to = to ? _clipPos(this, to) : from;

      _replaceRange(this, code, from, to, origin);
    },
    getRange: function getRange(from, to, lineSep) {
      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));

      if (lineSep === false) {
        return lines;
      }

      return lines.join(lineSep || this.lineSeparator());
    },
    getLine: function getLine(line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function getLineHandle(line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function getLineNumber(line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function getLineHandleVisualStart(line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }

      return visualLine(line);
    },
    lineCount: function lineCount() {
      return this.size;
    },
    firstLine: function firstLine() {
      return this.first;
    },
    lastLine: function lastLine() {
      return this.first + this.size - 1;
    },
    clipPos: function clipPos(pos) {
      return _clipPos(this, pos);
    },
    getCursor: function getCursor(start) {
      var range$$1 = this.sel.primary(),
          pos;

      if (start == null || start == "head") {
        pos = range$$1.head;
      } else if (start == "anchor") {
        pos = range$$1.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range$$1.to();
      } else {
        pos = range$$1.from();
      }

      return pos;
    },
    listSelections: function listSelections() {
      return this.sel.ranges;
    },
    somethingSelected: function somethingSelected() {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function (line, ch, options) {
      setSimpleSelection(this, _clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function (anchor, head, options) {
      setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function (head, other, options) {
      extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function (heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function (f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function (ranges, primary, options) {
      var this$1 = this;

      if (!ranges.length) {
        return;
      }

      var out = [];

      for (var i = 0; i < ranges.length; i++) {
        out[i] = new Range(_clipPos(this$1, ranges[i].anchor), _clipPos(this$1, ranges[i].head));
      }

      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }

      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function (anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),
    getSelection: function getSelection(lineSep) {
      var this$1 = this;
      var ranges = this.sel.ranges,
          lines;

      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }

      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function getSelections(lineSep) {
      var this$1 = this;
      var parts = [],
          ranges = this.sel.ranges;

      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());

        if (lineSep !== false) {
          sel = sel.join(lineSep || this$1.lineSeparator());
        }

        parts[i] = sel;
      }

      return parts;
    },
    replaceSelection: function replaceSelection(code, collapse, origin) {
      var dup = [];

      for (var i = 0; i < this.sel.ranges.length; i++) {
        dup[i] = code;
      }

      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function (code, collapse, origin) {
      var this$1 = this;
      var changes = [],
          sel = this.sel;

      for (var i = 0; i < sel.ranges.length; i++) {
        var range$$1 = sel.ranges[i];
        changes[i] = {
          from: range$$1.from(),
          to: range$$1.to(),
          text: this$1.splitLines(code[i]),
          origin: origin
        };
      }

      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);

      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
        makeChange(this$1, changes[i$1]);
      }

      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function () {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function () {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function () {
      makeChangeFromHistory(this, "redo", true);
    }),
    setExtending: function setExtending(val) {
      this.extend = val;
    },
    getExtending: function getExtending() {
      return this.extend;
    },
    historySize: function historySize() {
      var hist = this.history,
          done = 0,
          undone = 0;

      for (var i = 0; i < hist.done.length; i++) {
        if (!hist.done[i].ranges) {
          ++done;
        }
      }

      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
        if (!hist.undone[i$1].ranges) {
          ++undone;
        }
      }

      return {
        undo: done,
        redo: undone
      };
    },
    clearHistory: function clearHistory() {
      this.history = new History(this.history.maxGeneration);
    },
    markClean: function markClean() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function changeGeneration(forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }

      return this.history.generation;
    },
    isClean: function isClean(gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function getHistory() {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function setHistory(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    setGutterMarker: docMethodOp(function (line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;

        if (!value && isEmpty(markers)) {
          line.gutterMarkers = null;
        }

        return true;
      });
    }),
    clearGutter: docMethodOp(function (gutterID) {
      var this$1 = this;
      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;

            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }

            return true;
          });
        }
      });
    }),
    lineInfo: function lineInfo(line) {
      var n;

      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }

        n = line;
        line = getLine(this, line);

        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);

        if (n == null) {
          return null;
        }
      }

      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    addLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";

        if (!line[prop]) {
          line[prop] = cls;
        } else if (classTest(cls).test(line[prop])) {
          return false;
        } else {
          line[prop] += " " + cls;
        }

        return true;
      });
    }),
    removeLineClass: docMethodOp(function (handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];

        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop] = null;
        } else {
          var found = cur.match(classTest(cls));

          if (!found) {
            return false;
          }

          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }

        return true;
      });
    }),
    addLineWidget: docMethodOp(function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function removeLineWidget(widget) {
      widget.clear();
    },
    markText: function markText(from, to, options) {
      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function setBookmark(pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false,
        shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = _clipPos(this, pos);
      return _markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function findMarksAt(pos) {
      pos = _clipPos(this, pos);
      var markers = [],
          spans = getLine(this, pos.line).markedSpans;

      if (spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];

          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }

      return markers;
    },
    findMarks: function findMarks(from, to, filter) {
      from = _clipPos(this, from);
      to = _clipPos(this, to);
      var found = [],
          lineNo$$1 = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;

        if (spans) {
          for (var i = 0; i < spans.length; i++) {
            var span = spans[i];

            if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to || span.from == null && lineNo$$1 != from.line || span.from != null && lineNo$$1 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }

        ++lineNo$$1;
      });
      return found;
    },
    getAllMarks: function getAllMarks() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;

        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            if (sps[i].from != null) {
              markers.push(sps[i].marker);
            }
          }
        }
      });
      return markers;
    },
    posFromIndex: function posFromIndex(off) {
      var ch,
          lineNo$$1 = this.first,
          sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;

        if (sz > off) {
          ch = off;
          return true;
        }

        off -= sz;
        ++lineNo$$1;
      });
      return _clipPos(this, Pos(lineNo$$1, ch));
    },
    indexFromPos: function indexFromPos(coords) {
      coords = _clipPos(this, coords);
      var index = coords.ch;

      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }

      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) {
        // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index;
    },
    copy: function copy(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;

      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }

      return doc;
    },
    linkedDoc: function linkedDoc(options) {
      if (!options) {
        options = {};
      }

      var from = this.first,
          to = this.first + this.size;

      if (options.from != null && options.from > from) {
        from = options.from;
      }

      if (options.to != null && options.to < to) {
        to = options.to;
      }

      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);

      if (options.sharedHist) {
        copy.history = this.history;
      }

      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
        doc: this,
        isParent: true,
        sharedHist: options.sharedHist
      }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function unlinkDoc(other) {
      var this$1 = this;

      if (other instanceof CodeMirror$1) {
        other = other.doc;
      }

      if (this.linked) {
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this$1.linked[i];

          if (link.doc != other) {
            continue;
          }

          this$1.linked.splice(i, 1);
          other.unlinkDoc(this$1);
          detachSharedMarkers(findSharedMarkers(this$1));
          break;
        }
      } // If the histories were shared, split them again


      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          return splitIds.push(doc.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function iterLinkedDocs(f) {
      linkedDocs(this, f);
    },
    getMode: function getMode() {
      return this.mode;
    },
    getEditor: function getEditor() {
      return this.cm;
    },
    splitLines: function splitLines(str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }

      return splitLinesAuto(str);
    },
    lineSeparator: function lineSeparator() {
      return this.lineSep || "\n";
    },
    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }

      if (dir == this.direction) {
        return;
      }

      this.direction = dir;
      this.iter(function (line) {
        return line.order = null;
      });

      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  }); // Public alias.

  Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)

  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);

    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }

    e_preventDefault(e);

    if (ie) {
      lastDrop = +new Date();
    }

    var pos = posFromMouse(cm, e, true),
        files = e.dataTransfer.files;

    if (!pos || cm.isReadOnly()) {
      return;
    } // Might be a file drop, in which case we simply extract the text
    // and insert it.


    if (files && files.length && window.FileReader && window.File) {
      var n = files.length,
          text = Array(n),
          read = 0;

      var loadFile = function loadFile(file, i) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          return;
        }

        var reader = new FileReader();
        reader.onload = operation(cm, function () {
          var content = reader.result;

          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            content = "";
          }

          text[i] = content;

          if (++read == n) {
            pos = _clipPos(cm.doc, pos);
            var change = {
              from: pos,
              to: pos,
              text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };

      for (var i = 0; i < n; ++i) {
        loadFile(files[i], i);
      }
    } else {
      // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e); // Ensure the editor is re-focused

        setTimeout(function () {
          return cm.display.input.focus();
        }, 20);
        return;
      }

      try {
        var text$1 = e.dataTransfer.getData("Text");

        if (text$1) {
          var selected;

          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }

          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));

          if (selected) {
            for (var i$1 = 0; i$1 < selected.length; ++i$1) {
              _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
            }
          }

          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e) {}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }

    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove"; // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.

    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason

        img._top = img.offsetTop;
      }

      e.dataTransfer.setDragImage(img, 0, 0);

      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);

    if (!pos) {
      return;
    }

    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);

    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }

    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  } // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.


  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }

    var byClass = document.getElementsByClassName("CodeMirror");

    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;

      if (cm) {
        f(cm);
      }
    }
  }

  var globalsRegistered = false;

  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }

    registerGlobalHandlers();
    globalsRegistered = true;
  }

  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function () {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    }); // When the window loses focus, we want to show the editor as blurred

    on(window, "blur", function () {
      return forEachCodeMirror(onBlur);
    });
  } // Called when the window resizes


  function onResize(cm) {
    var d = cm.display; // Might be a text scaling operation, clear size caches.

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause",
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    44: "PrintScrn",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Mod",
    92: "Mod",
    93: "Mod",
    106: "*",
    107: "=",
    109: "-",
    110: ".",
    111: "/",
    127: "Delete",
    145: "ScrollLock",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'",
    63232: "Up",
    63233: "Down",
    63234: "Left",
    63235: "Right",
    63272: "Delete",
    63273: "Home",
    63275: "End",
    63276: "PageUp",
    63277: "PageDown",
    63302: "Insert"
  }; // Number keys

  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  } // Alphabetic keys


  for (var i$1 = 65; i$1 <= 90; i$1++) {
    keyNames[i$1] = String.fromCharCode(i$1);
  } // Function keys


  for (var i$2 = 1; i$2 <= 12; i$2++) {
    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
  }

  var keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft",
    "Right": "goCharRight",
    "Up": "goLineUp",
    "Down": "goLineDown",
    "End": "goLineEnd",
    "Home": "goLineStartSmart",
    "PageUp": "goPageUp",
    "PageDown": "goPageDown",
    "Delete": "delCharAfter",
    "Backspace": "delCharBefore",
    "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab",
    "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent",
    "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  }; // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.

  keyMap.pcDefault = {
    "Ctrl-A": "selectAll",
    "Ctrl-D": "deleteLine",
    "Ctrl-Z": "undo",
    "Shift-Ctrl-Z": "redo",
    "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart",
    "Ctrl-End": "goDocEnd",
    "Ctrl-Up": "goLineUp",
    "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft",
    "Ctrl-Right": "goGroupRight",
    "Alt-Left": "goLineStart",
    "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore",
    "Ctrl-Delete": "delGroupAfter",
    "Ctrl-S": "save",
    "Ctrl-F": "find",
    "Ctrl-G": "findNext",
    "Shift-Ctrl-G": "findPrev",
    "Shift-Ctrl-F": "replace",
    "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess",
    "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection",
    "Shift-Ctrl-U": "redoSelection",
    "Alt-U": "redoSelection",
    "fallthrough": "basic"
  }; // Very basic readline/emacs-style bindings, which are standard on Mac.

  keyMap.emacsy = {
    "Ctrl-F": "goCharRight",
    "Ctrl-B": "goCharLeft",
    "Ctrl-P": "goLineUp",
    "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight",
    "Alt-B": "goWordLeft",
    "Ctrl-A": "goLineStart",
    "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown",
    "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter",
    "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter",
    "Alt-Backspace": "delWordBefore",
    "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll",
    "Cmd-D": "deleteLine",
    "Cmd-Z": "undo",
    "Shift-Cmd-Z": "redo",
    "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart",
    "Cmd-Up": "goDocStart",
    "Cmd-End": "goDocEnd",
    "Cmd-Down": "goDocEnd",
    "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight",
    "Cmd-Left": "goLineLeft",
    "Cmd-Right": "goLineRight",
    "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter",
    "Alt-Delete": "delGroupAfter",
    "Cmd-S": "save",
    "Cmd-F": "find",
    "Cmd-G": "findNext",
    "Shift-Cmd-G": "findPrev",
    "Cmd-Alt-F": "replace",
    "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess",
    "Cmd-]": "indentMore",
    "Cmd-Backspace": "delWrappedLineLeft",
    "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection",
    "Shift-Cmd-U": "redoSelection",
    "Ctrl-Up": "goDocStart",
    "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;

    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];

      if (/^(cmd|meta|m)$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }

    if (alt) {
      name = "Alt-" + name;
    }

    if (ctrl) {
      name = "Ctrl-" + name;
    }

    if (cmd) {
      name = "Cmd-" + name;
    }

    if (shift) {
      name = "Shift-" + name;
    }

    return name;
  } // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.


  function normalizeKeyMap(keymap) {
    var copy = {};

    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];

        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
          continue;
        }

        if (value == "...") {
          delete keymap[keyname];
          continue;
        }

        var keys = map(keyname.split(" "), normalizeKeyName);

        for (var i = 0; i < keys.length; i++) {
          var val = void 0,
              name = void 0;

          if (i == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i + 1).join(" ");
            val = "...";
          }

          var prev = copy[name];

          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }

        delete keymap[keyname];
      }
    }

    for (var prop in copy) {
      keymap[prop] = copy[prop];
    }

    return keymap;
  }

  function lookupKey(key, map$$1, handle, context) {
    map$$1 = getKeyMap(map$$1);
    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];

    if (found === false) {
      return "nothing";
    }

    if (found === "...") {
      return "multi";
    }

    if (found != null && handle(found)) {
      return "handled";
    }

    if (map$$1.fallthrough) {
      if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]") {
        return lookupKey(key, map$$1.fallthrough, handle, context);
      }

      for (var i = 0; i < map$$1.fallthrough.length; i++) {
        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);

        if (result) {
          return result;
        }
      }
    }
  } // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.


  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }

  function addModifierNames(name, event, noShift) {
    var base = name;

    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }

    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }

    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
      name = "Cmd-" + name;
    }

    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }

    return name;
  } // Look up the name of a key as indicated by an event object.


  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }

    var name = keyNames[event.keyCode];

    if (name == null || event.altGraphKey) {
      return false;
    } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)


    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }

    return addModifierNames(name, event, noShift);
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  } // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.


  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges,
        kill = []; // Build up a set of ranges to kill first, merging overlapping
    // ranges.

    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);

      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();

        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }

      kill.push(toKill);
    } // Next, remove those actual ranges.


    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--) {
        _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      }

      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      var order = getOrder(lineObj, cm.doc.direction);

      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).

        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) {
            return measureCharPrepared(cm, prep, ch).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);

          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }

        return new Pos(lineNo, ch, sticky);
      }
    }

    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);

    if (!bidi) {
      return moveLogically(line, start, dir);
    }

    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }

    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
        part = bidi[partPos];

    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir);
    }

    var mv = function mv(pos, dir) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
    };

    var prep;

    var getWrappedLineExtent = function getWrappedLineExtent(ch) {
      if (!cm.options.lineWrapping) {
        return {
          begin: 0,
          end: line.text.length
        };
      }

      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch);
    };

    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);

      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    } // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part


    var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {
      var getRes = function getRes(ch, moveInStorageOrder) {
        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
      };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = dir > 0 == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);

        if (part.from <= ch && ch < part.to) {
          return getRes(ch, moveInStorageOrder);
        }

        ch = moveInStorageOrder ? part.from : mv(part.to, -1);

        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
          return getRes(ch, moveInStorageOrder);
        }
      }
    }; // Case 3a: Look for other bidi parts on the same visual line


    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);

    if (res) {
      return res;
    } // Case 3b: Look for other bidi parts on the next visual line


    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);

    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));

      if (res) {
        return res;
      }
    } // Case 4: Nowhere to move


    return null;
  } // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.


  var commands = {
    selectAll: selectAll,
    singleSelection: function singleSelection(cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function killLine(cm) {
      return deleteNearSelection(cm, function (range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;

          if (range.head.ch == len && range.head.line < cm.lastLine()) {
            return {
              from: range.head,
              to: Pos(range.head.line + 1, 0)
            };
          } else {
            return {
              from: range.head,
              to: Pos(range.head.line, len)
            };
          }
        } else {
          return {
            from: range.from(),
            to: range.to()
          };
        }
      });
    },
    deleteLine: function deleteLine(cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function delLineLeft(cm) {
      return deleteNearSelection(cm, function (range) {
        return {
          from: Pos(range.from().line, 0),
          to: range.from()
        };
      });
    },
    delWrappedLineLeft: function delWrappedLineLeft(cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");
        return {
          from: leftPos,
          to: range.from()
        };
      });
    },
    delWrappedLineRight: function delWrappedLineRight(cm) {
      return deleteNearSelection(cm, function (range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
        return {
          from: range.from(),
          to: rightPos
        };
      });
    },
    undo: function undo(cm) {
      return cm.undo();
    },
    redo: function redo(cm) {
      return cm.redo();
    },
    undoSelection: function undoSelection(cm) {
      return cm.undoSelection();
    },
    redoSelection: function redoSelection(cm) {
      return cm.redoSelection();
    },
    goDocStart: function goDocStart(cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function goDocEnd(cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function goLineStart(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStart(cm, range.head.line);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineStartSmart: function goLineStartSmart(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineStartSmart(cm, range.head);
      }, {
        origin: "+move",
        bias: 1
      });
    },
    goLineEnd: function goLineEnd(cm) {
      return cm.extendSelectionsBy(function (range) {
        return lineEnd(cm, range.head.line);
      }, {
        origin: "+move",
        bias: -1
      });
    },
    goLineRight: function goLineRight(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeft: function goLineLeft(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        return cm.coordsChar({
          left: 0,
          top: top
        }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function goLineLeftSmart(cm) {
      return cm.extendSelectionsBy(function (range) {
        var top = cm.cursorCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({
          left: 0,
          top: top
        }, "div");

        if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
          return lineStartSmart(cm, range.head);
        }

        return pos;
      }, sel_move);
    },
    goLineUp: function goLineUp(cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function goLineDown(cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function goPageUp(cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function goPageDown(cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function goCharLeft(cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function goCharRight(cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function goColumnLeft(cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function goColumnRight(cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function goWordLeft(cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function goGroupRight(cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function goGroupLeft(cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function goWordRight(cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function delCharBefore(cm) {
      return cm.deleteH(-1, "char");
    },
    delCharAfter: function delCharAfter(cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function delWordBefore(cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function delWordAfter(cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function delGroupBefore(cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function delGroupAfter(cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function indentAuto(cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function indentMore(cm) {
      return cm.indentSelection("add");
    },
    indentLess: function indentLess(cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function insertTab(cm) {
      return cm.replaceSelection("\t");
    },
    insertSoftTab: function insertSoftTab(cm) {
      var spaces = [],
          ranges = cm.listSelections(),
          tabSize = cm.options.tabSize;

      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }

      cm.replaceSelections(spaces);
    },
    defaultTab: function defaultTab(cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function transposeChars(cm) {
      return runInOp(cm, function () {
        var ranges = cm.listSelections(),
            newSel = [];

        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) {
            continue;
          }

          var cur = ranges[i].head,
              line = getLine(cm.doc, cur.line).text;

          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }

            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;

              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
              }
            }
          }

          newSel.push(new Range(cur, cur));
        }

        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function newlineAndIndent(cm) {
      return runInOp(cm, function () {
        var sels = cm.listSelections();

        for (var i = sels.length - 1; i >= 0; i--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
        }

        sels = cm.listSelections();

        for (var i$1 = 0; i$1 < sels.length; i$1++) {
          cm.indentLine(sels[i$1].from().line, null, true);
        }

        ensureCursorVisible(cm);
      });
    },
    openLine: function openLine(cm) {
      return cm.replaceSelection("\n", "start");
    },
    toggleOverwrite: function toggleOverwrite(cm) {
      return cm.toggleOverwrite();
    }
  };

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);

    if (visual != line) {
      lineN = lineNo(visual);
    }

    return endOfLine(true, cm, visual, lineN, 1);
  }

  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);

    if (visual != line) {
      lineN = lineNo(visual);
    }

    return endOfLine(true, cm, line, lineN, -1);
  }

  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);

    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(0, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }

    return start;
  } // Run a handler that was bound to a key.


  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];

      if (!bound) {
        return false;
      }
    } // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document


    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift,
        done = false;

    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }

      if (dropShift) {
        cm.display.shift = false;
      }

      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }

    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);

      if (result) {
        return result;
      }
    }

    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  } // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.


  var stopSeq = new Delayed();

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;

    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }

      if (/\'$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }

      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }

    return dispatchKeyInner(cm, name, e, handle);
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi") {
      cm.state.keySeq = name;
    }

    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result;
  } // Handle a key from the keydown event.


  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);

    if (!name) {
      return false;
    }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function (b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function (b) {
        return doHandleBinding(cm, b);
      });
    }
  } // Handle a key from the keypress event


  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) {
      return doHandleBinding(cm, b, true);
    });
  }

  var lastStoppedKey = null;

  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();

    if (signalDOMEvent(cm, e)) {
      return;
    } // IE does strange things with escape.


    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }

    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);

    if (presto) {
      lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo

      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    } // Turn mouse into crosshair when Alt is held on Mac.


    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }

    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }

    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;

    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }

    var keyCode = e.keyCode,
        charCode = e.charCode;

    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }

    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }

    var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace

    if (ch == "\x08") {
      return;
    }

    if (handleCharBinding(cm, e, ch)) {
      return;
    }

    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function PastClick(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };

  var lastClick;
  var lastDoubleClick;

  function clickRepeat(pos, button) {
    var now = +new Date();

    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  } // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.


  function onMouseDown(e) {
    var cm = this,
        display = cm.display;

    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }

    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () {
          return display.scroller.draggable = true;
        }, 100);
      }

      return;
    }

    if (clickInGutter(cm, e)) {
      return;
    }

    var pos = posFromMouse(cm, e),
        button = e_button(e),
        repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus(); // #3261: make sure, that we're not starting a second selection

    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
      return;
    }

    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }

      setTimeout(function () {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        onContextMenu(cm, e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";

    if (repeat == "double") {
      name = "Double" + name;
    } else if (repeat == "triple") {
      name = "Triple" + name;
    }

    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }

      if (!bound) {
        return false;
      }

      var done = false;

      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }

        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }

      return done;
    });
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};

    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }

    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }

    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }

    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }

    return value;
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt();
    }

    var behavior = configureMouse(cm, repeat, event);
    var sel = cm.doc.sel,
        contained;

    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  } // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.


  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display,
        moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) {
        display.scroller.draggable = false;
      }

      cm.state.draggingText = false;
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);

      if (!moved) {
        e_preventDefault(e);

        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)


        if (webkit || ie && ie_version == 9) {
          setTimeout(function () {
            display.wrapper.ownerDocument.body.focus();
            display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });

    var mouseMove = function mouseMove(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };

    var dragStart = function dragStart() {
      return moved = true;
    }; // Let the drag handler handle this.


    if (webkit) {
      display.scroller.draggable = true;
    }

    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag; // IE's approach to draggable

    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }

    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);
    delayBlurEvent(cm);
    setTimeout(function () {
      return display.input.focus();
    }, 20);
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }

    if (unit == "word") {
      return cm.findWordAt(pos);
    }

    if (unit == "line") {
      return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }

    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  } // Normal selection, as opposed to text dragging.


  function leftButtonSelect(cm, event, start, behavior) {
    var display = cm.display,
        doc = cm.doc;
    e_preventDefault(event);
    var ourRange,
        ourIndex,
        startSel = doc.sel,
        ranges = startSel.ranges;

    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);

      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }

      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range$$1 = rangeForUnit(cm, start, behavior.unit);

      if (behavior.extend) {
        ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend);
      } else {
        ourRange = range$$1;
      }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
        scroll: false,
        origin: "*mouse"
      });
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
        scroll: false,
        origin: "*mouse"
      });
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;

    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }

      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [],
            tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol),
            right = Math.max(startCol, posCol);

        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc, line).text,
              leftPos = findColumn(text, left, tabSize);

          if (left == right) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }

        if (!ranges.length) {
          ranges.push(new Range(start, start));
        }

        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
          origin: "*mouse",
          scroll: false
        });
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range$$1 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor,
            head;

        if (cmp(range$$1.anchor, anchor) > 0) {
          head = range$$1.head;
          anchor = minPos(oldRange.from(), range$$1.anchor);
        } else {
          head = range$$1.anchor;
          anchor = maxPos(oldRange.to(), range$$1.head);
        }

        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).

    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");

      if (!cur) {
        return;
      }

      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);

        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function () {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;

        if (outside) {
          setTimeout(operation(cm, function () {
            if (counter != curCount) {
              return;
            }

            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      e_preventDefault(e);
      display.input.focus();
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  } // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.


  function bidiSimplify(cm, range$$1) {
    var anchor = range$$1.anchor;
    var head = range$$1.head;
    var anchorLine = getLine(cm.doc, anchor.line);

    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range$$1;
    }

    var order = getOrder(anchorLine);

    if (!order) {
      return range$$1;
    }

    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
        part = order[index];

    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range$$1;
    }

    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);

    if (boundary == 0 || boundary == order.length) {
      return range$$1;
    } // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)


    var leftSide;

    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);

      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to,
        sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head);
  } // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.


  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;

    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;
        mY = e.clientY;
      } catch (e) {
        return false;
      }
    }

    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }

    if (prevent) {
      e_preventDefault(e);
    }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) {
      return e_defaultPrevented(e);
    }

    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];

      if (g && g.getBoundingClientRect().right >= mX) {
        var line = _lineAtHeight(cm.doc, mY);

        var gutter = cm.options.gutters[i];
        signal(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  } // CONTEXT MENU HANDLING
  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.


  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }

    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }

    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }

    return gutterEvent(cm, e, "gutterContextMenu", false);
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {
    toString: function toString() {
      return "CodeMirror.Init";
    }
  };
  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;

      if (handle) {
        optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }

    CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.

    CodeMirror.Init = Init; // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.

    option("value", "", function (cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);
    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;

      if (!val) {
        return;
      }

      var newBreaks = [],
          lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);

          if (found == -1) {
            break;
          }

          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }

        lineNo++;
      });

      for (var i = newBreaks.length - 1; i >= 0; i--) {
        _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
      }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");

      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);
    option("theme", "default", function (cm) {
      themeChanged(cm);
      guttersChanged(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);

      if (prev && prev.detach) {
        prev.detach(cm, next);
      }

      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);
    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm) {
      setGuttersForLineNumbers(cm.options);
      guttersChanged(cm);
    }, true);
    option("firstLineNumber", 1, guttersChanged, true);
    option("lineNumberFormatter", function (integer) {
      return integer;
    }, guttersChanged, true);
    option("showCursorWhenSelecting", false, updateSelection, true);
    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }

      cm.display.input.readOnlyChanged(val);
    });
    option("disableInput", false, function (cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);
    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });
    option("tabindex", null, function (cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) {
      return cm.doc.setDirection(val);
    }, true);
    option("phrases", null);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    alignHorizontally(cm);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;

    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }

    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      return updateScrollbars(cm);
    }, 100);
  } // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.


  function CodeMirror$1(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror$1)) {
      return new CodeMirror$1(place, options);
    }

    this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.

    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);
    var doc = options.value;

    if (typeof doc == "string") {
      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
    } else if (options.mode) {
      doc.modeOption = options.mode;
    }

    this.doc = doc;
    var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);

    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }

    initScrollbars(this);
    this.state = {
      keyMaps: [],
      // stores maps added by addKeyMap
      overlays: [],
      // highlighting overlays, as added by addOverlay
      modeGen: 0,
      // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false,
      // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false,
      cutIncoming: false,
      // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(),
      // stores highlight worker timeout
      keySeq: null,
      // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) {
      display.input.focus();
    } // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload


    if (ie && ie_version < 11) {
      setTimeout(function () {
        return this$1.display.input.reset(true);
      }, 20);
    }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    _startOperation(this);

    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(bind(onFocus, this), 20);
    } else {
      onBlur(this);
    }

    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this$1, options[opt], Init);
      }
    }

    maybeUpdateLineNumberWidth(this);

    if (options.finishInit) {
      options.finishInit(this);
    }

    for (var i = 0; i < initHooks.length; ++i) {
      initHooks[i](this$1);
    }

    _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.


    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  } // The default configuration options.


  CodeMirror$1.defaults = defaults; // Functions to run when options are changed.

  CodeMirror$1.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor

  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click

    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }

        var pos = posFromMouse(cm, e);

        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }

        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function (e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    } // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.


    if (!captureRightClick) {
      on(d.scroller, "contextmenu", function (e) {
        return onContextMenu(cm, e);
      });
    } // Used to suppress mouse event handling when a touch happens


    var touchFinished,
        prevTouch = {
      end: 0
    };

    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () {
          return d.activeTouch = null;
        }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date();
      }
    }

    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }

      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }

    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }

      var dx = other.left - touch.left,
          dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }

    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date();
        d.activeTouch = {
          start: now,
          moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };

        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;

      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"),
            range;

        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          {
            range = new Range(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          {
            range = cm.findWordAt(pos);
          } else // Triple tap
          {
            range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }

        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }

      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch); // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.

    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    }); // Listen to wheel events in order to try and update the viewport on time.

    on(d.scroller, "mousewheel", function (e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function (e) {
      return onScrollWheel(cm, e);
    }); // Prevent wrapper from ever scrolling

    on(d.wrapper, "scroll", function () {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    d.dragFunctions = {
      enter: function enter(e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function over(e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);
          e_stop(e);
        }
      },
      start: function start(e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function leave(e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };
    var inp = d.input.getField();
    on(inp, "keyup", function (e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function (e) {
      return onBlur(cm, e);
    });
  }

  var initHooks = [];

  CodeMirror$1.defineInitHook = function (f) {
    return initHooks.push(f);
  }; // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.


  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc,
        state;

    if (how == null) {
      how = "add";
    }

    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n),
        curSpace = countColumn(line.text, null, tabSize);

    if (line.stateAfter) {
      line.stateAfter = null;
    }

    var curSpaceString = line.text.match(/^\s*/)[0],
        indentation;

    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);

      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }

        how = "prev";
      }
    }

    if (how == "prev") {
      if (n > doc.first) {
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }

    indentation = Math.max(0, indentation);
    var indentString = "",
        pos = 0;

    if (cm.options.indentWithTabs) {
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += "\t";
      }
    }

    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }

    if (indentString != curSpaceString) {
      _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");

      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];

        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break;
        }
      }
    }
  } // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.


  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;

    if (!sel) {
      sel = doc.sel;
    }

    var paste = cm.state.pasteIncoming || origin == "paste";
    var textLines = splitLinesAuto(inserted),
        multiPaste = null; // When pasting N lines into N selections, insert one line per selection

    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];

          for (var i = 0; i < lastCopied.text.length; i++) {
            multiPaste.push(doc.splitLines(lastCopied.text[i]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) {
          return [l];
        });
      }
    }

    var updateInput; // Normal behavior is to insert the new text into every selection

    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range$$1 = sel.ranges[i$1];
      var from = range$$1.from(),
          to = range$$1.to();

      if (range$$1.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) // Handle overwrite
          {
            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
          from = to = Pos(from.line, 0);
        }
      }

      updateInput = cm.curOp.updateInput;
      var changeEvent = {
        from: from,
        to: to,
        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }

    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }

    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");

    if (pasted) {
      e.preventDefault();

      if (!cm.isReadOnly() && !cm.options.disableInput) {
        runInOp(cm, function () {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }

      return true;
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }

    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range$$1 = sel.ranges[i];

      if (range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line) {
        continue;
      }

      var mode = cm.getModeAt(range$$1.head);
      var indented = false;

      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range$$1.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch))) {
          indented = indentLine(cm, range$$1.head.line, "smart");
        }
      }

      if (indented) {
        signalLater(cm, "electricInput", cm, range$$1.head.line);
      }
    }
  }

  function copyableRanges(cm) {
    var text = [],
        ranges = [];

    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {
        anchor: Pos(line, 0),
        head: Pos(line + 1, 0)
      };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }

    return {
      text: text,
      ranges: ranges
    };
  }

  function disableBrowserMagic(field, spellcheck) {
    field.setAttribute("autocorrect", "off");
    field.setAttribute("autocapitalize", "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.

    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    } // If border: 0; -- iOS fails to open keyboard (issue #1287)


    if (ios) {
      te.style.border = "1px solid black";
    }

    disableBrowserMagic(te);
    return div;
  } // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.
  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.


  var addEditorMethods = function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;
    var helpers = CodeMirror.helpers = {};
    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function focus() {
        window.focus();
        this.display.input.focus();
      },
      setOption: function setOption(option, value) {
        var options = this.options,
            old = options[option];

        if (options[option] == value && option != "mode") {
          return;
        }

        options[option] = value;

        if (optionHandlers.hasOwnProperty(option)) {
          operation(this, optionHandlers[option])(this, value, old);
        }

        signal(this, "optionChange", this, option);
      },
      getOption: function getOption(option) {
        return this.options[option];
      },
      getDoc: function getDoc() {
        return this.doc;
      },
      addKeyMap: function addKeyMap(map$$1, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
      },
      removeKeyMap: function removeKeyMap(map$$1) {
        var maps = this.state.keyMaps;

        for (var i = 0; i < maps.length; ++i) {
          if (maps[i] == map$$1 || maps[i].name == map$$1) {
            maps.splice(i, 1);
            return true;
          }
        }
      },
      addOverlay: methodOp(function (spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);

        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }

        insertSorted(this.state.overlays, {
          mode: mode,
          modeSpec: spec,
          opaque: options && options.opaque,
          priority: options && options.priority || 0
        }, function (overlay) {
          return overlay.priority;
        });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function (spec) {
        var this$1 = this;
        var overlays = this.state.overlays;

        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;

          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this$1.state.modeGen++;
            regChange(this$1);
            return;
          }
        }
      }),
      indentLine: methodOp(function (n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }

        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function (how) {
        var this$1 = this;
        var ranges = this.doc.sel.ranges,
            end = -1;

        for (var i = 0; i < ranges.length; i++) {
          var range$$1 = ranges[i];

          if (!range$$1.empty()) {
            var from = range$$1.from(),
                to = range$$1.to();
            var start = Math.max(end, from.line);
            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;

            for (var j = start; j < end; ++j) {
              indentLine(this$1, j, how);
            }

            var newRanges = this$1.doc.sel.ranges;

            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
              replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
            }
          } else if (range$$1.head.line > end) {
            indentLine(this$1, range$$1.head.line, how, true);
            end = range$$1.head.line;

            if (i == this$1.doc.sel.primIndex) {
              ensureCursorVisible(this$1);
            }
          }
        }
      }),
      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function getTokenAt(pos, precise) {
        return takeToken(this, pos, precise);
      },
      getLineTokens: function getLineTokens(line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },
      getTokenTypeAt: function getTokenTypeAt(pos) {
        pos = _clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0,
            after = (styles.length - 1) / 2,
            ch = pos.ch;
        var type;

        if (ch == 0) {
          type = styles[2];
        } else {
          for (;;) {
            var mid = before + after >> 1;

            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type = styles[mid * 2 + 2];
              break;
            }
          }
        }

        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
      },
      getModeAt: function getModeAt(pos) {
        var mode = this.doc.mode;

        if (!mode.innerMode) {
          return mode;
        }

        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
      },
      getHelper: function getHelper(pos, type) {
        return this.getHelpers(pos, type)[0];
      },
      getHelpers: function getHelpers(pos, type) {
        var this$1 = this;
        var found = [];

        if (!helpers.hasOwnProperty(type)) {
          return found;
        }

        var help = helpers[type],
            mode = this.getModeAt(pos);

        if (typeof mode[type] == "string") {
          if (help[mode[type]]) {
            found.push(help[mode[type]]);
          }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];

            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }

        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];

          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }

        return found;
      },
      getStateAfter: function getStateAfter(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },
      cursorCoords: function cursorCoords(start, mode) {
        var pos,
            range$$1 = this.doc.sel.primary();

        if (start == null) {
          pos = range$$1.head;
        } else if (_typeof(start) == "object") {
          pos = _clipPos(this.doc, start);
        } else {
          pos = start ? range$$1.from() : range$$1.to();
        }

        return _cursorCoords(this, pos, mode || "page");
      },
      charCoords: function charCoords(pos, mode) {
        return _charCoords(this, _clipPos(this.doc, pos), mode || "page");
      },
      coordsChar: function coordsChar(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return _coordsChar(this, coords.left, coords.top);
      },
      lineAtHeight: function lineAtHeight(height, mode) {
        height = fromCoordSystem(this, {
          top: height,
          left: 0
        }, mode || "page").top;
        return _lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function heightAtLine(line, mode, includeWidgets) {
        var end = false,
            lineObj;

        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;

          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;
            end = true;
          }

          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }

        return intoCoordSystem(this, lineObj, {
          top: 0,
          left: 0
        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);
      },
      defaultTextHeight: function defaultTextHeight() {
        return textHeight(this.display);
      },
      defaultCharWidth: function defaultCharWidth() {
        return charWidth(this.display);
      },
      getViewport: function getViewport() {
        return {
          from: this.display.viewFrom,
          to: this.display.viewTo
        };
      },
      addWidget: function addWidget(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = _cursorCoords(this, _clipPos(this.doc, pos));
        var top = pos.bottom,
            left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);

        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below

          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }

          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }

        node.style.top = top + "px";
        node.style.left = node.style.right = "";

        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }

          node.style.left = left + "px";
        }

        if (scroll) {
          scrollIntoView(this, {
            left: left,
            top: top,
            right: left + node.offsetWidth,
            bottom: top + node.offsetHeight
          });
        }
      },
      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),
      execCommand: function execCommand(cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },
      triggerElectric: methodOp(function (text) {
        triggerElectric(this, text);
      }),
      findPosH: function findPosH(from, amount, unit, visually) {
        var this$1 = this;
        var dir = 1;

        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }

        var cur = _clipPos(this.doc, from);

        for (var i = 0; i < amount; ++i) {
          cur = _findPosH(this$1.doc, cur, dir, unit, visually);

          if (cur.hitSide) {
            break;
          }
        }

        return cur;
      },
      moveH: methodOp(function (dir, unit) {
        var this$1 = this;
        this.extendSelectionsBy(function (range$$1) {
          if (this$1.display.shift || this$1.doc.extend || range$$1.empty()) {
            return _findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }
        }, sel_move);
      }),
      deleteH: methodOp(function (dir, unit) {
        var sel = this.doc.sel,
            doc = this.doc;

        if (sel.somethingSelected()) {
          doc.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function (range$$1) {
            var other = _findPosH(doc, range$$1.head, dir, unit, false);

            return dir < 0 ? {
              from: other,
              to: range$$1.head
            } : {
              from: range$$1.head,
              to: other
            };
          });
        }
      }),
      findPosV: function findPosV(from, amount, unit, goalColumn) {
        var this$1 = this;
        var dir = 1,
            x = goalColumn;

        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }

        var cur = _clipPos(this.doc, from);

        for (var i = 0; i < amount; ++i) {
          var coords = _cursorCoords(this$1, cur, "div");

          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }

          cur = _findPosV(this$1, coords, dir, unit);

          if (cur.hitSide) {
            break;
          }
        }

        return cur;
      },
      moveV: methodOp(function (dir, unit) {
        var this$1 = this;
        var doc = this.doc,
            goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range$$1) {
          if (collapse) {
            return dir < 0 ? range$$1.from() : range$$1.to();
          }

          var headPos = _cursorCoords(this$1, range$$1.head, "div");

          if (range$$1.goalColumn != null) {
            headPos.left = range$$1.goalColumn;
          }

          goals.push(headPos.left);

          var pos = _findPosV(this$1, headPos, dir, unit);

          if (unit == "page" && range$$1 == doc.sel.primary()) {
            addToScrollTop(this$1, _charCoords(this$1, pos, "div").top - headPos.top);
          }

          return pos;
        }, sel_move);

        if (goals.length) {
          for (var i = 0; i < doc.sel.ranges.length; i++) {
            doc.sel.ranges[i].goalColumn = goals[i];
          }
        }
      }),
      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function findWordAt(pos) {
        var doc = this.doc,
            line = getLine(doc, pos.line).text;
        var start = pos.ch,
            end = pos.ch;

        if (line) {
          var helper = this.getHelper(pos, "wordChars");

          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }

          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function (ch) {
            return isWordChar(ch, helper);
          } : /\s/.test(startChar) ? function (ch) {
            return /\s/.test(ch);
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };

          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }

          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }

        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },
      toggleOverwrite: function toggleOverwrite(value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }

        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function hasFocus() {
        return this.display.input.getField() == activeElt();
      },
      isReadOnly: function isReadOnly() {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },
      scrollTo: methodOp(function (x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function getScrollInfo() {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft,
          top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this),
          clientWidth: displayWidth(this)
        };
      },
      scrollIntoView: methodOp(function (range$$1, margin) {
        if (range$$1 == null) {
          range$$1 = {
            from: this.doc.sel.primary().head,
            to: null
          };

          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range$$1 == "number") {
          range$$1 = {
            from: Pos(range$$1, 0),
            to: null
          };
        } else if (range$$1.from == null) {
          range$$1 = {
            from: range$$1,
            to: null
          };
        }

        if (!range$$1.to) {
          range$$1.to = range$$1.from;
        }

        range$$1.margin = margin || 0;

        if (range$$1.from.line != null) {
          scrollToRange(this, range$$1);
        } else {
          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
        }
      }),
      setSize: methodOp(function (width, height) {
        var this$1 = this;

        var interpret = function interpret(val) {
          return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
        };

        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }

        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }

        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }

        var lineNo$$1 = this.display.viewFrom;
        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].noHScroll) {
                regLineChange(this$1, lineNo$$1, "widget");
                break;
              }
            }
          }

          ++lineNo$$1;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),
      operation: function operation(f) {
        return runInOp(this, f);
      },
      startOperation: function startOperation() {
        return _startOperation(this);
      },
      endOperation: function endOperation() {
        return _endOperation(this);
      },
      refresh: methodOp(function () {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this);

        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
          estimateLineHeights(this);
        }

        signal(this, "refresh", this);
      }),
      swapDoc: methodOp(function (doc) {
        var old = this.doc;
        old.cm = null;
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),
      phrase: function phrase(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
      },
      getInputField: function getInputField() {
        return this.display.input.getField();
      },
      getWrapperElement: function getWrapperElement() {
        return this.display.wrapper;
      },
      getScrollerElement: function getScrollerElement() {
        return this.display.scroller;
      },
      getGutterElement: function getGutterElement() {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function (type, name, value) {
      if (!helpers.hasOwnProperty(type)) {
        helpers[type] = CodeMirror[type] = {
          _global: []
        };
      }

      helpers[type][name] = value;
    };

    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);

      helpers[type]._global.push({
        pred: predicate,
        val: value
      });
    };
  }; // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.


  function _findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);

    function findNextLine() {
      var l = pos.line + dir;

      if (l < doc.first || l >= doc.first + doc.size) {
        return false;
      }

      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l);
    }

    function moveOnce(boundToLine) {
      var next;

      if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }

      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }

      return true;
    }

    if (unit == "char") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null,
          group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");

      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }

        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";

        if (group && !first && !type) {
          type = "s";
        }

        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
            pos.sticky = "after";
          }

          break;
        }

        if (type) {
          sawType = type;
        }

        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }

    var result = skipAtomic(doc, pos, oldPos, origDir, true);

    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }

    return result;
  } // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.


  function _findPosV(cm, pos, dir, unit) {
    var doc = cm.doc,
        x = pos.left,
        y;

    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }

    var target;

    for (;;) {
      target = _coordsChar(cm, x, y);

      if (!target.outside) {
        break;
      }

      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }

      y += dir * 5;
    }

    return target;
  } // CONTENTEDITABLE INPUT STYLE


  var ContentEditableInput = function ContentEditableInput(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
        cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck);
    on(div, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      } // IE doesn't fire input events, so we schedule a read for the pasted content in this way


      if (ie_version <= 11) {
        setTimeout(operation(cm, function () {
          return this$1.updateFromDOM();
        }), 20);
      }
    });
    on(div, "compositionstart", function (e) {
      this$1.composing = {
        data: e.data,
        done: false
      };
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) {
        this$1.composing = {
          data: e.data,
          done: false
        };
      }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) {
          this$1.readFromDOMSoon();
        }

        this$1.composing.done = true;
      }
    });
    on(div, "touchstart", function () {
      return input.forceCompositionEnd();
    });
    on(div, "input", function () {
      if (!this$1.composing) {
        this$1.readFromDOMSoon();
      }
    });

    function onCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }

      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });

        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });

        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }

      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n"); // iOS exposes the clipboard API, but seems to discard content inserted into it

        e.clipboardData.setData("Text", content);

        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      } // Old-fashioned briefly-focus-a-textarea hack


      var kludge = hiddenTextarea(),
          te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();

        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }

    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = this.cm.state.focused;
    return result;
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }

    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }

    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(),
        cm = this.cm,
        prim = cm.doc.sel.primary();
    var from = prim.from(),
        to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);

    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }

    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
      node: view[0].measure.map[2],
      offset: 0
    };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);

    if (!end) {
      var measure = view[view.length - 1].measure;
      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {
        node: map$$1[map$$1.length - 1],
        offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]
      };
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }

    var old = sel.rangeCount && sel.getRangeAt(0),
        rng;

    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible


    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);

        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }

      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }

    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;

      if (this$1.selectionChanged()) {
        this$1.cm.operation(function () {
          return this$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();

    if (!sel.rangeCount) {
      return false;
    }

    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node);
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor()) {
        this.showSelection(this.prepareSelection(), true);
      }

      this.div.focus();
    }
  };

  ContentEditableInput.prototype.blur = function () {
    this.div.blur();
  };

  ContentEditableInput.prototype.getField = function () {
    return this.div;
  };

  ContentEditableInput.prototype.supportsTouch = function () {
    return true;
  };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;

    if (this.selectionInEditor()) {
      this.pollSelection();
    } else {
      runInOp(this.cm, function () {
        return input.cm.curOp.selectionChanged = true;
      });
    }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }

    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }

    var sel = this.getSelection(),
        cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.

    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({
        type: "keydown",
        keyCode: 8,
        preventDefault: Math.abs
      });
      this.blur();
      this.focus();
      return;
    }

    if (this.composing) {
      return;
    }

    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);

    if (anchor && head) {
      runInOp(cm, function () {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);

        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm,
        display = cm.display,
        sel = cm.doc.sel.primary();
    var from = sel.from(),
        to = sel.to();

    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }

    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }

    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }

    var fromIndex, fromLine, fromNode;

    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }

    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;

    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) {
      return false;
    }

    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));

    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else {
        break;
      }
    }

    var cutFront = 0,
        cutEnd = 0;
    var newTop = newText[0],
        oldTop = oldText[0],
        maxCutFront = Math.min(newTop.length, oldTop.length);

    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }

    var newBot = lst(newText),
        oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));

    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    } // Try to move start of change to start of selection if ambiguous


    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);

    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      _replaceRange(cm.doc, newText, chFrom, chTo, "+input");

      return true;
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };

  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };

  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) {
      return;
    }

    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };

  ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

    if (this.readDOMTimeout != null) {
      return;
    }

    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;

      if (this$1.composing) {
        if (this$1.composing.done) {
          this$1.composing = null;
        } else {
          return;
        }
      }

      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function () {
        return regChange(this$1.cm);
      });
    }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) {
      return;
    }

    e.preventDefault();

    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};

  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);

    if (!view || view.hidden) {
      return null;
    }

    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);
    var order = getOrder(line, cm.doc.direction),
        side = "left";

    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }

    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }

    return false;
  }

  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }

    return pos;
  }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "",
        closing = false,
        lineSep = cm.doc.lineSeparator(),
        extraLinebreak = false;

    function recognizeMarker(id) {
      return function (marker) {
        return marker.id == id;
      };
    }

    function close() {
      if (closing) {
        text += lineSep;

        if (extraLinebreak) {
          text += lineSep;
        }

        closing = extraLinebreak = false;
      }
    }

    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }

    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");

        if (cmText) {
          addText(cmText);
          return;
        }

        var markerID = node.getAttribute("cm-marker"),
            range$$1;

        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));

          if (found.length && (range$$1 = found[0].find(0))) {
            addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep));
          }

          return;
        }

        if (node.getAttribute("contenteditable") == "false") {
          return;
        }

        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);

        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
          return;
        }

        if (isBlock) {
          close();
        }

        for (var i = 0; i < node.childNodes.length; i++) {
          walk(node.childNodes[i]);
        }

        if (/^(pre|p)$/i.test(node.nodeName)) {
          extraLinebreak = true;
        }

        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }

    for (;;) {
      walk(from);

      if (from == to) {
        break;
      }

      from = from.nextSibling;
      extraLinebreak = false;
    }

    return text;
  }

  function domToPos(cm, node, offset) {
    var lineNode;

    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];

      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }

      node = null;
      offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }

        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }

    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];

      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild,
        bad = false;

    if (!node || !contains(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }

    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;

      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }

    var textNode = node.nodeType == 3 ? node : null,
        topNode = node;

    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;

      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }

    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }

    var measure = lineView.measure,
        maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map$$1 = i < 0 ? measure.map : maps[i];

        for (var j = 0; j < map$$1.length; j += 3) {
          var curNode = map$$1[j + 2];

          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map$$1[j] + offset;

            if (offset < 0 || curNode != textNode) {
              ch = map$$1[j + (offset ? 1 : 0)];
            }

            return Pos(line, ch);
          }
        }
      }
    }

    var found = find(textNode, topNode, offset);

    if (found) {
      return badPos(found, bad);
    } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems


    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);

      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }

    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);

      if (found) {
        return badPos(Pos(found.line, found.ch + dist$1), bad);
      } else {
        dist$1 += before.textContent.length;
      }
    }
  } // TEXTAREA INPUT STYLE


  var TextareaInput = function TextareaInput(cm) {
    this.cm = cm; // See input.poll and input.reset

    this.prevInput = ""; // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.

    this.pollingFast = false; // Self-resetting timeout for the poller

    this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea

    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
    var this$1 = this;
    var input = this,
        cm = this.cm;
    this.createField(display);
    var te = this.textarea;
    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)

    if (ios) {
      te.style.width = "0px";
    }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) {
        this$1.hasSelection = null;
      }

      input.poll();
    });
    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }

      cm.state.pasteIncoming = true;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }

      if (cm.somethingSelected()) {
        setLastCopied({
          lineWise: false,
          text: cm.getSelections()
        });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({
          lineWise: true,
          text: ranges.text
        });

        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }

      if (e.type == "cut") {
        cm.state.cutIncoming = true;
      }
    }

    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);
    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }

      cm.state.pasteIncoming = true;
      input.focus();
    }); // Prevent normal selection in the editor (we handle our own)

    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });
    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");

      if (input.composing) {
        input.composing.range.clear();
      }

      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        })
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is
    // focused, and receives input.

    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm,
        display = cm.display,
        doc = cm.doc;
    var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts

    if (cm.options.moveInputWithCursor) {
      var headPos = _cursorCoords(cm, doc.sel.primary().head, "div");

      var wrapOff = display.wrapper.getBoundingClientRect(),
          lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
    }

    return result;
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm,
        display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);

    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  }; // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)


  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) {
      return;
    }

    var cm = this.cm;

    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;

      if (cm.state.focused) {
        selectInput(this.textarea);
      }

      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";

      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
  };

  TextareaInput.prototype.getField = function () {
    return this.textarea;
  };

  TextareaInput.prototype.supportsTouch = function () {
    return false;
  };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM

    }
  };

  TextareaInput.prototype.blur = function () {
    this.textarea.blur();
  };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () {
    this.slowPoll();
  }; // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.


  TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

    if (this.pollingFast) {
      return;
    }

    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();

      if (this$1.cm.state.focused) {
        this$1.slowPoll();
      }
    });
  }; // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.


  TextareaInput.prototype.fastPoll = function () {
    var missed = false,
        input = this;
    input.pollingFast = true;

    function p() {
      var changed = input.poll();

      if (!changed && !missed) {
        missed = true;
        input.polling.set(60, p);
      } else {
        input.pollingFast = false;
        input.slowPoll();
      }
    }

    input.polling.set(20, p);
  }; // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).


  TextareaInput.prototype.poll = function () {
    var this$1 = this;
    var cm = this.cm,
        input = this.textarea,
        prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.

    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }

    var text = input.value; // If nothing changed, bail.

    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    } // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).


    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);

      if (first == 0x200b && !prevInput) {
        prevInput = "\u200B";
      }

      if (first == 0x21da) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    } // Find the part of the input that is actually new


    var same = 0,
        l = Math.min(prevInput.length, text.length);

    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null); // Don't leave long text in the textarea, since it makes further polling slow

      if (text.length > 1000 || text.indexOf("\n") > -1) {
        input.value = this$1.prevInput = "";
      } else {
        this$1.prevInput = text;
      }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
          className: "CodeMirror-composing"
        });
      }
    });
    return true;
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }

    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this,
        cm = input.cm,
        display = cm.display,
        te = input.textarea;
    var pos = posFromMouse(cm, e),
        scrollPos = display.scroller.scrollTop;

    if (!pos || presto) {
      return;
    } // Opera is difficult.
    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.


    var reset = cm.options.resetSelectionOnContextMenu;

    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }

    var oldCSS = te.style.cssText,
        oldWrapperCSS = input.wrapper.style.cssText;
    input.wrapper.style.cssText = "position: absolute";
    var wrapperBox = input.wrapper.getBoundingClientRect();
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;

    if (webkit) {
      oldScrollY = window.scrollY;
    } // Work around Chrome issue (#2712)


    display.input.focus();

    if (webkit) {
      window.scrollTo(null, oldScrollY);
    }

    display.input.reset(); // Adds "Select all" to context menu in FF

    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }

    input.contextMenuPending = true;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.

    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200B" + (selected ? te.value : "");
        te.value = "\u21DA"; // Used to catch context-menu undo

        te.value = extval;
        input.prevInput = selected ? "" : "\u200B";
        te.selectionStart = 1;
        te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the
        // selection in the meantime.

        display.selForContextMenu = cm.doc.sel;
      }
    }

    function rehide() {
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;

      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      } // Try to detect the user choosing select-all


      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }

        var i = 0,
            poll = function poll() {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };

        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }

    if (captureRightClick) {
      e_stop(e);

      var mouseup = function mouseup() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };

      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) {
      this.reset();
    }

    this.textarea.disabled = val == "nocursor";
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;

    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }

    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    } // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.


    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {
      textarea.value = cm.getValue();
    }

    var realSubmit;

    if (textarea.form) {
      on(textarea.form, "submit", save); // Deplorable hack to make the submit method do the right thing.

      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;

        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;

      cm.getTextArea = function () {
        return textarea;
      };

      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice

        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";

        if (textarea.form) {
          off(textarea.form, "submit", save);

          if (typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror$1(function (node) {
      return textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  } // EDITOR CONSTRUCTOR


  defineOptions(CodeMirror$1);
  addEditorMethods(CodeMirror$1); // Set up methods on CodeMirror's prototype to redirect to the editor's document.

  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");

  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror$1.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }

  eventMixin(Doc); // INPUT HANDLING

  CodeMirror$1.inputStyles = {
    "textarea": TextareaInput,
    "contenteditable": ContentEditableInput
  }; // MODE DEFINITION AND QUERYING
  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)

  CodeMirror$1.defineMode = function (name
  /*, mode, */
  ) {
    if (!CodeMirror$1.defaults.mode && name != "null") {
      CodeMirror$1.defaults.mode = name;
    }

    defineMode.apply(this, arguments);
  };

  CodeMirror$1.defineMIME = defineMIME; // Minimal default mode.

  CodeMirror$1.defineMode("null", function () {
    return {
      token: function token(stream) {
        return stream.skipToEnd();
      }
    };
  });
  CodeMirror$1.defineMIME("text/plain", "null"); // EXTENSIONS

  CodeMirror$1.defineExtension = function (name, func) {
    CodeMirror$1.prototype[name] = func;
  };

  CodeMirror$1.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror$1.fromTextArea = fromTextArea;
  addLegacyProps(CodeMirror$1);
  CodeMirror$1.version = "5.40.0";
  return CodeMirror$1;
}); // CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE


(function (mod) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) == "object" && _typeof(_module) == "object") // CommonJS
    mod(require("../../lib/codemirror"));else if (typeof _define == "function" && _define.amd) // AMD
    _define(["../../lib/codemirror"], mod);else // Plain browser env
    mod(CodeMirror);
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("javascript", function (config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/; // Tokenizer

    var keywords = function () {
      function kw(type) {
        return {
          type: type,
          style: "keyword"
        };
      }

      var A = kw("keyword a"),
          B = kw("keyword b"),
          C = kw("keyword c"),
          D = kw("keyword d");
      var operator = kw("operator"),
          atom = {
        type: "atom",
        style: "atom"
      };
      return {
        "if": kw("if"),
        "while": A,
        "with": A,
        "else": B,
        "do": B,
        "try": B,
        "finally": B,
        "return": D,
        "break": D,
        "continue": D,
        "new": kw("new"),
        "delete": C,
        "void": C,
        "throw": C,
        "debugger": kw("debugger"),
        "var": kw("var"),
        "const": kw("var"),
        "let": kw("var"),
        "function": kw("function"),
        "catch": kw("catch"),
        "for": kw("for"),
        "switch": kw("switch"),
        "case": kw("case"),
        "default": kw("default"),
        "in": operator,
        "typeof": operator,
        "instanceof": operator,
        "true": atom,
        "false": atom,
        "null": atom,
        "undefined": atom,
        "NaN": atom,
        "Infinity": atom,
        "this": kw("this"),
        "class": kw("class"),
        "super": kw("atom"),
        "yield": C,
        "export": kw("export"),
        "import": kw("import"),
        "extends": C,
        "await": C
      };
    }();

    var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

    function readRegexp(stream) {
      var escaped = false,
          next,
          inSet = false;

      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;else if (inSet && next == "]") inSet = false;
        }

        escaped = !escaped && next == "\\";
      }
    } // Used as scratch variables to communicate multiple values without
    // consing up tons of objects.


    var type, content;

    function ret(tp, style, cont) {
      type = tp;
      content = cont;
      return style;
    }

    function tokenBase(stream, state) {
      var ch = stream.next();

      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\da-f]+|o[0-7]+|b[01]+)n?/i)) {
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^\d*(?:n|(?:\.\d*)?(?:[eE][+\-]?\d+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#") {
        stream.skipToEnd();
        return ret("error", "error");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=") stream.eat("=");
          } else if (/[<>*+\-]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">") stream.eat(ch);
          }
        }

        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();

        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word];
            return ret(kw.type, kw.style, word);
          }

          if (word == "async" && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, false)) return ret("async", "keyword", word);
        }

        return ret("variable", "variable", word);
      }
    }

    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
            next;

        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }

        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\";
        }

        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }

    function tokenComment(stream, state) {
      var maybeEnd = false,
          ch;

      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }

        maybeEnd = ch == "*";
      }

      return ret("comment", "comment");
    }

    function tokenQuasi(stream, state) {
      var escaped = false,
          next;

      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }

        escaped = !escaped && next == "\\";
      }

      return ret("quasi", "string-2", stream.current());
    }

    var brackets = "([{}])"; // This is a crude lookahead trick to try and notice that we're
    // parsing the argument patterns for a fat-arrow function before we
    // actually hit the arrow token. It only works if the arrow is on
    // the same line as the arguments and there's no strange noise
    // (comments) in between. Fallback is to only notice when we hit the
    // arrow, and not declare the arguments as locals for the arrow
    // body.

    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;

      if (isTS) {
        // Try to skip TypeScript return type declarations after the arguments
        var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
        if (m) arrow = m.index;
      }

      var depth = 0,
          sawSomething = false;

      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);

        if (bracket >= 0 && bracket < 3) {
          if (!depth) {
            ++pos;
            break;
          }

          if (--depth == 0) {
            if (ch == "(") sawSomething = true;
            break;
          }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\/]/.test(ch)) {
          return;
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }

      if (sawSomething && !depth) state.fatArrowAt = pos;
    } // Parser


    var atomicTypes = {
      "atom": true,
      "number": true,
      "variable": true,
      "string": true,
      "regexp": true,
      "this": true,
      "jsonld-keyword": true
    };

    function JSLexical(indented, column, type, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }

    function inScope(state, varname) {
      for (var v = state.localVars; v; v = v.next) {
        if (v.name == varname) return true;
      }

      for (var cx = state.context; cx; cx = cx.prev) {
        for (var v = cx.vars; v; v = v.next) {
          if (v.name == varname) return true;
        }
      }
    }

    function parseJS(state, style, type, content, stream) {
      var cc = state.cc; // Communicate our context to the combinators.
      // (Less wasteful than consing up a hundred closures on every call.)

      cx.state = state;
      cx.stream = stream;
      cx.marked = null, cx.cc = cc;
      cx.style = style;
      if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;

        if (combinator(type, content)) {
          while (cc.length && cc[cc.length - 1].lex) {
            cc.pop()();
          }

          if (cx.marked) return cx.marked;
          if (type == "variable" && inScope(state, content)) return "variable-2";
          return style;
        }
      }
    } // Combinator utils


    var cx = {
      state: null,
      column: null,
      marked: null,
      cc: null
    };

    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) {
        cx.cc.push(arguments[i]);
      }
    }

    function cont() {
      pass.apply(null, arguments);
      return true;
    }

    function inList(name, list) {
      for (var v = list; v; v = v.next) {
        if (v.name == name) return true;
      }

      return false;
    }

    function register(varname) {
      var state = cx.state;
      cx.marked = "def";

      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          // FIXME function decls are also not block scoped
          var newContext = registerVarScoped(varname, state.context);

          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      } // Fall through means this is global


      if (parserConfig.globalVars && !inList(varname, state.globalVars)) state.globalVars = new Var(varname, state.globalVars);
    }

    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner) return null;
        if (inner == context.prev) return context;
        return new Context(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false);
      }
    }

    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
    } // Combinators


    function Context(prev, vars, block) {
      this.prev = prev;
      this.vars = vars;
      this.block = block;
    }

    function Var(name, next) {
      this.name = name;
      this.next = next;
    }

    var defaultVars = new Var("this", new Var("arguments", null));

    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }

    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }

    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }

    popcontext.lex = true;

    function pushlex(type, info) {
      var result = function result() {
        var state = cx.state,
            indent = state.indented;
        if (state.lexical.type == "stat") indent = state.lexical.indented;else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev) {
          indent = outer.indented;
        }
        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
      };

      result.lex = true;
      return result;
    }

    function poplex() {
      var state = cx.state;

      if (state.lexical.prev) {
        if (state.lexical.type == ")") state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }

    poplex.lex = true;

    function expect(wanted) {
      function exp(type) {
        if (type == wanted) return cont();else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();else return cont(exp);
      }

      ;
      return exp;
    }

    function statement(type, value) {
      if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type == "debugger") return cont(expect(";"));
      if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type == ";") return cont();

      if (type == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex) cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }

      if (type == "function") return cont(functiondef);
      if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);

      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), className, poplex);
      }

      if (type == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
          cx.marked = "keyword";
          if (value == "enum") return cont(enumdef);else if (value == "type") return cont(typeexpr, expect("operator"), typeexpr, expect(";"));else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, block, poplex);
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }

      if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
      if (type == "case") return cont(expression, expect(":"));
      if (type == "default") return cont(expect(":"));
      if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
      if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
      if (type == "async") return cont(statement);
      if (value == "@") return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }

    function maybeCatchBinding(type) {
      if (type == "(") return cont(funarg, expect(")"));
    }

    function expression(type, value) {
      return expressionInner(type, value, false);
    }

    function expressionNoComma(type, value) {
      return expressionInner(type, value, true);
    }

    function parenExpr(type) {
      if (type != "(") return pass();
      return cont(pushlex(")"), expression, expect(")"), poplex);
    }

    function expressionInner(type, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }

      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
      if (type == "function") return cont(functiondef, maybeop);

      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), classExpression, poplex);
      }

      if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
      if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type == "quasi") return pass(quasi, maybeop);
      if (type == "new") return cont(maybeTarget(noComma));
      if (type == "import") return cont(expression);
      return cont();
    }

    function maybeexpression(type) {
      if (type.match(/[;\}\)\],]/)) return pass();
      return pass(expression);
    }

    function maybeoperatorComma(type, value) {
      if (type == ",") return cont(expression);
      return maybeoperatorNoComma(type, value, false);
    }

    function maybeoperatorNoComma(type, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);

      if (type == "operator") {
        if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, false)) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }

      if (type == "quasi") {
        return pass(quasi, me);
      }

      if (type == ";") return;
      if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type == ".") return cont(property, me);
      if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);

      if (isTS && value == "as") {
        cx.marked = "keyword";
        return cont(typeexpr, me);
      }

      if (type == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
        return cont(expr);
      }
    }

    function quasi(type, value) {
      if (type != "quasi") return pass();
      if (value.slice(value.length - 2) != "${") return cont(quasi);
      return cont(expression, continueQuasi);
    }

    function continueQuasi(type) {
      if (type == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }

    function arrowBody(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expression);
    }

    function arrowBodyNoComma(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expressionNoComma);
    }

    function maybeTarget(noComma) {
      return function (type) {
        if (type == ".") return cont(noComma ? targetNoComma : target);else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);else return pass(noComma ? expressionNoComma : expression);
      };
    }

    function target(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorComma);
      }
    }

    function targetNoComma(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorNoComma);
      }
    }

    function maybelabel(type) {
      if (type == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }

    function property(type) {
      if (type == "variable") {
        cx.marked = "property";
        return cont();
      }
    }

    function objprop(type, value) {
      if (type == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params

        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false))) cx.state.fatArrowAt = cx.stream.pos + m[0].length;
        return cont(afterprop);
      } else if (type == "number" || type == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == ":") {
        return pass(afterprop);
      }
    }

    function getterSetter(type) {
      if (type != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }

    function afterprop(type) {
      if (type == ":") return cont(expressionNoComma);
      if (type == "(") return pass(functiondef);
    }

    function commasep(what, end, sep) {
      function proceed(type, value) {
        if (sep ? sep.indexOf(type) > -1 : type == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(function (type, value) {
            if (type == end || value == end) return pass();
            return pass(what);
          }, proceed);
        }

        if (type == end || value == end) return cont();
        return cont(expect(end));
      }

      return function (type, value) {
        if (type == end || value == end) return cont();
        return pass(what, proceed);
      };
    }

    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++) {
        cx.cc.push(arguments[i]);
      }

      return cont(pushlex(end, info), commasep(what, end), poplex);
    }

    function block(type) {
      if (type == "}") return cont();
      return pass(statement, block);
    }

    function maybetype(type, value) {
      if (isTS) {
        if (type == ":") return cont(typeexpr);
        if (value == "?") return cont(maybetype);
      }
    }

    function mayberettype(type) {
      if (isTS && type == ":") {
        if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr);else return cont(typeexpr);
      }
    }

    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }

    function typeexpr(type, value) {
      if (value == "keyof" || value == "typeof") {
        cx.marked = "keyword";
        return cont(value == "keyof" ? typeexpr : expressionNoComma);
      }

      if (type == "variable" || value == "void") {
        cx.marked = "type";
        return cont(afterType);
      }

      if (type == "string" || type == "number" || type == "atom") return cont(afterType);
      if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType);
      if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType);
      if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr);
    }

    function maybeReturnType(type) {
      if (type == "=>") return cont(typeexpr);
    }

    function typeprop(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value == "?") {
        return cont(typeprop);
      } else if (type == ":") {
        return cont(typeexpr);
      } else if (type == "[") {
        return cont(expression, maybetype, expect("]"), typeprop);
      }
    }

    function typearg(type, value) {
      if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg);
      if (type == ":") return cont(typeexpr);
      return pass(typeexpr);
    }

    function afterType(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value == "|" || type == "." || value == "&") return cont(typeexpr);
      if (type == "[") return cont(expect("]"), afterType);

      if (value == "extends" || value == "implements") {
        cx.marked = "keyword";
        return cont(typeexpr);
      }
    }

    function maybeTypeArgs(_, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }

    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }

    function maybeTypeDefault(_, value) {
      if (value == "=") return cont(typeexpr);
    }

    function vardef(_, value) {
      if (value == "enum") {
        cx.marked = "keyword";
        return cont(enumdef);
      }

      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }

    function pattern(type, value) {
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(pattern);
      }

      if (type == "variable") {
        register(value);
        return cont();
      }

      if (type == "spread") return cont(pattern);
      if (type == "[") return contCommasep(pattern, "]");
      if (type == "{") return contCommasep(proppattern, "}");
    }

    function proppattern(type, value) {
      if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }

      if (type == "variable") cx.marked = "property";
      if (type == "spread") return cont(pattern);
      if (type == "}") return pass();
      return cont(expect(":"), pattern, maybeAssign);
    }

    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }

    function vardefCont(type) {
      if (type == ",") return cont(vardef);
    }

    function maybeelse(type, value) {
      if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }

    function forspec(type, value) {
      if (value == "await") return cont(forspec);
      if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
    }

    function forspec1(type) {
      if (type == "var") return cont(vardef, expect(";"), forspec2);
      if (type == ";") return cont(forspec2);
      if (type == "variable") return cont(formaybeinof);
      return pass(expression, expect(";"), forspec2);
    }

    function formaybeinof(_type, value) {
      if (value == "in" || value == "of") {
        cx.marked = "keyword";
        return cont(expression);
      }

      return cont(maybeoperatorComma, forspec2);
    }

    function forspec2(type, value) {
      if (type == ";") return cont(forspec3);

      if (value == "in" || value == "of") {
        cx.marked = "keyword";
        return cont(expression);
      }

      return pass(expression, expect(";"), forspec3);
    }

    function forspec3(type) {
      if (type != ")") cont(expression);
    }

    function functiondef(type, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondef);
      }

      if (type == "variable") {
        register(value);
        return cont(functiondef);
      }

      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }

    function funarg(type, value) {
      if (value == "@") cont(expression, funarg);
      if (type == "spread") return cont(funarg);

      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(funarg);
      }

      return pass(pattern, maybetype, maybeAssign);
    }

    function classExpression(type, value) {
      // Class expressions may have an optional name.
      if (type == "variable") return className(type, value);
      return classNameAfter(type, value);
    }

    function className(type, value) {
      if (type == "variable") {
        register(value);
        return cont(classNameAfter);
      }
    }

    function classNameAfter(type, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);

      if (value == "extends" || value == "implements" || isTS && type == ",") {
        if (value == "implements") cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }

      if (type == "{") return cont(pushlex("}"), classBody, poplex);
    }

    function classBody(type, value) {
      if (type == "async" || type == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }

      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(isTS ? classfield : functiondef, classBody);
      }

      if (type == "[") return cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody);

      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }

      if (type == ";") return cont(classBody);
      if (type == "}") return cont();
      if (value == "@") return cont(expression, classBody);
    }

    function classfield(type, value) {
      if (value == "?") return cont(classfield);
      if (type == ":") return cont(typeexpr, maybeAssign);
      if (value == "=") return cont(expressionNoComma);
      return pass(functiondef);
    }

    function afterExport(type, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(maybeFrom, expect(";"));
      }

      if (value == "default") {
        cx.marked = "keyword";
        return cont(expression, expect(";"));
      }

      if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }

    function exportField(type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(expect("variable"));
      }

      if (type == "variable") return pass(expressionNoComma, exportField);
    }

    function afterImport(type) {
      if (type == "string") return cont();
      if (type == "(") return pass(expression);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }

    function importSpec(type, value) {
      if (type == "{") return contCommasep(importSpec, "}");
      if (type == "variable") register(value);
      if (value == "*") cx.marked = "keyword";
      return cont(maybeAs);
    }

    function maybeMoreImports(type) {
      if (type == ",") return cont(importSpec, maybeMoreImports);
    }

    function maybeAs(_type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(importSpec);
      }
    }

    function maybeFrom(_type, value) {
      if (value == "from") {
        cx.marked = "keyword";
        return cont(expression);
      }
    }

    function arrayLiteral(type) {
      if (type == "]") return cont();
      return pass(commasep(expressionNoComma, "]"));
    }

    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }

    function enummember() {
      return pass(pattern, maybeAssign);
    }

    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
    }

    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
    } // Interface


    return {
      startState: function startState(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && _typeof(parserConfig.globalVars) == "object") state.globalVars = parserConfig.globalVars;
        return state;
      },
      token: function token(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }

        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type == "comment") return style;
        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
        return parseJS(state, style, type, content, stream);
      },
      indent: function indent(state, textAfter) {
        if (state.tokenize == tokenComment) return CodeMirror.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0),
            lexical = state.lexical,
            top; // Kludge to prevent 'maybelse' from blocking lexical scope pops

        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
        }

        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter))) {
          lexical = lexical.prev;
        }

        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
        var type = lexical.type,
            closing = firstChar == type;
        if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
      },
      electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``",
      helperType: jsonMode ? "json" : "javascript",
      jsonldMode: jsonldMode,
      jsonMode: jsonMode,
      expressionAllowed: expressionAllowed,
      skipExpression: function skipExpression(state) {
        var top = state.cc[state.cc.length - 1];
        if (top == expression || top == expressionNoComma) state.cc.pop();
      }
    };
  });
  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
  CodeMirror.defineMIME("text/javascript", "javascript");
  CodeMirror.defineMIME("text/ecmascript", "javascript");
  CodeMirror.defineMIME("application/javascript", "javascript");
  CodeMirror.defineMIME("application/x-javascript", "javascript");
  CodeMirror.defineMIME("application/ecmascript", "javascript");
  CodeMirror.defineMIME("application/json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/x-json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/ld+json", {
    name: "javascript",
    jsonld: true
  });
  CodeMirror.defineMIME("text/typescript", {
    name: "javascript",
    typescript: true
  });
  CodeMirror.defineMIME("application/typescript", {
    name: "javascript",
    typescript: true
  });
});

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CodeMirror;

},{"../../lib/codemirror":undefined}],53:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = {};
var _module = undefined;
var Highcharts;

var _define = function define() {
  var fn = arguments[arguments.length - 1];
  Highcharts = fn();
  _define = undefined;
};

_define.amd = true;
/*
Highcharts JS v6.1.2 (2018-08-31)
(c) 2009-2016 Torstein Honsi
License: www.highcharts.com/license
*/

(function (S, K) {
  "object" === _typeof(_module) && _module.exports ? _module.exports = S.document ? K(S) : K : "function" === typeof _define && _define.amd ? _define(function () {
    return K(S);
  }) : S.Highcharts = K(S);
})("undefined" !== typeof window ? window : void 0, function (S) {
  var K = function () {
    var a = "undefined" === typeof S ? window : S,
        A = a.document,
        C = a.navigator && a.navigator.userAgent || "",
        E = A && A.createElementNS && !!A.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
        m = /(edge|msie|trident)/i.test(C) && !a.opera,
        g = -1 !== C.indexOf("Firefox"),
        e = -1 !== C.indexOf("Chrome"),
        v = g && 4 > parseInt(C.split("Firefox/")[1], 10);
    return a.Highcharts ? a.Highcharts.error(16, !0) : {
      product: "Highcharts",
      version: "6.1.2",
      deg2rad: 2 * Math.PI / 360,
      doc: A,
      hasBidiBug: v,
      hasTouch: A && void 0 !== A.documentElement.ontouchstart,
      isMS: m,
      isWebKit: -1 !== C.indexOf("AppleWebKit"),
      isFirefox: g,
      isChrome: e,
      isSafari: !e && -1 !== C.indexOf("Safari"),
      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(C),
      SVG_NS: "http://www.w3.org/2000/svg",
      chartCount: 0,
      seriesTypes: {},
      symbolSizes: {},
      svg: E,
      win: a,
      marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
      noop: function noop() {},
      charts: []
    };
  }();

  (function (a) {
    a.timers = [];
    var A = a.charts,
        C = a.doc,
        E = a.win;

    a.error = function (m, g) {
      m = a.isNumber(m) ? "Highcharts error #" + m + ": www.highcharts.com/errors/" + m : m;
      if (g) throw Error(m);
      E.console && console.log(m);
    };

    a.Fx = function (a, g, e) {
      this.options = g;
      this.elem = a;
      this.prop = e;
    };

    a.Fx.prototype = {
      dSetter: function dSetter() {
        var a = this.paths[0],
            g = this.paths[1],
            e = [],
            v = this.now,
            u = a.length,
            t;
        if (1 === v) e = this.toD;else if (u === g.length && 1 > v) for (; u--;) {
          t = parseFloat(a[u]), e[u] = isNaN(t) ? g[u] : v * parseFloat(g[u] - t) + t;
        } else e = g;
        this.elem.attr("d", e, null, !0);
      },
      update: function update() {
        var a = this.elem,
            g = this.prop,
            e = this.now,
            v = this.options.step;
        if (this[g + "Setter"]) this[g + "Setter"]();else a.attr ? a.element && a.attr(g, e, null, !0) : a.style[g] = e + this.unit;
        v && v.call(a, e, this);
      },
      run: function run(m, g, e) {
        var v = this,
            u = v.options,
            t = function t(a) {
          return t.stopped ? !1 : v.step(a);
        },
            l = E.requestAnimationFrame || function (a) {
          setTimeout(a, 13);
        },
            d = function d() {
          for (var c = 0; c < a.timers.length; c++) {
            a.timers[c]() || a.timers.splice(c--, 1);
          }

          a.timers.length && l(d);
        };

        m !== g || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = m, this.end = g, this.unit = e, this.now = this.start, this.pos = 0, t.elem = this.elem, t.prop = this.prop, t() && 1 === a.timers.push(t) && l(d)) : (delete u.curAnim[this.prop], u.complete && 0 === a.keys(u.curAnim).length && u.complete.call(this.elem));
      },
      step: function step(m) {
        var g = +new Date(),
            e,
            v = this.options,
            u = this.elem,
            t = v.complete,
            l = v.duration,
            d = v.curAnim;
        u.attr && !u.element ? m = !1 : m || g >= l + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), e = d[this.prop] = !0, a.objectEach(d, function (a) {
          !0 !== a && (e = !1);
        }), e && t && t.call(u), m = !1) : (this.pos = v.easing((g - this.startTime) / l), this.now = this.start + (this.end - this.start) * this.pos, this.update(), m = !0);
        return m;
      },
      initPath: function initPath(m, g, e) {
        function v(a) {
          var b, c;

          for (f = a.length; f--;) {
            b = "M" === a[f] || "L" === a[f], c = /[a-zA-Z]/.test(a[f + 3]), b && c && a.splice(f + 1, 0, a[f + 1], a[f + 2], a[f + 1], a[f + 2]);
          }
        }

        function u(a, b) {
          for (; a.length < n;) {
            a[0] = b[n - a.length];
            var c = a.slice(0, r);
            [].splice.apply(a, [0, 0].concat(c));
            q && (c = a.slice(a.length - r), [].splice.apply(a, [a.length, 0].concat(c)), f--);
          }

          a[0] = "M";
        }

        function t(a, c) {
          for (var f = (n - a.length) / r; 0 < f && f--;) {
            b = a.slice().splice(a.length / G - r, r * G), b[0] = c[n - r - f * r], x && (b[r - 6] = b[r - 2], b[r - 5] = b[r - 1]), [].splice.apply(a, [a.length / G, 0].concat(b)), q && f--;
          }
        }

        g = g || "";
        var l,
            d = m.startX,
            c = m.endX,
            x = -1 < g.indexOf("C"),
            r = x ? 7 : 3,
            n,
            b,
            f;
        g = g.split(" ");
        e = e.slice();
        var q = m.isArea,
            G = q ? 2 : 1,
            J;
        x && (v(g), v(e));

        if (d && c) {
          for (f = 0; f < d.length; f++) {
            if (d[f] === c[0]) {
              l = f;
              break;
            } else if (d[0] === c[c.length - d.length + f]) {
              l = f;
              J = !0;
              break;
            }
          }

          void 0 === l && (g = []);
        }

        g.length && a.isNumber(l) && (n = e.length + l * G * r, J ? (u(g, e), t(e, g)) : (u(e, g), t(g, e)));
        return [g, e];
      },
      fillSetter: function fillSetter() {
        a.Fx.prototype.strokeSetter.apply(this, arguments);
      },
      strokeSetter: function strokeSetter() {
        this.elem.attr(this.prop, a.color(this.start).tweenTo(a.color(this.end), this.pos), null, !0);
      }
    };

    a.merge = function () {
      var m,
          g = arguments,
          e,
          v = {},
          u = function u(e, l) {
        "object" !== _typeof(e) && (e = {});
        a.objectEach(l, function (d, c) {
          !a.isObject(d, !0) || a.isClass(d) || a.isDOMElement(d) ? e[c] = l[c] : e[c] = u(e[c] || {}, d);
        });
        return e;
      };

      !0 === g[0] && (v = g[1], g = Array.prototype.slice.call(g, 2));
      e = g.length;

      for (m = 0; m < e; m++) {
        v = u(v, g[m]);
      }

      return v;
    };

    a.pInt = function (a, g) {
      return parseInt(a, g || 10);
    };

    a.isString = function (a) {
      return "string" === typeof a;
    };

    a.isArray = function (a) {
      a = Object.prototype.toString.call(a);
      return "[object Array]" === a || "[object Array Iterator]" === a;
    };

    a.isObject = function (m, g) {
      return !!m && "object" === _typeof(m) && (!g || !a.isArray(m));
    };

    a.isDOMElement = function (m) {
      return a.isObject(m) && "number" === typeof m.nodeType;
    };

    a.isClass = function (m) {
      var g = m && m.constructor;
      return !(!a.isObject(m, !0) || a.isDOMElement(m) || !g || !g.name || "Object" === g.name);
    };

    a.isNumber = function (a) {
      return "number" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;
    };

    a.erase = function (a, g) {
      for (var e = a.length; e--;) {
        if (a[e] === g) {
          a.splice(e, 1);
          break;
        }
      }
    };

    a.defined = function (a) {
      return void 0 !== a && null !== a;
    };

    a.attr = function (m, g, e) {
      var v;
      a.isString(g) ? a.defined(e) ? m.setAttribute(g, e) : m && m.getAttribute && ((v = m.getAttribute(g)) || "class" !== g || (v = m.getAttribute(g + "Name"))) : a.defined(g) && a.isObject(g) && a.objectEach(g, function (a, e) {
        m.setAttribute(e, a);
      });
      return v;
    };

    a.splat = function (m) {
      return a.isArray(m) ? m : [m];
    };

    a.syncTimeout = function (a, g, e) {
      if (g) return setTimeout(a, g, e);
      a.call(0, e);
    };

    a.clearTimeout = function (m) {
      a.defined(m) && clearTimeout(m);
    };

    a.extend = function (a, g) {
      var e;
      a || (a = {});

      for (e in g) {
        a[e] = g[e];
      }

      return a;
    };

    a.pick = function () {
      var a = arguments,
          g,
          e,
          v = a.length;

      for (g = 0; g < v; g++) {
        if (e = a[g], void 0 !== e && null !== e) return e;
      }
    };

    a.css = function (m, g) {
      a.isMS && !a.svg && g && void 0 !== g.opacity && (g.filter = "alpha(opacity\x3d" + 100 * g.opacity + ")");
      a.extend(m.style, g);
    };

    a.createElement = function (m, g, e, v, u) {
      m = C.createElement(m);
      var t = a.css;
      g && a.extend(m, g);
      u && t(m, {
        padding: 0,
        border: "none",
        margin: 0
      });
      e && t(m, e);
      v && v.appendChild(m);
      return m;
    };

    a.extendClass = function (m, g) {
      var e = function e() {};

      e.prototype = new m();
      a.extend(e.prototype, g);
      return e;
    };

    a.pad = function (a, g, e) {
      return Array((g || 2) + 1 - String(a).replace("-", "").length).join(e || 0) + a;
    };

    a.relativeLength = function (a, g, e) {
      return /%$/.test(a) ? g * parseFloat(a) / 100 + (e || 0) : parseFloat(a);
    };

    a.wrap = function (a, g, e) {
      var m = a[g];

      a[g] = function () {
        var a = Array.prototype.slice.call(arguments),
            g = arguments,
            l = this;

        l.proceed = function () {
          m.apply(l, arguments.length ? arguments : g);
        };

        a.unshift(m);
        a = e.apply(this, a);
        l.proceed = null;
        return a;
      };
    };

    a.formatSingle = function (m, g, e) {
      var v = /\.([0-9])/,
          u = a.defaultOptions.lang;
      /f$/.test(m) ? (e = (e = m.match(v)) ? e[1] : -1, null !== g && (g = a.numberFormat(g, e, u.decimalPoint, -1 < m.indexOf(",") ? u.thousandsSep : ""))) : g = (e || a.time).dateFormat(m, g);
      return g;
    };

    a.format = function (m, g, e) {
      for (var v = "{", u = !1, t, l, d, c, x = [], r; m;) {
        v = m.indexOf(v);
        if (-1 === v) break;
        t = m.slice(0, v);

        if (u) {
          t = t.split(":");
          l = t.shift().split(".");
          c = l.length;
          r = g;

          for (d = 0; d < c; d++) {
            r && (r = r[l[d]]);
          }

          t.length && (r = a.formatSingle(t.join(":"), r, e));
          x.push(r);
        } else x.push(t);

        m = m.slice(v + 1);
        v = (u = !u) ? "}" : "{";
      }

      x.push(m);
      return x.join("");
    };

    a.getMagnitude = function (a) {
      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
    };

    a.normalizeTickInterval = function (m, g, e, v, u) {
      var t,
          l = m;
      e = a.pick(e, 1);
      t = m / e;
      g || (g = u ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === v && (1 === e ? g = a.grep(g, function (a) {
        return 0 === a % 1;
      }) : .1 >= e && (g = [1 / e])));

      for (v = 0; v < g.length && !(l = g[v], u && l * e >= m || !u && t <= (g[v] + (g[v + 1] || g[v])) / 2); v++) {
        ;
      }

      return l = a.correctFloat(l * e, -Math.round(Math.log(.001) / Math.LN10));
    };

    a.stableSort = function (a, g) {
      var e = a.length,
          m,
          u;

      for (u = 0; u < e; u++) {
        a[u].safeI = u;
      }

      a.sort(function (a, e) {
        m = g(a, e);
        return 0 === m ? a.safeI - e.safeI : m;
      });

      for (u = 0; u < e; u++) {
        delete a[u].safeI;
      }
    };

    a.arrayMin = function (a) {
      for (var g = a.length, e = a[0]; g--;) {
        a[g] < e && (e = a[g]);
      }

      return e;
    };

    a.arrayMax = function (a) {
      for (var g = a.length, e = a[0]; g--;) {
        a[g] > e && (e = a[g]);
      }

      return e;
    };

    a.destroyObjectProperties = function (m, g) {
      a.objectEach(m, function (a, v) {
        a && a !== g && a.destroy && a.destroy();
        delete m[v];
      });
    };

    a.discardElement = function (m) {
      var g = a.garbageBin;
      g || (g = a.createElement("div"));
      m && g.appendChild(m);
      g.innerHTML = "";
    };

    a.correctFloat = function (a, g) {
      return parseFloat(a.toPrecision(g || 14));
    };

    a.setAnimation = function (m, g) {
      g.renderer.globalAnimation = a.pick(m, g.options.chart.animation, !0);
    };

    a.animObject = function (m) {
      return a.isObject(m) ? a.merge(m) : {
        duration: m ? 500 : 0
      };
    };

    a.timeUnits = {
      millisecond: 1,
      second: 1E3,
      minute: 6E4,
      hour: 36E5,
      day: 864E5,
      week: 6048E5,
      month: 24192E5,
      year: 314496E5
    };

    a.numberFormat = function (m, g, e, v) {
      m = +m || 0;
      g = +g;
      var u = a.defaultOptions.lang,
          t = (m.toString().split(".")[1] || "").split("e")[0].length,
          l,
          d,
          c = m.toString().split("e");
      -1 === g ? g = Math.min(t, 20) : a.isNumber(g) ? g && c[1] && 0 > c[1] && (l = g + +c[1], 0 <= l ? (c[0] = (+c[0]).toExponential(l).split("e")[0], g = l) : (c[0] = c[0].split(".")[0] || 0, m = 20 > g ? (c[0] * Math.pow(10, c[1])).toFixed(g) : 0, c[1] = 0)) : g = 2;
      d = (Math.abs(c[1] ? c[0] : m) + Math.pow(10, -Math.max(g, t) - 1)).toFixed(g);
      t = String(a.pInt(d));
      l = 3 < t.length ? t.length % 3 : 0;
      e = a.pick(e, u.decimalPoint);
      v = a.pick(v, u.thousandsSep);
      m = (0 > m ? "-" : "") + (l ? t.substr(0, l) + v : "");
      m += t.substr(l).replace(/(\d{3})(?=\d)/g, "$1" + v);
      g && (m += e + d.slice(-g));
      c[1] && 0 !== +m && (m += "e" + c[1]);
      return m;
    };

    Math.easeInOutSine = function (a) {
      return -.5 * (Math.cos(Math.PI * a) - 1);
    };

    a.getStyle = function (m, g, e) {
      if ("width" === g) return Math.max(0, Math.min(m.offsetWidth, m.scrollWidth) - a.getStyle(m, "padding-left") - a.getStyle(m, "padding-right"));
      if ("height" === g) return Math.max(0, Math.min(m.offsetHeight, m.scrollHeight) - a.getStyle(m, "padding-top") - a.getStyle(m, "padding-bottom"));
      E.getComputedStyle || a.error(27, !0);
      if (m = E.getComputedStyle(m, void 0)) m = m.getPropertyValue(g), a.pick(e, "opacity" !== g) && (m = a.pInt(m));
      return m;
    };

    a.inArray = function (m, g, e) {
      return (a.indexOfPolyfill || Array.prototype.indexOf).call(g, m, e);
    };

    a.grep = function (m, g) {
      return (a.filterPolyfill || Array.prototype.filter).call(m, g);
    };

    a.find = Array.prototype.find ? function (a, g) {
      return a.find(g);
    } : function (a, g) {
      var e,
          v = a.length;

      for (e = 0; e < v; e++) {
        if (g(a[e], e)) return a[e];
      }
    };

    a.some = function (m, g, e) {
      return (a.somePolyfill || Array.prototype.some).call(m, g, e);
    };

    a.map = function (a, g) {
      for (var e = [], v = 0, u = a.length; v < u; v++) {
        e[v] = g.call(a[v], a[v], v, a);
      }

      return e;
    };

    a.keys = function (m) {
      return (a.keysPolyfill || Object.keys).call(void 0, m);
    };

    a.reduce = function (m, g, e) {
      return (a.reducePolyfill || Array.prototype.reduce).apply(m, 2 < arguments.length ? [g, e] : [g]);
    };

    a.offset = function (a) {
      var g = C.documentElement;
      a = a.parentElement || a.parentNode ? a.getBoundingClientRect() : {
        top: 0,
        left: 0
      };
      return {
        top: a.top + (E.pageYOffset || g.scrollTop) - (g.clientTop || 0),
        left: a.left + (E.pageXOffset || g.scrollLeft) - (g.clientLeft || 0)
      };
    };

    a.stop = function (m, g) {
      for (var e = a.timers.length; e--;) {
        a.timers[e].elem !== m || g && g !== a.timers[e].prop || (a.timers[e].stopped = !0);
      }
    };

    a.each = function (m, g, e) {
      return (a.forEachPolyfill || Array.prototype.forEach).call(m, g, e);
    };

    a.objectEach = function (a, g, e) {
      for (var v in a) {
        a.hasOwnProperty(v) && g.call(e || a[v], a[v], v, a);
      }
    };

    a.addEvent = function (m, g, e, v) {
      var u,
          t = m.addEventListener || a.addEventListenerPolyfill;
      u = "function" === typeof m && m.prototype ? m.prototype.protoEvents = m.prototype.protoEvents || {} : m.hcEvents = m.hcEvents || {};
      a.Point && m instanceof a.Point && m.series && m.series.chart && (m.series.chart.runTrackerClick = !0);
      t && t.call(m, g, e, !1);
      u[g] || (u[g] = []);
      u[g].push(e);
      v && a.isNumber(v.order) && (e.order = v.order, u[g].sort(function (a, d) {
        return a.order - d.order;
      }));
      return function () {
        a.removeEvent(m, g, e);
      };
    };

    a.removeEvent = function (m, g, e) {
      function v(d, c) {
        var e = m.removeEventListener || a.removeEventListenerPolyfill;
        e && e.call(m, d, c, !1);
      }

      function u(d) {
        var c, e;
        m.nodeName && (g ? (c = {}, c[g] = !0) : c = d, a.objectEach(c, function (a, c) {
          if (d[c]) for (e = d[c].length; e--;) {
            v(c, d[c][e]);
          }
        }));
      }

      var t, l;
      a.each(["protoEvents", "hcEvents"], function (d) {
        var c = m[d];
        c && (g ? (t = c[g] || [], e ? (l = a.inArray(e, t), -1 < l && (t.splice(l, 1), c[g] = t), v(g, e)) : (u(c), c[g] = [])) : (u(c), m[d] = {}));
      });
    };

    a.fireEvent = function (m, g, e, v) {
      var u, t, l, d, c;
      e = e || {};
      C.createEvent && (m.dispatchEvent || m.fireEvent) ? (u = C.createEvent("Events"), u.initEvent(g, !0, !0), a.extend(u, e), m.dispatchEvent ? m.dispatchEvent(u) : m.fireEvent(g, u)) : a.each(["protoEvents", "hcEvents"], function (x) {
        if (m[x]) for (t = m[x][g] || [], l = t.length, e.target || a.extend(e, {
          preventDefault: function preventDefault() {
            e.defaultPrevented = !0;
          },
          target: m,
          type: g
        }), d = 0; d < l; d++) {
          (c = t[d]) && !1 === c.call(m, e) && e.preventDefault();
        }
      });
      v && !e.defaultPrevented && v.call(m, e);
    };

    a.animate = function (m, g, e) {
      var v,
          u = "",
          t,
          l,
          d;
      a.isObject(e) || (d = arguments, e = {
        duration: d[2],
        easing: d[3],
        complete: d[4]
      });
      a.isNumber(e.duration) || (e.duration = 400);
      e.easing = "function" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;
      e.curAnim = a.merge(g);
      a.objectEach(g, function (c, d) {
        a.stop(m, d);
        l = new a.Fx(m, e, d);
        t = null;
        "d" === d ? (l.paths = l.initPath(m, m.d, g.d), l.toD = g.d, v = 0, t = 1) : m.attr ? v = m.attr(d) : (v = parseFloat(a.getStyle(m, d)) || 0, "opacity" !== d && (u = "px"));
        t || (t = c);
        t && t.match && t.match("px") && (t = t.replace(/px/g, ""));
        l.run(v, t, u);
      });
    };

    a.seriesType = function (m, g, e, v, u) {
      var t = a.getOptions(),
          l = a.seriesTypes;
      t.plotOptions[m] = a.merge(t.plotOptions[g], e);
      l[m] = a.extendClass(l[g] || function () {}, v);
      l[m].prototype.type = m;
      u && (l[m].prototype.pointClass = a.extendClass(a.Point, u));
      return l[m];
    };

    a.uniqueKey = function () {
      var a = Math.random().toString(36).substring(2, 9),
          g = 0;
      return function () {
        return "highcharts-" + a + "-" + g++;
      };
    }();

    E.jQuery && (E.jQuery.fn.highcharts = function () {
      var m = [].slice.call(arguments);
      if (this[0]) return m[0] ? (new a[a.isString(m[0]) ? m.shift() : "Chart"](this[0], m[0], m[1]), this) : A[a.attr(this[0], "data-highcharts-chart")];
    });
  })(K);

  (function (a) {
    var A = a.each,
        C = a.isNumber,
        E = a.map,
        m = a.merge,
        g = a.pInt;

    a.Color = function (e) {
      if (!(this instanceof a.Color)) return new a.Color(e);
      this.init(e);
    };

    a.Color.prototype = {
      parsers: [{
        regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
        parse: function parse(a) {
          return [g(a[1]), g(a[2]), g(a[3]), parseFloat(a[4], 10)];
        }
      }, {
        regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
        parse: function parse(a) {
          return [g(a[1]), g(a[2]), g(a[3]), 1];
        }
      }],
      names: {
        white: "#ffffff",
        black: "#000000"
      },
      init: function init(e) {
        var g, u, t, l;
        if ((this.input = e = this.names[e && e.toLowerCase ? e.toLowerCase() : ""] || e) && e.stops) this.stops = E(e.stops, function (d) {
          return new a.Color(d[1]);
        });else if (e && e.charAt && "#" === e.charAt() && (g = e.length, e = parseInt(e.substr(1), 16), 7 === g ? u = [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255, 1] : 4 === g && (u = [(e & 3840) >> 4 | (e & 3840) >> 8, (e & 240) >> 4 | e & 240, (e & 15) << 4 | e & 15, 1])), !u) for (t = this.parsers.length; t-- && !u;) {
          l = this.parsers[t], (g = l.regex.exec(e)) && (u = l.parse(g));
        }
        this.rgba = u || [];
      },
      get: function get(a) {
        var e = this.input,
            g = this.rgba,
            t;
        this.stops ? (t = m(e), t.stops = [].concat(t.stops), A(this.stops, function (e, d) {
          t.stops[d] = [t.stops[d][0], e.get(a)];
        })) : t = g && C(g[0]) ? "rgb" === a || !a && 1 === g[3] ? "rgb(" + g[0] + "," + g[1] + "," + g[2] + ")" : "a" === a ? g[3] : "rgba(" + g.join(",") + ")" : e;
        return t;
      },
      brighten: function brighten(a) {
        var e,
            u = this.rgba;
        if (this.stops) A(this.stops, function (e) {
          e.brighten(a);
        });else if (C(a) && 0 !== a) for (e = 0; 3 > e; e++) {
          u[e] += g(255 * a), 0 > u[e] && (u[e] = 0), 255 < u[e] && (u[e] = 255);
        }
        return this;
      },
      setOpacity: function setOpacity(a) {
        this.rgba[3] = a;
        return this;
      },
      tweenTo: function tweenTo(a, g) {
        var e = this.rgba,
            t = a.rgba;
        t.length && e && e.length ? (a = 1 !== t[3] || 1 !== e[3], g = (a ? "rgba(" : "rgb(") + Math.round(t[0] + (e[0] - t[0]) * (1 - g)) + "," + Math.round(t[1] + (e[1] - t[1]) * (1 - g)) + "," + Math.round(t[2] + (e[2] - t[2]) * (1 - g)) + (a ? "," + (t[3] + (e[3] - t[3]) * (1 - g)) : "") + ")") : g = a.input || "none";
        return g;
      }
    };

    a.color = function (e) {
      return new a.Color(e);
    };
  })(K);

  (function (a) {
    var A,
        C,
        E = a.addEvent,
        m = a.animate,
        g = a.attr,
        e = a.charts,
        v = a.color,
        u = a.css,
        t = a.createElement,
        l = a.defined,
        d = a.deg2rad,
        c = a.destroyObjectProperties,
        x = a.doc,
        r = a.each,
        n = a.extend,
        b = a.erase,
        f = a.grep,
        q = a.hasTouch,
        G = a.inArray,
        J = a.isArray,
        B = a.isFirefox,
        H = a.isMS,
        w = a.isObject,
        p = a.isString,
        D = a.isWebKit,
        z = a.merge,
        F = a.noop,
        M = a.objectEach,
        h = a.pick,
        y = a.pInt,
        N = a.removeEvent,
        k = a.splat,
        I = a.stop,
        T = a.svg,
        Q = a.SVG_NS,
        O = a.symbolSizes,
        P = a.win;

    A = a.SVGElement = function () {
      return this;
    };

    n(A.prototype, {
      opacity: 1,
      SVG_NS: Q,
      textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline cursor".split(" "),
      init: function init(a, b) {
        this.element = "span" === b ? t(b) : x.createElementNS(this.SVG_NS, b);
        this.renderer = a;
      },
      animate: function animate(b, k, y) {
        k = a.animObject(h(k, this.renderer.globalAnimation, !0));
        0 !== k.duration ? (y && (k.complete = y), m(this, b, k)) : (this.attr(b, null, y), k.step && k.step.call(this));
        return this;
      },
      complexColor: function complexColor(b, h, k) {
        var L = this.renderer,
            y,
            c,
            f,
            d,
            n,
            p,
            q,
            e,
            I,
            w,
            N,
            D = [],
            R;
        a.fireEvent(this.renderer, "complexColor", {
          args: arguments
        }, function () {
          b.radialGradient ? c = "radialGradient" : b.linearGradient && (c = "linearGradient");
          c && (f = b[c], n = L.gradients, q = b.stops, w = k.radialReference, J(f) && (b[c] = f = {
            x1: f[0],
            y1: f[1],
            x2: f[2],
            y2: f[3],
            gradientUnits: "userSpaceOnUse"
          }), "radialGradient" === c && w && !l(f.gradientUnits) && (d = f, f = z(f, L.getRadialAttr(w, d), {
            gradientUnits: "userSpaceOnUse"
          })), M(f, function (a, b) {
            "id" !== b && D.push(b, a);
          }), M(q, function (a) {
            D.push(a);
          }), D = D.join(","), n[D] ? N = n[D].attr("id") : (f.id = N = a.uniqueKey(), n[D] = p = L.createElement(c).attr(f).add(L.defs), p.radAttr = d, p.stops = [], r(q, function (b) {
            0 === b[1].indexOf("rgba") ? (y = a.color(b[1]), e = y.get("rgb"), I = y.get("a")) : (e = b[1], I = 1);
            b = L.createElement("stop").attr({
              offset: b[0],
              "stop-color": e,
              "stop-opacity": I
            }).add(p);
            p.stops.push(b);
          })), R = "url(" + L.url + "#" + N + ")", k.setAttribute(h, R), k.gradient = D, b.toString = function () {
            return R;
          });
        });
      },
      applyTextOutline: function applyTextOutline(h) {
        var k = this.element,
            L,
            y,
            c,
            f,
            d;
        -1 !== h.indexOf("contrast") && (h = h.replace(/contrast/g, this.renderer.getContrast(k.style.fill)));
        h = h.split(" ");
        y = h[h.length - 1];

        if ((c = h[0]) && "none" !== c && a.svg) {
          this.fakeTS = !0;
          h = [].slice.call(k.getElementsByTagName("tspan"));
          this.ySetter = this.xSetter;
          c = c.replace(/(^[\d\.]+)(.*?)$/g, function (a, b, h) {
            return 2 * b + h;
          });

          for (d = h.length; d--;) {
            L = h[d], "highcharts-text-outline" === L.getAttribute("class") && b(h, k.removeChild(L));
          }

          f = k.firstChild;
          r(h, function (a, b) {
            0 === b && (a.setAttribute("x", k.getAttribute("x")), b = k.getAttribute("y"), a.setAttribute("y", b || 0), null === b && k.setAttribute("y", 0));
            a = a.cloneNode(1);
            g(a, {
              "class": "highcharts-text-outline",
              fill: y,
              stroke: y,
              "stroke-width": c,
              "stroke-linejoin": "round"
            });
            k.insertBefore(a, f);
          });
        }
      },
      attr: function attr(a, b, h, k) {
        var y,
            L = this.element,
            c,
            f = this,
            d,
            n;
        "string" === typeof a && void 0 !== b && (y = a, a = {}, a[y] = b);
        "string" === typeof a ? f = (this[a + "Getter"] || this._defaultGetter).call(this, a, L) : (M(a, function (b, h) {
          d = !1;
          k || I(this, h);
          this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(h) && (c || (this.symbolAttr(a), c = !0), d = !0);
          !this.rotation || "x" !== h && "y" !== h || (this.doTransform = !0);
          d || (n = this[h + "Setter"] || this._defaultSetter, n.call(this, b, h, L));
        }, this), this.afterSetters());
        h && h.call(this);
        return f;
      },
      afterSetters: function afterSetters() {
        this.doTransform && (this.updateTransform(), this.doTransform = !1);
      },
      addClass: function addClass(a, b) {
        var h = this.attr("class") || "";
        -1 === h.indexOf(a) && (b || (a = (h + (h ? " " : "") + a).replace("  ", " ")), this.attr("class", a));
        return this;
      },
      hasClass: function hasClass(a) {
        return -1 !== G(a, (this.attr("class") || "").split(" "));
      },
      removeClass: function removeClass(a) {
        return this.attr("class", (this.attr("class") || "").replace(a, ""));
      },
      symbolAttr: function symbolAttr(a) {
        var b = this;
        r("x y r start end width height innerR anchorX anchorY".split(" "), function (k) {
          b[k] = h(a[k], b[k]);
        });
        b.attr({
          d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
        });
      },
      clip: function clip(a) {
        return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
      },
      crisp: function crisp(a, b) {
        var h;
        b = b || a.strokeWidth || 0;
        h = Math.round(b) % 2 / 2;
        a.x = Math.floor(a.x || this.x || 0) + h;
        a.y = Math.floor(a.y || this.y || 0) + h;
        a.width = Math.floor((a.width || this.width || 0) - 2 * h);
        a.height = Math.floor((a.height || this.height || 0) - 2 * h);
        l(a.strokeWidth) && (a.strokeWidth = b);
        return a;
      },
      css: function css(a) {
        var b = this.styles,
            h = {},
            k = this.element,
            c,
            f = "",
            L,
            d = !b,
            p = ["textOutline", "textOverflow", "width"];
        a && a.color && (a.fill = a.color);
        b && M(a, function (a, k) {
          a !== b[k] && (h[k] = a, d = !0);
        });
        d && (b && (a = n(b, h)), a && (null === a.width || "auto" === a.width ? delete this.textWidth : "text" === k.nodeName.toLowerCase() && a.width && (c = this.textWidth = y(a.width))), this.styles = a, c && !T && this.renderer.forExport && delete a.width, k.namespaceURI === this.SVG_NS ? (L = function L(a, b) {
          return "-" + b.toLowerCase();
        }, M(a, function (a, b) {
          -1 === G(b, p) && (f += b.replace(/([A-Z])/g, L) + ":" + a + ";");
        }), f && g(k, "style", f)) : u(k, a), this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline)));
        return this;
      },
      getStyle: function getStyle(a) {
        return P.getComputedStyle(this.element || this, "").getPropertyValue(a);
      },
      strokeWidth: function strokeWidth() {
        var a = this.getStyle("stroke-width"),
            b;
        a.indexOf("px") === a.length - 2 ? a = y(a) : (b = x.createElementNS(Q, "rect"), g(b, {
          width: a,
          "stroke-width": 0
        }), this.element.parentNode.appendChild(b), a = b.getBBox().width, b.parentNode.removeChild(b));
        return a;
      },
      on: function on(a, b) {
        var h = this,
            k = h.element;
        q && "click" === a ? (k.ontouchstart = function (a) {
          h.touchEventFired = Date.now();
          a.preventDefault();
          b.call(k, a);
        }, k.onclick = function (a) {
          (-1 === P.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (h.touchEventFired || 0)) && b.call(k, a);
        }) : k["on" + a] = b;
        return this;
      },
      setRadialReference: function setRadialReference(a) {
        var b = this.renderer.gradients[this.element.gradient];
        this.element.radialReference = a;
        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));
        return this;
      },
      translate: function translate(a, b) {
        return this.attr({
          translateX: a,
          translateY: b
        });
      },
      invert: function invert(a) {
        this.inverted = a;
        this.updateTransform();
        return this;
      },
      updateTransform: function updateTransform() {
        var a = this.translateX || 0,
            b = this.translateY || 0,
            k = this.scaleX,
            y = this.scaleY,
            c = this.inverted,
            f = this.rotation,
            d = this.matrix,
            n = this.element;
        c && (a += this.width, b += this.height);
        a = ["translate(" + a + "," + b + ")"];
        l(d) && a.push("matrix(" + d.join(",") + ")");
        c ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + h(this.rotationOriginX, n.getAttribute("x"), 0) + " " + h(this.rotationOriginY, n.getAttribute("y") || 0) + ")");
        (l(k) || l(y)) && a.push("scale(" + h(k, 1) + " " + h(y, 1) + ")");
        a.length && n.setAttribute("transform", a.join(" "));
      },
      toFront: function toFront() {
        var a = this.element;
        a.parentNode.appendChild(a);
        return this;
      },
      align: function align(a, k, y) {
        var c,
            f,
            d,
            n,
            L = {};
        f = this.renderer;
        d = f.alignedObjects;
        var q, e;

        if (a) {
          if (this.alignOptions = a, this.alignByTranslate = k, !y || p(y)) this.alignTo = c = y || "renderer", b(d, this), d.push(this), y = null;
        } else a = this.alignOptions, k = this.alignByTranslate, c = this.alignTo;

        y = h(y, f[c], f);
        c = a.align;
        f = a.verticalAlign;
        d = (y.x || 0) + (a.x || 0);
        n = (y.y || 0) + (a.y || 0);
        "right" === c ? q = 1 : "center" === c && (q = 2);
        q && (d += (y.width - (a.width || 0)) / q);
        L[k ? "translateX" : "x"] = Math.round(d);
        "bottom" === f ? e = 1 : "middle" === f && (e = 2);
        e && (n += (y.height - (a.height || 0)) / e);
        L[k ? "translateY" : "y"] = Math.round(n);
        this[this.placed ? "animate" : "attr"](L);
        this.placed = !0;
        this.alignAttr = L;
        return this;
      },
      getBBox: function getBBox(a, b) {
        var k,
            y = this.renderer,
            c,
            f = this.element,
            p = this.styles,
            q,
            L = this.textStr,
            e,
            z = y.cache,
            I = y.cacheKeys,
            w;
        b = h(b, this.rotation);
        c = b * d;
        q = f && A.prototype.getStyle.call(f, "font-size");
        l(L) && (w = L.toString(), -1 === w.indexOf("\x3c") && (w = w.replace(/[0-9]/g, "0")), w += ["", b || 0, q, this.textWidth, p && p.textOverflow].join());
        w && !a && (k = z[w]);

        if (!k) {
          if (f.namespaceURI === this.SVG_NS || y.forExport) {
            try {
              (e = this.fakeTS && function (a) {
                r(f.querySelectorAll(".highcharts-text-outline"), function (b) {
                  b.style.display = a;
                });
              }) && e("none"), k = f.getBBox ? n({}, f.getBBox()) : {
                width: f.offsetWidth,
                height: f.offsetHeight
              }, e && e("");
            } catch (V) {}

            if (!k || 0 > k.width) k = {
              width: 0,
              height: 0
            };
          } else k = this.htmlGetBBox();

          y.isSVG && (a = k.width, y = k.height, p && "11px" === p.fontSize && 17 === Math.round(y) && (k.height = y = 14), b && (k.width = Math.abs(y * Math.sin(c)) + Math.abs(a * Math.cos(c)), k.height = Math.abs(y * Math.cos(c)) + Math.abs(a * Math.sin(c))));

          if (w && 0 < k.height) {
            for (; 250 < I.length;) {
              delete z[I.shift()];
            }

            z[w] || I.push(w);
            z[w] = k;
          }
        }

        return k;
      },
      show: function show(a) {
        return this.attr({
          visibility: a ? "inherit" : "visible"
        });
      },
      hide: function hide() {
        return this.attr({
          visibility: "hidden"
        });
      },
      fadeOut: function fadeOut(a) {
        var b = this;
        b.animate({
          opacity: 0
        }, {
          duration: a || 150,
          complete: function complete() {
            b.attr({
              y: -9999
            });
          }
        });
      },
      add: function add(a) {
        var b = this.renderer,
            h = this.element,
            k;
        a && (this.parentGroup = a);
        this.parentInverted = a && a.inverted;
        void 0 !== this.textStr && b.buildText(this);
        this.added = !0;
        if (!a || a.handleZ || this.zIndex) k = this.zIndexSetter();
        k || (a ? a.element : b.box).appendChild(h);
        if (this.onAdd) this.onAdd();
        return this;
      },
      safeRemoveChild: function safeRemoveChild(a) {
        var b = a.parentNode;
        b && b.removeChild(a);
      },
      destroy: function destroy() {
        var a = this,
            h = a.element || {},
            k = a.renderer.isSVG && "SPAN" === h.nodeName && a.parentGroup,
            y = h.ownerSVGElement,
            c = a.clipPath;
        h.onclick = h.onmouseout = h.onmouseover = h.onmousemove = h.point = null;
        I(a);
        c && y && (r(y.querySelectorAll("[clip-path],[CLIP-PATH]"), function (a) {
          var b = a.getAttribute("clip-path"),
              h = c.element.id;
          (-1 < b.indexOf("(#" + h + ")") || -1 < b.indexOf('("#' + h + '")')) && a.removeAttribute("clip-path");
        }), a.clipPath = c.destroy());

        if (a.stops) {
          for (y = 0; y < a.stops.length; y++) {
            a.stops[y] = a.stops[y].destroy();
          }

          a.stops = null;
        }

        for (a.safeRemoveChild(h); k && k.div && 0 === k.div.childNodes.length;) {
          h = k.parentGroup, a.safeRemoveChild(k.div), delete k.div, k = h;
        }

        a.alignTo && b(a.renderer.alignedObjects, a);
        M(a, function (b, h) {
          delete a[h];
        });
        return null;
      },
      xGetter: function xGetter(a) {
        "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
        return this._defaultGetter(a);
      },
      _defaultGetter: function _defaultGetter(a) {
        a = h(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
        /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
        return a;
      },
      dSetter: function dSetter(a, b, h) {
        a && a.join && (a = a.join(" "));
        /(NaN| {2}|^$)/.test(a) && (a = "M 0 0");
        this[b] !== a && (h.setAttribute(b, a), this[b] = a);
      },
      alignSetter: function alignSetter(a) {
        this.alignValue = a;
        this.element.setAttribute("text-anchor", {
          left: "start",
          center: "middle",
          right: "end"
        }[a]);
      },
      opacitySetter: function opacitySetter(a, b, h) {
        this[b] = a;
        h.setAttribute(b, a);
      },
      titleSetter: function titleSetter(a) {
        var b = this.element.getElementsByTagName("title")[0];
        b || (b = x.createElementNS(this.SVG_NS, "title"), this.element.appendChild(b));
        b.firstChild && b.removeChild(b.firstChild);
        b.appendChild(x.createTextNode(String(h(a), "").replace(/<[^>]*>/g, "").replace(/&lt;/g, "\x3c").replace(/&gt;/g, "\x3e")));
      },
      textSetter: function textSetter(a) {
        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));
      },
      fillSetter: function fillSetter(a, b, h) {
        "string" === typeof a ? h.setAttribute(b, a) : a && this.complexColor(a, b, h);
      },
      visibilitySetter: function visibilitySetter(a, b, h) {
        "inherit" === a ? h.removeAttribute(b) : this[b] !== a && h.setAttribute(b, a);
        this[b] = a;
      },
      zIndexSetter: function zIndexSetter(a, b) {
        var h = this.renderer,
            k = this.parentGroup,
            c = (k || h).element || h.box,
            f,
            d = this.element,
            n,
            p,
            h = c === h.box;
        f = this.added;
        var q;
        l(a) ? (d.setAttribute("data-z-index", a), a = +a, this[b] === a && (f = !1)) : l(this[b]) && d.removeAttribute("data-z-index");
        this[b] = a;

        if (f) {
          (a = this.zIndex) && k && (k.handleZ = !0);
          b = c.childNodes;

          for (q = b.length - 1; 0 <= q && !n; q--) {
            if (k = b[q], f = k.getAttribute("data-z-index"), p = !l(f), k !== d) if (0 > a && p && !h && !q) c.insertBefore(d, b[q]), n = !0;else if (y(f) <= a || p && (!l(a) || 0 <= a)) c.insertBefore(d, b[q + 1] || null), n = !0;
          }

          n || (c.insertBefore(d, b[h ? 3 : 0] || null), n = !0);
        }

        return n;
      },
      _defaultSetter: function _defaultSetter(a, b, h) {
        h.setAttribute(b, a);
      }
    });
    A.prototype.yGetter = A.prototype.xGetter;

    A.prototype.translateXSetter = A.prototype.translateYSetter = A.prototype.rotationSetter = A.prototype.verticalAlignSetter = A.prototype.rotationOriginXSetter = A.prototype.rotationOriginYSetter = A.prototype.scaleXSetter = A.prototype.scaleYSetter = A.prototype.matrixSetter = function (a, b) {
      this[b] = a;
      this.doTransform = !0;
    };

    C = a.SVGRenderer = function () {
      this.init.apply(this, arguments);
    };

    n(C.prototype, {
      Element: A,
      SVG_NS: Q,
      init: function init(a, b, h, k, y, c) {
        var f;
        k = this.createElement("svg").attr({
          version: "1.1",
          "class": "highcharts-root"
        });
        f = k.element;
        a.appendChild(f);
        g(a, "dir", "ltr");
        -1 === a.innerHTML.indexOf("xmlns") && g(f, "xmlns", this.SVG_NS);
        this.isSVG = !0;
        this.box = f;
        this.boxWrapper = k;
        this.alignedObjects = [];
        this.url = (B || D) && x.getElementsByTagName("base").length ? P.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
        this.createElement("desc").add().element.appendChild(x.createTextNode("Created with Highcharts 6.1.2"));
        this.defs = this.createElement("defs").add();
        this.allowHTML = c;
        this.forExport = y;
        this.gradients = {};
        this.cache = {};
        this.cacheKeys = [];
        this.imgCount = 0;
        this.setSize(b, h, !1);
        var d;
        B && a.getBoundingClientRect && (b = function b() {
          u(a, {
            left: 0,
            top: 0
          });
          d = a.getBoundingClientRect();
          u(a, {
            left: Math.ceil(d.left) - d.left + "px",
            top: Math.ceil(d.top) - d.top + "px"
          });
        }, b(), this.unSubPixelFix = E(P, "resize", b));
      },
      definition: function definition(a) {
        function b(a, y) {
          var c;
          r(k(a), function (a) {
            var k = h.createElement(a.tagName),
                f = {};
            M(a, function (a, b) {
              "tagName" !== b && "children" !== b && "textContent" !== b && (f[b] = a);
            });
            k.attr(f);
            k.add(y || h.defs);
            a.textContent && k.element.appendChild(x.createTextNode(a.textContent));
            b(a.children || [], k);
            c = k;
          });
          return c;
        }

        var h = this;
        return b(a);
      },
      isHidden: function isHidden() {
        return !this.boxWrapper.getBBox().width;
      },
      destroy: function destroy() {
        var a = this.defs;
        this.box = null;
        this.boxWrapper = this.boxWrapper.destroy();
        c(this.gradients || {});
        this.gradients = null;
        a && (this.defs = a.destroy());
        this.unSubPixelFix && this.unSubPixelFix();
        return this.alignedObjects = null;
      },
      createElement: function createElement(a) {
        var b = new this.Element();
        b.init(this, a);
        return b;
      },
      draw: F,
      getRadialAttr: function getRadialAttr(a, b) {
        return {
          cx: a[0] - a[2] / 2 + b.cx * a[2],
          cy: a[1] - a[2] / 2 + b.cy * a[2],
          r: b.r * a[2]
        };
      },
      getSpanWidth: function getSpanWidth(a) {
        return a.getBBox(!0).width;
      },
      applyEllipsis: function applyEllipsis(a, b, h, k) {
        var y = a.rotation,
            c = h,
            f,
            d = 0,
            n = h.length,
            p = function p(a) {
          b.removeChild(b.firstChild);
          a && b.appendChild(x.createTextNode(a));
        },
            q;

        a.rotation = 0;
        c = this.getSpanWidth(a, b);

        if (q = c > k) {
          for (; d <= n;) {
            f = Math.ceil((d + n) / 2), c = h.substring(0, f) + "\u2026", p(c), c = this.getSpanWidth(a, b), d === n ? d = n + 1 : c > k ? n = f - 1 : d = f;
          }

          0 === n && p("");
        }

        a.rotation = y;
        return q;
      },
      escapes: {
        "\x26": "\x26amp;",
        "\x3c": "\x26lt;",
        "\x3e": "\x26gt;",
        "'": "\x26#39;",
        '"': "\x26quot;"
      },
      buildText: function buildText(a) {
        var b = a.element,
            k = this,
            c = k.forExport,
            d = h(a.textStr, "").toString(),
            n = -1 !== d.indexOf("\x3c"),
            p = b.childNodes,
            q,
            e = g(b, "x"),
            z = a.styles,
            I = a.textWidth,
            l = z && z.lineHeight,
            w = z && z.textOutline,
            N = z && "ellipsis" === z.textOverflow,
            D = z && "nowrap" === z.whiteSpace,
            B,
            F = p.length,
            H = I && !a.added && this.box,
            L = function L(a) {
          return l ? y(l) : k.fontMetrics(void 0, a.getAttribute("style") ? a : b).h;
        },
            t = function t(a, b) {
          M(k.escapes, function (h, k) {
            b && -1 !== G(h, b) || (a = a.toString().replace(new RegExp(h, "g"), k));
          });
          return a;
        },
            J = function J(a, b) {
          var h;
          h = a.indexOf("\x3c");
          a = a.substring(h, a.indexOf("\x3e") - h);
          h = a.indexOf(b + "\x3d");
          if (-1 !== h && (h = h + b.length + 1, b = a.charAt(h), '"' === b || "'" === b)) return a = a.substring(h + 1), a.substring(0, a.indexOf(b));
        },
            z = [d, N, D, l, w, z && z.fontSize, I].join();

        if (z !== a.textCache) {
          for (a.textCache = z; F--;) {
            b.removeChild(p[F]);
          }

          n || w || N || I || -1 !== d.indexOf(" ") ? (H && H.appendChild(b), d = n ? d.replace(/<(b|strong)>/g, '\x3cspan class\x3d"highcharts-strong"\x3e').replace(/<(i|em)>/g, '\x3cspan class\x3d"highcharts-emphasized"\x3e').replace(/<a/g, "\x3cspan").replace(/<\/(b|strong|i|em|a)>/g, "\x3c/span\x3e").split(/<br.*?>/g) : [d], d = f(d, function (a) {
            return "" !== a;
          }), r(d, function (h, y) {
            var f,
                d = 0;
            h = h.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||\x3cspan").replace(/<\/span>/g, "\x3c/span\x3e|||");
            f = h.split("|||");
            r(f, function (h) {
              if ("" !== h || 1 === f.length) {
                var n = {},
                    p = x.createElementNS(k.SVG_NS, "tspan"),
                    z,
                    l;
                (z = J(h, "class")) && g(p, "class", z);
                if (z = J(h, "style")) z = z.replace(/(;| |^)color([ :])/, "$1fill$2"), g(p, "style", z);
                (l = J(h, "href")) && !c && (g(p, "onclick", 'location.href\x3d"' + l + '"'), g(p, "class", "highcharts-anchor"));
                h = t(h.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");

                if (" " !== h) {
                  p.appendChild(x.createTextNode(h));
                  d ? n.dx = 0 : y && null !== e && (n.x = e);
                  g(p, n);
                  b.appendChild(p);
                  !d && B && (!T && c && u(p, {
                    display: "block"
                  }), g(p, "dy", L(p)));

                  if (I) {
                    n = h.replace(/([^\^])-/g, "$1- ").split(" ");
                    l = 1 < f.length || y || 1 < n.length && !D;
                    var w = [],
                        r,
                        G = L(p),
                        F = a.rotation;

                    for (N && (q = k.applyEllipsis(a, p, h, I)); !N && l && (n.length || w.length);) {
                      a.rotation = 0, r = k.getSpanWidth(a, p), h = r > I, void 0 === q && (q = h), h && 1 !== n.length ? (p.removeChild(p.firstChild), w.unshift(n.pop())) : (n = w, w = [], n.length && !D && (p = x.createElementNS(Q, "tspan"), g(p, {
                        dy: G,
                        x: e
                      }), z && g(p, "style", z), b.appendChild(p)), r > I && (I = r + 1)), n.length && p.appendChild(x.createTextNode(n.join(" ").replace(/- /g, "-")));
                    }

                    a.rotation = F;
                  }

                  d++;
                }
              }
            });
            B = B || b.childNodes.length;
          }), N && q && a.attr("title", t(a.textStr, ["\x26lt;", "\x26gt;"])), H && H.removeChild(b), w && a.applyTextOutline && a.applyTextOutline(w)) : b.appendChild(x.createTextNode(t(d)));
        }
      },
      getContrast: function getContrast(a) {
        a = v(a).rgba;
        a[0] *= 1;
        a[1] *= 1.2;
        a[2] *= .5;
        return 459 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF";
      },
      button: function button(a, b, h, k, y, c, f, d, n) {
        var p = this.label(a, b, h, n, null, null, null, null, "button"),
            q = 0;
        p.attr(z({
          padding: 8,
          r: 2
        }, y));
        E(p.element, H ? "mouseover" : "mouseenter", function () {
          3 !== q && p.setState(1);
        });
        E(p.element, H ? "mouseout" : "mouseleave", function () {
          3 !== q && p.setState(q);
        });

        p.setState = function (a) {
          1 !== a && (p.state = q = a);
          p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);
        };

        return p.on("click", function (a) {
          3 !== q && k.call(p, a);
        });
      },
      crispLine: function crispLine(a, b) {
        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - b % 2 / 2);
        a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + b % 2 / 2);
        return a;
      },
      path: function path(a) {
        var b = {};
        J(a) ? b.d = a : w(a) && n(b, a);
        return this.createElement("path").attr(b);
      },
      circle: function circle(a, b, h) {
        a = w(a) ? a : {
          x: a,
          y: b,
          r: h
        };
        b = this.createElement("circle");

        b.xSetter = b.ySetter = function (a, b, h) {
          h.setAttribute("c" + b, a);
        };

        return b.attr(a);
      },
      arc: function arc(a, b, h, k, y, c) {
        w(a) ? (k = a, b = k.y, h = k.r, a = k.x) : k = {
          innerR: k,
          start: y,
          end: c
        };
        a = this.symbol("arc", a, b, h, h, k);
        a.r = h;
        return a;
      },
      rect: function rect(a, b, h, k, y, c) {
        y = w(a) ? a.r : y;
        c = this.createElement("rect");
        a = w(a) ? a : void 0 === a ? {} : {
          x: a,
          y: b,
          width: Math.max(h, 0),
          height: Math.max(k, 0)
        };
        y && (a.r = y);

        c.rSetter = function (a, b, h) {
          g(h, {
            rx: a,
            ry: a
          });
        };

        return c.attr(a);
      },
      setSize: function setSize(a, b, k) {
        var y = this.alignedObjects,
            c = y.length;
        this.width = a;
        this.height = b;

        for (this.boxWrapper.animate({
          width: a,
          height: b
        }, {
          step: function step() {
            this.attr({
              viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
            });
          },
          duration: h(k, !0) ? void 0 : 0
        }); c--;) {
          y[c].align();
        }
      },
      g: function g(a) {
        var b = this.createElement("g");
        return a ? b.attr({
          "class": "highcharts-" + a
        }) : b;
      },
      image: function image(a, b, h, k, y, c) {
        var f = {
          preserveAspectRatio: "none"
        },
            d,
            p = function p(a, b) {
          a.setAttributeNS ? a.setAttributeNS("http://www.w3.org/1999/xlink", "href", b) : a.setAttribute("hc-svg-href", b);
        },
            q = function q(b) {
          p(d.element, a);
          c.call(d, b);
        };

        1 < arguments.length && n(f, {
          x: b,
          y: h,
          width: k,
          height: y
        });
        d = this.createElement("image").attr(f);
        c ? (p(d.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw\x3d\x3d"), f = new P.Image(), E(f, "load", q), f.src = a, f.complete && q({})) : p(d.element, a);
        return d;
      },
      symbol: function symbol(a, b, k, y, c, f) {
        var d = this,
            p,
            q = /^url\((.*?)\)$/,
            z = q.test(a),
            I = !z && (this.symbols[a] ? a : "circle"),
            w = I && this.symbols[I],
            N = l(b) && w && w.call(this.symbols, Math.round(b), Math.round(k), y, c, f),
            D,
            B;
        w ? (p = this.path(N), n(p, {
          symbolName: I,
          x: b,
          y: k,
          width: y,
          height: c
        }), f && n(p, f)) : z && (D = a.match(q)[1], p = this.image(D), p.imgwidth = h(O[D] && O[D].width, f && f.width), p.imgheight = h(O[D] && O[D].height, f && f.height), B = function B() {
          p.attr({
            width: p.width,
            height: p.height
          });
        }, r(["width", "height"], function (a) {
          p[a + "Setter"] = function (a, b) {
            var h = {},
                k = this["img" + b],
                y = "width" === b ? "translateX" : "translateY";
            this[b] = a;
            l(k) && (this.element && this.element.setAttribute(b, k), this.alignByTranslate || (h[y] = ((this[b] || 0) - k) / 2, this.attr(h)));
          };
        }), l(b) && p.attr({
          x: b,
          y: k
        }), p.isImg = !0, l(p.imgwidth) && l(p.imgheight) ? B() : (p.attr({
          width: 0,
          height: 0
        }), t("img", {
          onload: function onload() {
            var a = e[d.chartIndex];
            0 === this.width && (u(this, {
              position: "absolute",
              top: "-999em"
            }), x.body.appendChild(this));
            O[D] = {
              width: this.width,
              height: this.height
            };
            p.imgwidth = this.width;
            p.imgheight = this.height;
            p.element && B();
            this.parentNode && this.parentNode.removeChild(this);
            d.imgCount--;
            if (!d.imgCount && a && a.onload) a.onload();
          },
          src: D
        }), this.imgCount++));
        return p;
      },
      symbols: {
        circle: function circle(a, b, h, k) {
          return this.arc(a + h / 2, b + k / 2, h / 2, k / 2, {
            start: 0,
            end: 2 * Math.PI,
            open: !1
          });
        },
        square: function square(a, b, h, k) {
          return ["M", a, b, "L", a + h, b, a + h, b + k, a, b + k, "Z"];
        },
        triangle: function triangle(a, b, h, k) {
          return ["M", a + h / 2, b, "L", a + h, b + k, a, b + k, "Z"];
        },
        "triangle-down": function triangleDown(a, b, h, k) {
          return ["M", a, b, "L", a + h, b, a + h / 2, b + k, "Z"];
        },
        diamond: function diamond(a, b, h, k) {
          return ["M", a + h / 2, b, "L", a + h, b + k / 2, a + h / 2, b + k, a, b + k / 2, "Z"];
        },
        arc: function arc(a, b, k, y, c) {
          var f = c.start,
              p = c.r || k,
              d = c.r || y || k,
              n = c.end - .001;
          k = c.innerR;
          y = h(c.open, .001 > Math.abs(c.end - c.start - 2 * Math.PI));
          var q = Math.cos(f),
              z = Math.sin(f),
              e = Math.cos(n),
              n = Math.sin(n);
          c = .001 > c.end - f - Math.PI ? 0 : 1;
          p = ["M", a + p * q, b + d * z, "A", p, d, 0, c, 1, a + p * e, b + d * n];
          l(k) && p.push(y ? "M" : "L", a + k * e, b + k * n, "A", k, k, 0, c, 0, a + k * q, b + k * z);
          p.push(y ? "" : "Z");
          return p;
        },
        callout: function callout(a, b, h, k, y) {
          var c = Math.min(y && y.r || 0, h, k),
              f = c + 6,
              p = y && y.anchorX;
          y = y && y.anchorY;
          var d;
          d = ["M", a + c, b, "L", a + h - c, b, "C", a + h, b, a + h, b, a + h, b + c, "L", a + h, b + k - c, "C", a + h, b + k, a + h, b + k, a + h - c, b + k, "L", a + c, b + k, "C", a, b + k, a, b + k, a, b + k - c, "L", a, b + c, "C", a, b, a, b, a + c, b];
          p && p > h ? y > b + f && y < b + k - f ? d.splice(13, 3, "L", a + h, y - 6, a + h + 6, y, a + h, y + 6, a + h, b + k - c) : d.splice(13, 3, "L", a + h, k / 2, p, y, a + h, k / 2, a + h, b + k - c) : p && 0 > p ? y > b + f && y < b + k - f ? d.splice(33, 3, "L", a, y + 6, a - 6, y, a, y - 6, a, b + c) : d.splice(33, 3, "L", a, k / 2, p, y, a, k / 2, a, b + c) : y && y > k && p > a + f && p < a + h - f ? d.splice(23, 3, "L", p + 6, b + k, p, b + k + 6, p - 6, b + k, a + c, b + k) : y && 0 > y && p > a + f && p < a + h - f && d.splice(3, 3, "L", p - 6, b, p, b - 6, p + 6, b, h - c, b);
          return d;
        }
      },
      clipRect: function clipRect(b, h, k, y) {
        var c = a.uniqueKey(),
            f = this.createElement("clipPath").attr({
          id: c
        }).add(this.defs);
        b = this.rect(b, h, k, y, 0).add(f);
        b.id = c;
        b.clipPath = f;
        b.count = 0;
        return b;
      },
      text: function text(a, b, h, k) {
        var y = {};
        if (k && (this.allowHTML || !this.forExport)) return this.html(a, b, h);
        y.x = Math.round(b || 0);
        h && (y.y = Math.round(h));
        if (a || 0 === a) y.text = a;
        a = this.createElement("text").attr(y);
        k || (a.xSetter = function (a, b, h) {
          var k = h.getElementsByTagName("tspan"),
              y,
              c = h.getAttribute(b),
              f;

          for (f = 0; f < k.length; f++) {
            y = k[f], y.getAttribute(b) === c && y.setAttribute(b, a);
          }

          h.setAttribute(b, a);
        });
        return a;
      },
      fontMetrics: function fontMetrics(a, b) {
        a = b && A.prototype.getStyle.call(b, "font-size");
        a = /px/.test(a) ? y(a) : /em/.test(a) ? parseFloat(a) * (b ? this.fontMetrics(null, b.parentNode).f : 16) : 12;
        b = 24 > a ? a + 3 : Math.round(1.2 * a);
        return {
          h: b,
          b: Math.round(.8 * b),
          f: a
        };
      },
      rotCorr: function rotCorr(a, b, h) {
        var k = a;
        b && h && (k = Math.max(k * Math.cos(b * d), 4));
        return {
          x: -a / 3 * Math.sin(b * d),
          y: k
        };
      },
      label: function label(b, h, k, y, c, f, p, d, q) {
        var e = this,
            I = e.g("button" !== q && "label"),
            w = I.text = e.text("", 0, 0, p).attr({
          zIndex: 1
        }),
            D,
            B,
            g = 0,
            x = 3,
            G = 0,
            F,
            T,
            H,
            u,
            t,
            Q = {},
            J,
            v = /^url\((.*?)\)$/.test(y),
            m = v,
            M,
            O,
            P,
            L;
        q && I.addClass("highcharts-" + q);
        m = !0;

        M = function M() {
          return D.strokeWidth() % 2 / 2;
        };

        O = function O() {
          var a = w.element.style,
              b = {};
          B = (void 0 === F || void 0 === T || t) && l(w.textStr) && w.getBBox();
          I.width = (F || B.width || 0) + 2 * x + G;
          I.height = (T || B.height || 0) + 2 * x;
          J = x + e.fontMetrics(a && a.fontSize, w).b;
          m && (D || (I.box = D = e.symbols[y] || v ? e.symbol(y) : e.rect(), D.addClass(("button" === q ? "" : "highcharts-label-box") + (q ? " highcharts-" + q + "-box" : "")), D.add(I), a = M(), b.x = a, b.y = (d ? -J : 0) + a), b.width = Math.round(I.width), b.height = Math.round(I.height), D.attr(n(b, Q)), Q = {});
        };

        P = function P() {
          var a = G + x,
              b;
          b = d ? 0 : J;
          l(F) && B && ("center" === t || "right" === t) && (a += {
            center: .5,
            right: 1
          }[t] * (F - B.width));
          if (a !== w.x || b !== w.y) w.attr("x", a), w.hasBoxWidthChanged && (B = w.getBBox(!0), O()), void 0 !== b && w.attr("y", b);
          w.x = a;
          w.y = b;
        };

        L = function L(a, b) {
          D ? D.attr(a, b) : Q[a] = b;
        };

        I.onAdd = function () {
          w.add(I);
          I.attr({
            text: b || 0 === b ? b : "",
            x: h,
            y: k
          });
          D && l(c) && I.attr({
            anchorX: c,
            anchorY: f
          });
        };

        I.widthSetter = function (b) {
          F = a.isNumber(b) ? b : null;
        };

        I.heightSetter = function (a) {
          T = a;
        };

        I["text-alignSetter"] = function (a) {
          t = a;
        };

        I.paddingSetter = function (a) {
          l(a) && a !== x && (x = I.padding = a, P());
        };

        I.paddingLeftSetter = function (a) {
          l(a) && a !== G && (G = a, P());
        };

        I.alignSetter = function (a) {
          a = {
            left: 0,
            center: .5,
            right: 1
          }[a];
          a !== g && (g = a, B && I.attr({
            x: H
          }));
        };

        I.textSetter = function (a) {
          void 0 !== a && w.textSetter(a);
          O();
          P();
        };

        I["stroke-widthSetter"] = function (a, b) {
          a && (m = !0);
          this["stroke-width"] = a;
          L(b, a);
        };

        I.rSetter = function (a, b) {
          L(b, a);
        };

        I.anchorXSetter = function (a, b) {
          c = I.anchorX = a;
          L(b, Math.round(a) - M() - H);
        };

        I.anchorYSetter = function (a, b) {
          f = I.anchorY = a;
          L(b, a - u);
        };

        I.xSetter = function (a) {
          I.x = a;
          g && (a -= g * ((F || B.width) + 2 * x), I["forceAnimate:x"] = !0);
          H = Math.round(a);
          I.attr("translateX", H);
        };

        I.ySetter = function (a) {
          u = I.y = Math.round(a);
          I.attr("translateY", u);
        };

        var R = I.css;
        return n(I, {
          css: function css(a) {
            if (a) {
              var b = {};
              a = z(a);
              r(I.textProps, function (h) {
                void 0 !== a[h] && (b[h] = a[h], delete a[h]);
              });
              w.css(b);
              "width" in b && O();
            }

            return R.call(I, a);
          },
          getBBox: function getBBox() {
            return {
              width: B.width + 2 * x,
              height: B.height + 2 * x,
              x: B.x - x,
              y: B.y - x
            };
          },
          destroy: function destroy() {
            N(I.element, "mouseenter");
            N(I.element, "mouseleave");
            w && (w = w.destroy());
            D && (D = D.destroy());
            A.prototype.destroy.call(I);
            I = e = O = P = L = null;
          }
        });
      }
    });
    a.Renderer = C;
  })(K);

  (function (a) {
    var A = a.attr,
        C = a.createElement,
        E = a.css,
        m = a.defined,
        g = a.each,
        e = a.extend,
        v = a.isFirefox,
        u = a.isMS,
        t = a.isWebKit,
        l = a.pick,
        d = a.pInt,
        c = a.SVGRenderer,
        x = a.win,
        r = a.wrap;
    e(a.SVGElement.prototype, {
      htmlCss: function htmlCss(a) {
        var b = this.element;
        if ((b = a && "SPAN" === b.tagName && a.width) || this.textWidth && !b) delete a.width, this.textWidth = b, this.htmlUpdateTransform();
        a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");
        this.styles = e(this.styles, a);
        E(this.element, a);
        return this;
      },
      htmlGetBBox: function htmlGetBBox() {
        var a = this.element;
        return {
          x: a.offsetLeft,
          y: a.offsetTop,
          width: a.offsetWidth,
          height: a.offsetHeight
        };
      },
      htmlUpdateTransform: function htmlUpdateTransform() {
        if (this.added) {
          var a = this.renderer,
              b = this.element,
              c = this.x || 0,
              q = this.y || 0,
              e = this.textAlign || "left",
              l = {
            left: 0,
            center: .5,
            right: 1
          }[e],
              r = this.styles,
              x = r && r.whiteSpace;
          E(b, {
            marginLeft: this.translateX || 0,
            marginTop: this.translateY || 0
          });
          this.inverted && g(b.childNodes, function (c) {
            a.invertChild(c, b);
          });

          if ("SPAN" === b.tagName) {
            var r = this.rotation,
                w = this.textWidth && d(this.textWidth),
                p = [r, e, b.innerHTML, this.textWidth, this.textAlign].join(),
                D;
            (D = w !== this.oldTextWidth) && !(D = w > this.oldTextWidth) && ((D = this.textPxLength) || (E(b, {
              width: "",
              whiteSpace: x || "nowrap"
            }), D = b.offsetWidth), D = D > w);
            D && /[ \-]/.test(b.textContent || b.innerText) ? (E(b, {
              width: w + "px",
              display: "block",
              whiteSpace: x || "normal"
            }), this.oldTextWidth = w, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
            p !== this.cTT && (x = a.fontMetrics(b.style.fontSize).b, !m(r) || r === (this.oldRotation || 0) && e === this.oldAlign || this.setSpanRotation(r, l, x), this.getSpanCorrection(!m(r) && this.textPxLength || b.offsetWidth, x, l, r, e));
            E(b, {
              left: c + (this.xCorr || 0) + "px",
              top: q + (this.yCorr || 0) + "px"
            });
            this.cTT = p;
            this.oldRotation = r;
            this.oldAlign = e;
          }
        } else this.alignOnAdd = !0;
      },
      setSpanRotation: function setSpanRotation(a, b, c) {
        var f = {},
            d = this.renderer.getTransformKey();
        f[d] = f.transform = "rotate(" + a + "deg)";
        f[d + (v ? "Origin" : "-origin")] = f.transformOrigin = 100 * b + "% " + c + "px";
        E(this.element, f);
      },
      getSpanCorrection: function getSpanCorrection(a, b, c) {
        this.xCorr = -a * c;
        this.yCorr = -b;
      }
    });
    e(c.prototype, {
      getTransformKey: function getTransformKey() {
        return u && !/Edge/.test(x.navigator.userAgent) ? "-ms-transform" : t ? "-webkit-transform" : v ? "MozTransform" : x.opera ? "-o-transform" : "";
      },
      html: function html(a, b, c) {
        var f = this.createElement("span"),
            d = f.element,
            n = f.renderer,
            x = n.isSVG,
            u = function u(a, b) {
          g(["opacity", "visibility"], function (c) {
            r(a, c + "Setter", function (a, c, f, h) {
              a.call(this, c, f, h);
              b[f] = c;
            });
          });
          a.addedSetters = !0;
        };

        f.textSetter = function (a) {
          a !== d.innerHTML && delete this.bBox;
          this.textStr = a;
          d.innerHTML = l(a, "");
          f.doTransform = !0;
        };

        x && u(f, f.element.style);

        f.xSetter = f.ySetter = f.alignSetter = f.rotationSetter = function (a, b) {
          "align" === b && (b = "textAlign");
          f[b] = a;
          f.doTransform = !0;
        };

        f.afterSetters = function () {
          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
        };

        f.attr({
          text: a,
          x: Math.round(b),
          y: Math.round(c)
        }).css({
          position: "absolute"
        });
        d.style.whiteSpace = "nowrap";
        f.css = f.htmlCss;
        x && (f.add = function (a) {
          var b,
              c = n.box.parentNode,
              q = [];

          if (this.parentGroup = a) {
            if (b = a.div, !b) {
              for (; a;) {
                q.push(a), a = a.parentGroup;
              }

              g(q.reverse(), function (a) {
                function d(b, k) {
                  a[k] = b;
                  "translateX" === k ? h.left = b + "px" : h.top = b + "px";
                  a.doTransform = !0;
                }

                var h,
                    y = A(a.element, "class");
                y && (y = {
                  className: y
                });
                b = a.div = a.div || C("div", y, {
                  position: "absolute",
                  left: (a.translateX || 0) + "px",
                  top: (a.translateY || 0) + "px",
                  display: a.display,
                  opacity: a.opacity,
                  pointerEvents: a.styles && a.styles.pointerEvents
                }, b || c);
                h = b.style;
                e(a, {
                  classSetter: function (a) {
                    return function (b) {
                      this.element.setAttribute("class", b);
                      a.className = b;
                    };
                  }(b),
                  on: function on() {
                    q[0].div && f.on.apply({
                      element: q[0].div
                    }, arguments);
                    return a;
                  },
                  translateXSetter: d,
                  translateYSetter: d
                });
                a.addedSetters || u(a, h);
              });
            }
          } else b = c;

          b.appendChild(d);
          f.added = !0;
          f.alignOnAdd && f.htmlUpdateTransform();
          return f;
        });
        return f;
      }
    });
  })(K);

  (function (a) {
    var A = a.defined,
        C = a.each,
        E = a.extend,
        m = a.merge,
        g = a.pick,
        e = a.timeUnits,
        v = a.win;

    a.Time = function (a) {
      this.update(a, !1);
    };

    a.Time.prototype = {
      defaultOptions: {},
      update: function update(a) {
        var e = g(a && a.useUTC, !0),
            l = this;
        this.options = a = m(!0, this.options || {}, a);
        this.Date = a.Date || v.Date;
        this.timezoneOffset = (this.useUTC = e) && a.timezoneOffset;
        this.getTimezoneOffset = this.timezoneOffsetFunction();
        (this.variableTimezone = !(e && !a.getTimezoneOffset && !a.timezone)) || this.timezoneOffset ? (this.get = function (a, c) {
          var d = c.getTime(),
              e = d - l.getTimezoneOffset(c);
          c.setTime(e);
          a = c["getUTC" + a]();
          c.setTime(d);
          return a;
        }, this.set = function (a, c, e) {
          var d;
          if ("Milliseconds" === a || "Seconds" === a || "Minutes" === a && 0 === c.getTimezoneOffset() % 60) c["set" + a](e);else d = l.getTimezoneOffset(c), d = c.getTime() - d, c.setTime(d), c["setUTC" + a](e), a = l.getTimezoneOffset(c), d = c.getTime() + a, c.setTime(d);
        }) : e ? (this.get = function (a, c) {
          return c["getUTC" + a]();
        }, this.set = function (a, c, e) {
          return c["setUTC" + a](e);
        }) : (this.get = function (a, c) {
          return c["get" + a]();
        }, this.set = function (a, c, e) {
          return c["set" + a](e);
        });
      },
      makeTime: function makeTime(e, t, l, d, c, x) {
        var r, n, b;
        this.useUTC ? (r = this.Date.UTC.apply(0, arguments), n = this.getTimezoneOffset(r), r += n, b = this.getTimezoneOffset(r), n !== b ? r += b - n : n - 36E5 !== this.getTimezoneOffset(r - 36E5) || a.isSafari || (r -= 36E5)) : r = new this.Date(e, t, g(l, 1), g(d, 0), g(c, 0), g(x, 0)).getTime();
        return r;
      },
      timezoneOffsetFunction: function timezoneOffsetFunction() {
        var e = this,
            g = this.options,
            l = v.moment;
        if (!this.useUTC) return function (a) {
          return 6E4 * new Date(a).getTimezoneOffset();
        };

        if (g.timezone) {
          if (l) return function (a) {
            return 6E4 * -l.tz(a, g.timezone).utcOffset();
          };
          a.error(25);
        }

        return this.useUTC && g.getTimezoneOffset ? function (a) {
          return 6E4 * g.getTimezoneOffset(a);
        } : function () {
          return 6E4 * (e.timezoneOffset || 0);
        };
      },
      dateFormat: function dateFormat(e, g, l) {
        if (!a.defined(g) || isNaN(g)) return a.defaultOptions.lang.invalidDate || "";
        e = a.pick(e, "%Y-%m-%d %H:%M:%S");
        var d = this,
            c = new this.Date(g),
            x = this.get("Hours", c),
            r = this.get("Day", c),
            n = this.get("Date", c),
            b = this.get("Month", c),
            f = this.get("FullYear", c),
            q = a.defaultOptions.lang,
            G = q.weekdays,
            u = q.shortWeekdays,
            B = a.pad,
            c = a.extend({
          a: u ? u[r] : G[r].substr(0, 3),
          A: G[r],
          d: B(n),
          e: B(n, 2, " "),
          w: r,
          b: q.shortMonths[b],
          B: q.months[b],
          m: B(b + 1),
          o: b + 1,
          y: f.toString().substr(2, 2),
          Y: f,
          H: B(x),
          k: x,
          I: B(x % 12 || 12),
          l: x % 12 || 12,
          M: B(d.get("Minutes", c)),
          p: 12 > x ? "AM" : "PM",
          P: 12 > x ? "am" : "pm",
          S: B(c.getSeconds()),
          L: B(Math.round(g % 1E3), 3)
        }, a.dateFormats);
        a.objectEach(c, function (a, b) {
          for (; -1 !== e.indexOf("%" + b);) {
            e = e.replace("%" + b, "function" === typeof a ? a.call(d, g) : a);
          }
        });
        return l ? e.substr(0, 1).toUpperCase() + e.substr(1) : e;
      },
      getTimeTicks: function getTimeTicks(a, t, l, d) {
        var c = this,
            x = [],
            r = {},
            n,
            b = new c.Date(t),
            f = a.unitRange,
            q = a.count || 1,
            G;

        if (A(t)) {
          c.set("Milliseconds", b, f >= e.second ? 0 : q * Math.floor(c.get("Milliseconds", b) / q));
          f >= e.second && c.set("Seconds", b, f >= e.minute ? 0 : q * Math.floor(c.get("Seconds", b) / q));
          f >= e.minute && c.set("Minutes", b, f >= e.hour ? 0 : q * Math.floor(c.get("Minutes", b) / q));
          f >= e.hour && c.set("Hours", b, f >= e.day ? 0 : q * Math.floor(c.get("Hours", b) / q));
          f >= e.day && c.set("Date", b, f >= e.month ? 1 : q * Math.floor(c.get("Date", b) / q));
          f >= e.month && (c.set("Month", b, f >= e.year ? 0 : q * Math.floor(c.get("Month", b) / q)), n = c.get("FullYear", b));
          f >= e.year && c.set("FullYear", b, n - n % q);
          f === e.week && c.set("Date", b, c.get("Date", b) - c.get("Day", b) + g(d, 1));
          n = c.get("FullYear", b);
          d = c.get("Month", b);
          var u = c.get("Date", b),
              B = c.get("Hours", b);
          t = b.getTime();
          c.variableTimezone && (G = l - t > 4 * e.month || c.getTimezoneOffset(t) !== c.getTimezoneOffset(l));
          b = b.getTime();

          for (t = 1; b < l;) {
            x.push(b), b = f === e.year ? c.makeTime(n + t * q, 0) : f === e.month ? c.makeTime(n, d + t * q) : !G || f !== e.day && f !== e.week ? G && f === e.hour && 1 < q ? c.makeTime(n, d, u, B + t * q) : b + f * q : c.makeTime(n, d, u + t * q * (f === e.day ? 1 : 7)), t++;
          }

          x.push(b);
          f <= e.hour && 1E4 > x.length && C(x, function (a) {
            0 === a % 18E5 && "000000000" === c.dateFormat("%H%M%S%L", a) && (r[a] = "day");
          });
        }

        x.info = E(a, {
          higherRanks: r,
          totalRange: f * q
        });
        return x;
      }
    };
  })(K);

  (function (a) {
    var A = a.merge;
    a.defaultOptions = {
      symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
      lang: {
        loading: "Loading...",
        months: "January February March April May June July August September October November December".split(" "),
        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
        weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        decimalPoint: ".",
        numericSymbols: "kMGTPE".split(""),
        resetZoom: "Reset zoom",
        resetZoomTitle: "Reset zoom level 1:1",
        thousandsSep: " "
      },
      global: {},
      time: a.Time.prototype.defaultOptions,
      chart: {
        borderRadius: 0,
        colorCount: 10,
        defaultSeriesType: "line",
        ignoreHiddenSeries: !0,
        spacing: [10, 10, 15, 10],
        resetZoomButton: {
          theme: {
            zIndex: 6
          },
          position: {
            align: "right",
            x: -10,
            y: 10
          }
        },
        width: null,
        height: null
      },
      title: {
        text: "Chart title",
        align: "center",
        margin: 15,
        widthAdjust: -44
      },
      subtitle: {
        text: "",
        align: "center",
        widthAdjust: -44
      },
      plotOptions: {},
      labels: {
        style: {
          position: "absolute",
          color: "#333333"
        }
      },
      legend: {
        enabled: !0,
        align: "center",
        alignColumns: !0,
        layout: "horizontal",
        labelFormatter: function labelFormatter() {
          return this.name;
        },
        borderColor: "#999999",
        borderRadius: 0,
        navigation: {},
        itemCheckboxStyle: {
          position: "absolute",
          width: "13px",
          height: "13px"
        },
        squareSymbol: !0,
        symbolPadding: 5,
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        title: {}
      },
      loading: {},
      tooltip: {
        enabled: !0,
        animation: a.svg,
        borderRadius: 3,
        dateTimeLabelFormats: {
          millisecond: "%A, %b %e, %H:%M:%S.%L",
          second: "%A, %b %e, %H:%M:%S",
          minute: "%A, %b %e, %H:%M",
          hour: "%A, %b %e, %H:%M",
          day: "%A, %b %e, %Y",
          week: "Week from %A, %b %e, %Y",
          month: "%B %Y",
          year: "%Y"
        },
        footerFormat: "",
        padding: 8,
        snap: a.isTouchDevice ? 25 : 10,
        headerFormat: '\x3cspan class\x3d"highcharts-header"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e',
        pointFormat: "<span class=\"highcharts-color-{point.colorIndex}\">\u25CF</span> {series.name}: <span class=\"highcharts-strong\">{point.y}</span><br/>"
      },
      credits: {
        enabled: !0,
        href: "https://www.highcharts.com",
        position: {
          align: "right",
          x: -10,
          verticalAlign: "bottom",
          y: -5
        },
        text: "Highcharts.com"
      }
    };

    a.setOptions = function (C) {
      a.defaultOptions = A(!0, a.defaultOptions, C);
      a.time.update(A(a.defaultOptions.global, a.defaultOptions.time), !1);
      return a.defaultOptions;
    };

    a.getOptions = function () {
      return a.defaultOptions;
    };

    a.defaultPlotOptions = a.defaultOptions.plotOptions;
    a.time = new a.Time(A(a.defaultOptions.global, a.defaultOptions.time));

    a.dateFormat = function (A, E, m) {
      return a.time.dateFormat(A, E, m);
    };
  })(K);

  (function (a) {
    var A = a.correctFloat,
        C = a.defined,
        E = a.destroyObjectProperties,
        m = a.fireEvent,
        g = a.isNumber,
        e = a.pick,
        v = a.deg2rad;

    a.Tick = function (a, e, l, d) {
      this.axis = a;
      this.pos = e;
      this.type = l || "";
      this.isNewLabel = this.isNew = !0;
      l || d || this.addLabel();
    };

    a.Tick.prototype = {
      addLabel: function addLabel() {
        var a = this.axis,
            g = a.options,
            l = a.chart,
            d = a.categories,
            c = a.names,
            x = this.pos,
            r = g.labels,
            n = a.tickPositions,
            b = x === n[0],
            f = x === n[n.length - 1],
            c = d ? e(d[x], c[x], x) : x,
            d = this.label,
            n = n.info,
            q;
        a.isDatetimeAxis && n && (q = g.dateTimeLabelFormats[n.higherRanks[x] || n.unitName]);
        this.isFirst = b;
        this.isLast = f;
        g = {
          axis: a,
          chart: l,
          isFirst: b,
          isLast: f,
          dateTimeLabelFormat: q,
          value: a.isLog ? A(a.lin2log(c)) : c,
          pos: x
        };
        g = a.labelFormatter.call(g, g);
        if (C(d)) d && d.attr({
          text: g
        });else {
          if (this.label = d = C(g) && r.enabled ? l.renderer.text(g, 0, 0, r.useHTML).add(a.labelGroup) : null) d.textPxLength = d.getBBox().width;
          this.rotation = 0;
        }
      },
      getLabelSize: function getLabelSize() {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
      },
      handleOverflow: function handleOverflow(a) {
        var g = this.axis,
            l = g.options.labels,
            d = a.x,
            c = g.chart.chartWidth,
            x = g.chart.spacing,
            r = e(g.labelLeft, Math.min(g.pos, x[3])),
            x = e(g.labelRight, Math.max(g.isRadial ? 0 : g.pos + g.len, c - x[1])),
            n = this.label,
            b = this.rotation,
            f = {
          left: 0,
          center: .5,
          right: 1
        }[g.labelAlign || n.attr("align")],
            q = n.getBBox().width,
            G = g.getSlotWidth(this),
            u = G,
            B = 1,
            H,
            w = {};
        if (b || !1 === l.overflow) 0 > b && d - f * q < r ? H = Math.round(d / Math.cos(b * v) - r) : 0 < b && d + f * q > x && (H = Math.round((c - d) / Math.cos(b * v)));else if (c = d + (1 - f) * q, d - f * q < r ? u = a.x + u * (1 - f) - r : c > x && (u = x - a.x + u * f, B = -1), u = Math.min(G, u), u < G && "center" === g.labelAlign && (a.x += B * (G - u - f * (G - Math.min(q, u)))), q > u || g.autoRotation && (n.styles || {}).width) H = u;
        H && (w.width = H, (l.style || {}).textOverflow || (w.textOverflow = "ellipsis"), n.css(w));
      },
      getPosition: function getPosition(e, g, l, d) {
        var c = this.axis,
            x = c.chart,
            r = d && x.oldChartHeight || x.chartHeight;
        e = {
          x: e ? a.correctFloat(c.translate(g + l, null, null, d) + c.transB) : c.left + c.offset + (c.opposite ? (d && x.oldChartWidth || x.chartWidth) - c.right - c.left : 0),
          y: e ? r - c.bottom + c.offset - (c.opposite ? c.height : 0) : a.correctFloat(r - c.translate(g + l, null, null, d) - c.transB)
        };
        m(this, "afterGetPosition", {
          pos: e
        });
        return e;
      },
      getLabelPosition: function getLabelPosition(a, e, l, d, c, g, r, n) {
        var b = this.axis,
            f = b.transA,
            q = b.reversed,
            x = b.staggerLines,
            u = b.tickRotCorr || {
          x: 0,
          y: 0
        },
            B = c.y,
            H = d || b.reserveSpaceDefault ? 0 : -b.labelOffset * ("center" === b.labelAlign ? .5 : 1),
            w = {};
        C(B) || (B = 0 === b.side ? l.rotation ? -8 : -l.getBBox().height : 2 === b.side ? u.y + 8 : Math.cos(l.rotation * v) * (u.y - l.getBBox(!1, 0).height / 2));
        a = a + c.x + H + u.x - (g && d ? g * f * (q ? -1 : 1) : 0);
        e = e + B - (g && !d ? g * f * (q ? 1 : -1) : 0);
        x && (l = r / (n || 1) % x, b.opposite && (l = x - l - 1), e += b.labelOffset / x * l);
        w.x = a;
        w.y = Math.round(e);
        m(this, "afterGetLabelPosition", {
          pos: w
        });
        return w;
      },
      getMarkPath: function getMarkPath(a, e, l, d, c, g) {
        return g.crispLine(["M", a, e, "L", a + (c ? 0 : -l), e + (c ? l : 0)], d);
      },
      renderGridLine: function renderGridLine(a, e, l) {
        var d = this.axis,
            c = this.gridLine,
            g = {},
            r = this.pos,
            n = this.type,
            b = d.tickmarkOffset,
            f = d.chart.renderer;
        c || (n || (g.zIndex = 1), a && (g.opacity = 0), this.gridLine = c = f.path().attr(g).addClass("highcharts-" + (n ? n + "-" : "") + "grid-line").add(d.gridGroup));
        if (!a && c && (a = d.getPlotLinePath(r + b, c.strokeWidth() * l, a, !0))) c[this.isNew ? "attr" : "animate"]({
          d: a,
          opacity: e
        });
      },
      renderMark: function renderMark(a, e, g) {
        var d = this.axis,
            c = d.chart.renderer,
            l = this.type,
            r = d.tickSize(l ? l + "Tick" : "tick"),
            n = this.mark,
            b = !n,
            f = a.x;
        a = a.y;
        r && (d.opposite && (r[0] = -r[0]), b && (this.mark = n = c.path().addClass("highcharts-" + (l ? l + "-" : "") + "tick").add(d.axisGroup)), n[b ? "attr" : "animate"]({
          d: this.getMarkPath(f, a, r[0], n.strokeWidth() * g, d.horiz, c),
          opacity: e
        }));
      },
      renderLabel: function renderLabel(a, m, l, d) {
        var c = this.axis,
            x = c.horiz,
            r = c.options,
            n = this.label,
            b = r.labels,
            f = b.step,
            c = c.tickmarkOffset,
            q = !0,
            G = a.x;
        a = a.y;
        n && g(G) && (n.xy = a = this.getLabelPosition(G, a, n, x, b, c, d, f), this.isFirst && !this.isLast && !e(r.showFirstLabel, 1) || this.isLast && !this.isFirst && !e(r.showLastLabel, 1) ? q = !1 : !x || b.step || b.rotation || m || 0 === l || this.handleOverflow(a), f && d % f && (q = !1), q && g(a.y) ? (a.opacity = l, n[this.isNewLabel ? "attr" : "animate"](a), this.isNewLabel = !1) : (n.attr("y", -9999), this.isNewLabel = !0));
      },
      render: function render(g, m, l) {
        var d = this.axis,
            c = d.horiz,
            x = this.getPosition(c, this.pos, d.tickmarkOffset, m),
            r = x.x,
            n = x.y,
            d = c && r === d.pos + d.len || !c && n === d.pos ? -1 : 1;
        l = e(l, 1);
        this.isActive = !0;
        this.renderGridLine(m, l, d);
        this.renderMark(x, l, d);
        this.renderLabel(x, m, l, g);
        this.isNew = !1;
        a.fireEvent(this, "afterRender");
      },
      destroy: function destroy() {
        E(this, this.axis);
      }
    };
  })(K);

  var U = function (a) {
    var A = a.addEvent,
        C = a.animObject,
        E = a.arrayMax,
        m = a.arrayMin,
        g = a.correctFloat,
        e = a.defaultOptions,
        v = a.defined,
        u = a.deg2rad,
        t = a.destroyObjectProperties,
        l = a.each,
        d = a.extend,
        c = a.fireEvent,
        x = a.format,
        r = a.getMagnitude,
        n = a.grep,
        b = a.inArray,
        f = a.isArray,
        q = a.isNumber,
        G = a.isString,
        J = a.merge,
        B = a.normalizeTickInterval,
        H = a.objectEach,
        w = a.pick,
        p = a.removeEvent,
        D = a.splat,
        z = a.syncTimeout,
        F = a.Tick,
        M = function M() {
      this.init.apply(this, arguments);
    };

    a.extend(M.prototype, {
      defaultOptions: {
        dateTimeLabelFormats: {
          millisecond: "%H:%M:%S.%L",
          second: "%H:%M:%S",
          minute: "%H:%M",
          hour: "%H:%M",
          day: "%e. %b",
          week: "%e. %b",
          month: "%b '%y",
          year: "%Y"
        },
        endOnTick: !1,
        labels: {
          enabled: !0,
          x: 0
        },
        maxPadding: .01,
        minorTickLength: 2,
        minorTickPosition: "outside",
        minPadding: .01,
        startOfWeek: 1,
        startOnTick: !1,
        tickLength: 10,
        tickPixelInterval: 100,
        tickmarkPlacement: "between",
        tickPosition: "outside",
        title: {
          align: "middle"
        },
        type: "linear"
      },
      defaultYAxisOptions: {
        endOnTick: !0,
        maxPadding: .05,
        minPadding: .05,
        tickPixelInterval: 72,
        showLastLabel: !0,
        labels: {
          x: -8
        },
        startOnTick: !0,
        title: {
          rotation: 270,
          text: "Values"
        },
        stackLabels: {
          allowOverlap: !1,
          enabled: !1,
          formatter: function formatter() {
            return a.numberFormat(this.total, -1);
          }
        }
      },
      defaultLeftAxisOptions: {
        labels: {
          x: -15
        },
        title: {
          rotation: 270
        }
      },
      defaultRightAxisOptions: {
        labels: {
          x: 15
        },
        title: {
          rotation: 90
        }
      },
      defaultBottomAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {
          rotation: 0
        }
      },
      defaultTopAxisOptions: {
        labels: {
          autoRotation: [-45],
          x: 0
        },
        title: {
          rotation: 0
        }
      },
      init: function init(a, y) {
        var h = y.isX,
            k = this;
        k.chart = a;
        k.horiz = a.inverted && !k.isZAxis ? !h : h;
        k.isXAxis = h;
        k.coll = k.coll || (h ? "xAxis" : "yAxis");
        c(this, "init", {
          userOptions: y
        });
        k.opposite = y.opposite;
        k.side = y.side || (k.horiz ? k.opposite ? 0 : 2 : k.opposite ? 1 : 3);
        k.setOptions(y);
        var f = this.options,
            p = f.type;
        k.labelFormatter = f.labels.formatter || k.defaultLabelFormatter;
        k.userOptions = y;
        k.minPixelPadding = 0;
        k.reversed = f.reversed;
        k.visible = !1 !== f.visible;
        k.zoomEnabled = !1 !== f.zoomEnabled;
        k.hasNames = "category" === p || !0 === f.categories;
        k.categories = f.categories || k.hasNames;
        k.names || (k.names = [], k.names.keys = {});
        k.plotLinesAndBandsGroups = {};
        k.isLog = "logarithmic" === p;
        k.isDatetimeAxis = "datetime" === p;
        k.positiveValuesOnly = k.isLog && !k.allowNegativeLog;
        k.isLinked = v(f.linkedTo);
        k.ticks = {};
        k.labelEdge = [];
        k.minorTicks = {};
        k.plotLinesAndBands = [];
        k.alternateBands = {};
        k.len = 0;
        k.minRange = k.userMinRange = f.minRange || f.maxZoom;
        k.range = f.range;
        k.offset = f.offset || 0;
        k.stacks = {};
        k.oldStacks = {};
        k.stacksTouched = 0;
        k.max = null;
        k.min = null;
        k.crosshair = w(f.crosshair, D(a.options.tooltip.crosshairs)[h ? 0 : 1], !1);
        y = k.options.events;
        -1 === b(k, a.axes) && (h ? a.axes.splice(a.xAxis.length, 0, k) : a.axes.push(k), a[k.coll].push(k));
        k.series = k.series || [];
        a.inverted && !k.isZAxis && h && void 0 === k.reversed && (k.reversed = !0);
        H(y, function (a, b) {
          A(k, b, a);
        });
        k.lin2log = f.linearToLogConverter || k.lin2log;
        k.isLog && (k.val2lin = k.log2lin, k.lin2val = k.lin2log);
        c(this, "afterInit");
      },
      setOptions: function setOptions(a) {
        this.options = J(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], J(e[this.coll], a));
        c(this, "afterSetOptions", {
          userOptions: a
        });
      },
      defaultLabelFormatter: function defaultLabelFormatter() {
        var b = this.axis,
            f = this.value,
            c = b.chart.time,
            k = b.categories,
            p = this.dateTimeLabelFormat,
            d = e.lang,
            n = d.numericSymbols,
            d = d.numericSymbolMagnitude || 1E3,
            q = n && n.length,
            z,
            g = b.options.labels.format,
            b = b.isLog ? Math.abs(f) : b.tickInterval;
        if (g) z = x(g, this, c);else if (k) z = f;else if (p) z = c.dateFormat(p, f);else if (q && 1E3 <= b) for (; q-- && void 0 === z;) {
          c = Math.pow(d, q + 1), b >= c && 0 === 10 * f % c && null !== n[q] && 0 !== f && (z = a.numberFormat(f / c, -1) + n[q]);
        }
        void 0 === z && (z = 1E4 <= Math.abs(f) ? a.numberFormat(f, -1) : a.numberFormat(f, -1, void 0, ""));
        return z;
      },
      getSeriesExtremes: function getSeriesExtremes() {
        var a = this,
            b = a.chart;
        c(this, "getSeriesExtremes", null, function () {
          a.hasVisibleSeries = !1;
          a.dataMin = a.dataMax = a.threshold = null;
          a.softThreshold = !a.isXAxis;
          a.buildStacks && a.buildStacks();
          l(a.series, function (h) {
            if (h.visible || !b.options.chart.ignoreHiddenSeries) {
              var k = h.options,
                  f = k.threshold,
                  c;
              a.hasVisibleSeries = !0;
              a.positiveValuesOnly && 0 >= f && (f = null);
              if (a.isXAxis) k = h.xData, k.length && (h = m(k), c = E(k), q(h) || h instanceof Date || (k = n(k, q), h = m(k), c = E(k)), k.length && (a.dataMin = Math.min(w(a.dataMin, k[0], h), h), a.dataMax = Math.max(w(a.dataMax, k[0], c), c)));else if (h.getExtremes(), c = h.dataMax, h = h.dataMin, v(h) && v(c) && (a.dataMin = Math.min(w(a.dataMin, h), h), a.dataMax = Math.max(w(a.dataMax, c), c)), v(f) && (a.threshold = f), !k.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
            }
          });
        });
        c(this, "afterGetSeriesExtremes");
      },
      translate: function translate(a, b, f, k, c, p) {
        var h = this.linkedParent || this,
            y = 1,
            d = 0,
            n = k ? h.oldTransA : h.transA;
        k = k ? h.oldMin : h.min;
        var e = h.minPixelPadding;
        c = (h.isOrdinal || h.isBroken || h.isLog && c) && h.lin2val;
        n || (n = h.transA);
        f && (y *= -1, d = h.len);
        h.reversed && (y *= -1, d -= y * (h.sector || h.len));
        b ? (a = (a * y + d - e) / n + k, c && (a = h.lin2val(a))) : (c && (a = h.val2lin(a)), a = q(k) ? y * (a - k) * n + d + y * e + (q(p) ? n * p : 0) : void 0);
        return a;
      },
      toPixels: function toPixels(a, b) {
        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
      },
      toValue: function toValue(a, b) {
        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
      },
      getPlotLinePath: function getPlotLinePath(a, b, c, k, f) {
        var h = this.chart,
            y = this.left,
            p = this.top,
            d,
            n,
            e = c && h.oldChartHeight || h.chartHeight,
            z = c && h.oldChartWidth || h.chartWidth,
            I;
        d = this.transB;

        var g = function g(a, b, h) {
          if (a < b || a > h) k ? a = Math.min(Math.max(b, a), h) : I = !0;
          return a;
        };

        f = w(f, this.translate(a, null, null, c));
        f = Math.min(Math.max(-1E5, f), 1E5);
        a = c = Math.round(f + d);
        d = n = Math.round(e - f - d);
        q(f) ? this.horiz ? (d = p, n = e - this.bottom, a = c = g(a, y, y + this.width)) : (a = y, c = z - this.right, d = n = g(d, p, p + this.height)) : (I = !0, k = !1);
        return I && !k ? null : h.renderer.crispLine(["M", a, d, "L", c, n], b || 1);
      },
      getLinearTickPositions: function getLinearTickPositions(a, b, c) {
        var h,
            f = g(Math.floor(b / a) * a);
        c = g(Math.ceil(c / a) * a);
        var y = [],
            d;
        g(f + a) === f && (d = 20);
        if (this.single) return [b];

        for (b = f; b <= c;) {
          y.push(b);
          b = g(b + a, d);
          if (b === h) break;
          h = b;
        }

        return y;
      },
      getMinorTickInterval: function getMinorTickInterval() {
        var a = this.options;
        return !0 === a.minorTicks ? w(a.minorTickInterval, "auto") : !1 === a.minorTicks ? null : a.minorTickInterval;
      },
      getMinorTickPositions: function getMinorTickPositions() {
        var a = this,
            b = a.options,
            c = a.tickPositions,
            k = a.minorTickInterval,
            f = [],
            d = a.pointRangePadding || 0,
            p = a.min - d,
            d = a.max + d,
            n = d - p;
        if (n && n / k < a.len / 3) if (a.isLog) l(this.paddedTicks, function (b, h, c) {
          h && f.push.apply(f, a.getLogTickPositions(k, c[h - 1], c[h], !0));
        });else if (a.isDatetimeAxis && "auto" === this.getMinorTickInterval()) f = f.concat(a.getTimeTicks(a.normalizeTimeTickInterval(k), p, d, b.startOfWeek));else for (b = p + (c[0] - p) % k; b <= d && b !== f[0]; b += k) {
          f.push(b);
        }
        0 !== f.length && a.trimTicks(f);
        return f;
      },
      adjustForMinRange: function adjustForMinRange() {
        var a = this.options,
            b = this.min,
            f = this.max,
            k,
            c,
            d,
            p,
            n,
            e,
            q,
            z;
        this.isXAxis && void 0 === this.minRange && !this.isLog && (v(a.min) || v(a.max) ? this.minRange = null : (l(this.series, function (a) {
          e = a.xData;

          for (p = q = a.xIncrement ? 1 : e.length - 1; 0 < p; p--) {
            if (n = e[p] - e[p - 1], void 0 === d || n < d) d = n;
          }
        }), this.minRange = Math.min(5 * d, this.dataMax - this.dataMin)));
        f - b < this.minRange && (c = this.dataMax - this.dataMin >= this.minRange, z = this.minRange, k = (z - f + b) / 2, k = [b - k, w(a.min, b - k)], c && (k[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = E(k), f = [b + z, w(a.max, b + z)], c && (f[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), f = m(f), f - b < z && (k[0] = f - z, k[1] = w(a.min, f - z), b = E(k)));
        this.min = b;
        this.max = f;
      },
      getClosest: function getClosest() {
        var a;
        this.categories ? a = 1 : l(this.series, function (b) {
          var h = b.closestPointRange,
              k = b.visible || !b.chart.options.chart.ignoreHiddenSeries;
          !b.noSharedTooltip && v(h) && k && (a = v(a) ? Math.min(a, h) : h);
        });
        return a;
      },
      nameToX: function nameToX(a) {
        var h = f(this.categories),
            c = h ? this.categories : this.names,
            k = a.options.x,
            d;
        a.series.requireSorting = !1;
        v(k) || (k = !1 === this.options.uniqueNames ? a.series.autoIncrement() : h ? b(a.name, c) : w(c.keys[a.name], -1));
        -1 === k ? h || (d = c.length) : d = k;
        void 0 !== d && (this.names[d] = a.name, this.names.keys[a.name] = d);
        return d;
      },
      updateNames: function updateNames() {
        var b = this,
            f = this.names;
        0 < f.length && (l(a.keys(f.keys), function (a) {
          delete f.keys[a];
        }), f.length = 0, this.minRange = this.userMinRange, l(this.series || [], function (a) {
          a.xIncrement = null;
          if (!a.points || a.isDirtyData) a.processData(), a.generatePoints();
          l(a.points, function (k, h) {
            var f;
            k.options && (f = b.nameToX(k), void 0 !== f && f !== k.x && (k.x = f, a.xData[h] = f));
          });
        }));
      },
      setAxisTranslation: function setAxisTranslation(a) {
        var b = this,
            h = b.max - b.min,
            k = b.axisPointRange || 0,
            f,
            d = 0,
            p = 0,
            n = b.linkedParent,
            e = !!b.categories,
            q = b.transA,
            z = b.isXAxis;
        if (z || e || k) f = b.getClosest(), n ? (d = n.minPointOffset, p = n.pointRangePadding) : l(b.series, function (a) {
          var h = e ? 1 : z ? w(a.options.pointRange, f, 0) : b.axisPointRange || 0;
          a = a.options.pointPlacement;
          k = Math.max(k, h);
          b.single || (d = Math.max(d, G(a) ? 0 : h / 2), p = Math.max(p, "on" === a ? 0 : h));
        }), n = b.ordinalSlope && f ? b.ordinalSlope / f : 1, b.minPointOffset = d *= n, b.pointRangePadding = p *= n, b.pointRange = Math.min(k, h), z && (b.closestPointRange = f);
        a && (b.oldTransA = q);
        b.translationSlope = b.transA = q = b.options.staticScale || b.len / (h + p || 1);
        b.transB = b.horiz ? b.left : b.bottom;
        b.minPixelPadding = q * d;
        c(this, "afterSetAxisTranslation");
      },
      minFromRange: function minFromRange() {
        return this.max - this.range;
      },
      setTickInterval: function setTickInterval(b) {
        var h = this,
            f = h.chart,
            k = h.options,
            d = h.isLog,
            p = h.isDatetimeAxis,
            n = h.isXAxis,
            e = h.isLinked,
            z = k.maxPadding,
            D = k.minPadding,
            x = k.tickInterval,
            G = k.tickPixelInterval,
            F = h.categories,
            H = q(h.threshold) ? h.threshold : null,
            m = h.softThreshold,
            u,
            M,
            t,
            J;
        p || F || e || this.getTickAmount();
        t = w(h.userMin, k.min);
        J = w(h.userMax, k.max);
        e ? (h.linkedParent = f[h.coll][k.linkedTo], f = h.linkedParent.getExtremes(), h.min = w(f.min, f.dataMin), h.max = w(f.max, f.dataMax), k.type !== h.linkedParent.options.type && a.error(11, 1)) : (!m && v(H) && (h.dataMin >= H ? (u = H, D = 0) : h.dataMax <= H && (M = H, z = 0)), h.min = w(t, u, h.dataMin), h.max = w(J, M, h.dataMax));
        d && (h.positiveValuesOnly && !b && 0 >= Math.min(h.min, w(h.dataMin, h.min)) && a.error(10, 1), h.min = g(h.log2lin(h.min), 15), h.max = g(h.log2lin(h.max), 15));
        h.range && v(h.max) && (h.userMin = h.min = t = Math.max(h.dataMin, h.minFromRange()), h.userMax = J = h.max, h.range = null);
        c(h, "foundExtremes");
        h.beforePadding && h.beforePadding();
        h.adjustForMinRange();
        !(F || h.axisPointRange || h.usePercentage || e) && v(h.min) && v(h.max) && (f = h.max - h.min) && (!v(t) && D && (h.min -= f * D), !v(J) && z && (h.max += f * z));
        q(k.softMin) && !q(h.userMin) && (h.min = Math.min(h.min, k.softMin));
        q(k.softMax) && !q(h.userMax) && (h.max = Math.max(h.max, k.softMax));
        q(k.floor) && (h.min = Math.max(h.min, k.floor));
        q(k.ceiling) && (h.max = Math.min(h.max, k.ceiling));
        m && v(h.dataMin) && (H = H || 0, !v(t) && h.min < H && h.dataMin >= H ? h.min = H : !v(J) && h.max > H && h.dataMax <= H && (h.max = H));
        h.tickInterval = h.min === h.max || void 0 === h.min || void 0 === h.max ? 1 : e && !x && G === h.linkedParent.options.tickPixelInterval ? x = h.linkedParent.tickInterval : w(x, this.tickAmount ? (h.max - h.min) / Math.max(this.tickAmount - 1, 1) : void 0, F ? 1 : (h.max - h.min) * G / Math.max(h.len, G));
        n && !b && l(h.series, function (a) {
          a.processData(h.min !== h.oldMin || h.max !== h.oldMax);
        });
        h.setAxisTranslation(!0);
        h.beforeSetTickPositions && h.beforeSetTickPositions();
        h.postProcessTickInterval && (h.tickInterval = h.postProcessTickInterval(h.tickInterval));
        h.pointRange && !x && (h.tickInterval = Math.max(h.pointRange, h.tickInterval));
        b = w(k.minTickInterval, h.isDatetimeAxis && h.closestPointRange);
        !x && h.tickInterval < b && (h.tickInterval = b);
        p || d || x || (h.tickInterval = B(h.tickInterval, null, r(h.tickInterval), w(k.allowDecimals, !(.5 < h.tickInterval && 5 > h.tickInterval && 1E3 < h.max && 9999 > h.max)), !!this.tickAmount));
        this.tickAmount || (h.tickInterval = h.unsquish());
        this.setTickPositions();
      },
      setTickPositions: function setTickPositions() {
        var a = this.options,
            b,
            f = a.tickPositions;
        b = this.getMinorTickInterval();
        var k = a.tickPositioner,
            d = a.startOnTick,
            p = a.endOnTick;
        this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
        this.minorTickInterval = "auto" === b && this.tickInterval ? this.tickInterval / 5 : b;
        this.single = this.min === this.max && v(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);
        this.tickPositions = b = f && f.slice();
        !b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()], b[0] === b[1] && (b.length = 1)), this.tickPositions = b, k && (k = k.apply(this, [this.min, this.max]))) && (this.tickPositions = b = k);
        this.paddedTicks = b.slice(0);
        this.trimTicks(b, d, p);
        this.isLinked || (this.single && 2 > b.length && (this.min -= .5, this.max += .5), f || k || this.adjustTickAmount());
        c(this, "afterSetTickPositions");
      },
      trimTicks: function trimTicks(a, b, f) {
        var h = a[0],
            c = a[a.length - 1],
            d = this.minPointOffset || 0;

        if (!this.isLinked) {
          if (b && -Infinity !== h) this.min = h;else for (; this.min - d > a[0];) {
            a.shift();
          }
          if (f) this.max = c;else for (; this.max + d < a[a.length - 1];) {
            a.pop();
          }
          0 === a.length && v(h) && !this.options.tickPositions && a.push((c + h) / 2);
        }
      },
      alignToOthers: function alignToOthers() {
        var a = {},
            b,
            f = this.options;
        !1 === this.chart.options.chart.alignTicks || !1 === f.alignTicks || !1 === f.startOnTick || !1 === f.endOnTick || this.isLog || l(this.chart[this.coll], function (h) {
          var k = h.options,
              k = [h.horiz ? k.left : k.top, k.width, k.height, k.pane].join();
          h.series.length && (a[k] ? b = !0 : a[k] = 1);
        });
        return b;
      },
      getTickAmount: function getTickAmount() {
        var a = this.options,
            b = a.tickAmount,
            f = a.tickPixelInterval;
        !v(a.tickInterval) && this.len < f && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);
        !b && this.alignToOthers() && (b = Math.ceil(this.len / f) + 1);
        4 > b && (this.finalTickAmt = b, b = 5);
        this.tickAmount = b;
      },
      adjustTickAmount: function adjustTickAmount() {
        var a = this.tickInterval,
            b = this.tickPositions,
            f = this.tickAmount,
            k = this.finalTickAmt,
            c = b && b.length,
            d = w(this.threshold, this.softThreshold ? 0 : null);

        if (this.hasData()) {
          if (c < f) {
            for (; b.length < f;) {
              b.length % 2 || this.min === d ? b.push(g(b[b.length - 1] + a)) : b.unshift(g(b[0] - a));
            }

            this.transA *= (c - 1) / (f - 1);
            this.min = b[0];
            this.max = b[b.length - 1];
          } else c > f && (this.tickInterval *= 2, this.setTickPositions());

          if (v(k)) {
            for (a = f = b.length; a--;) {
              (3 === k && 1 === a % 2 || 2 >= k && 0 < a && a < f - 1) && b.splice(a, 1);
            }

            this.finalTickAmt = void 0;
          }
        }
      },
      setScale: function setScale() {
        var a, b;
        this.oldMin = this.min;
        this.oldMax = this.max;
        this.oldAxisLength = this.len;
        this.setAxisSize();
        b = this.len !== this.oldAxisLength;
        l(this.series, function (b) {
          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;
        });
        b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
        c(this, "afterSetScale");
      },
      setExtremes: function setExtremes(a, b, f, k, p) {
        var h = this,
            n = h.chart;
        f = w(f, !0);
        l(h.series, function (a) {
          delete a.kdTree;
        });
        p = d(p, {
          min: a,
          max: b
        });
        c(h, "setExtremes", p, function () {
          h.userMin = a;
          h.userMax = b;
          h.eventArgs = p;
          f && n.redraw(k);
        });
      },
      zoom: function zoom(a, b) {
        var h = this.dataMin,
            k = this.dataMax,
            f = this.options,
            c = Math.min(h, w(f.min, h)),
            f = Math.max(k, w(f.max, k));
        if (a !== this.min || b !== this.max) this.allowZoomOutside || (v(h) && (a < c && (a = c), a > f && (a = f)), v(k) && (b < c && (b = c), b > f && (b = f))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, {
          trigger: "zoom"
        });
        return !0;
      },
      setAxisSize: function setAxisSize() {
        var b = this.chart,
            f = this.options,
            c = f.offsets || [0, 0, 0, 0],
            k = this.horiz,
            d = this.width = Math.round(a.relativeLength(w(f.width, b.plotWidth - c[3] + c[1]), b.plotWidth)),
            p = this.height = Math.round(a.relativeLength(w(f.height, b.plotHeight - c[0] + c[2]), b.plotHeight)),
            n = this.top = Math.round(a.relativeLength(w(f.top, b.plotTop + c[0]), b.plotHeight, b.plotTop)),
            f = this.left = Math.round(a.relativeLength(w(f.left, b.plotLeft + c[3]), b.plotWidth, b.plotLeft));
        this.bottom = b.chartHeight - p - n;
        this.right = b.chartWidth - d - f;
        this.len = Math.max(k ? d : p, 0);
        this.pos = k ? f : n;
      },
      getExtremes: function getExtremes() {
        var a = this.isLog;
        return {
          min: a ? g(this.lin2log(this.min)) : this.min,
          max: a ? g(this.lin2log(this.max)) : this.max,
          dataMin: this.dataMin,
          dataMax: this.dataMax,
          userMin: this.userMin,
          userMax: this.userMax
        };
      },
      getThreshold: function getThreshold(a) {
        var b = this.isLog,
            h = b ? this.lin2log(this.min) : this.min,
            b = b ? this.lin2log(this.max) : this.max;
        null === a || -Infinity === a ? a = h : Infinity === a ? a = b : h > a ? a = h : b < a && (a = b);
        return this.translate(a, 0, 1, 0, 1);
      },
      autoLabelAlign: function autoLabelAlign(a) {
        a = (w(a, 0) - 90 * this.side + 720) % 360;
        return 15 < a && 165 > a ? "right" : 195 < a && 345 > a ? "left" : "center";
      },
      tickSize: function tickSize(a) {
        var b = this.options,
            h = b[a + "Length"],
            k = w(b[a + "Width"], "tick" === a && this.isXAxis ? 1 : 0);
        if (k && h) return "inside" === b[a + "Position"] && (h = -h), [h, k];
      },
      labelMetrics: function labelMetrics() {
        var a = this.tickPositions && this.tickPositions[0] || 0;
        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);
      },
      unsquish: function unsquish() {
        var a = this.options.labels,
            b = this.horiz,
            f = this.tickInterval,
            k = f,
            c = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / f),
            d,
            p = a.rotation,
            n = this.labelMetrics(),
            e,
            q = Number.MAX_VALUE,
            z,
            D = function D(a) {
          a /= c || 1;
          a = 1 < a ? Math.ceil(a) : 1;
          return g(a * f);
        };

        b ? (z = !a.staggerLines && !a.step && (v(p) ? [p] : c < w(a.autoRotationLimit, 80) && a.autoRotation)) && l(z, function (a) {
          var b;
          if (a === p || a && -90 <= a && 90 >= a) e = D(Math.abs(n.h / Math.sin(u * a))), b = e + Math.abs(a / 360), b < q && (q = b, d = a, k = e);
        }) : a.step || (k = D(n.h));
        this.autoRotation = z;
        this.labelRotation = w(d, p);
        return k;
      },
      getSlotWidth: function getSlotWidth() {
        var a = this.chart,
            b = this.horiz,
            f = this.options.labels,
            k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
            c = a.margin[3];
        return b && 2 > (f.step || 0) && !f.rotation && (this.staggerLines || 1) * this.len / k || !b && (f.style && parseInt(f.style.width, 10) || c && c - a.spacing[3] || .33 * a.chartWidth);
      },
      renderUnsquish: function renderUnsquish() {
        var a = this.chart,
            b = a.renderer,
            f = this.tickPositions,
            k = this.ticks,
            c = this.options.labels,
            d = c && c.style || {},
            p = this.horiz,
            n = this.getSlotWidth(),
            e = Math.max(1, Math.round(n - 2 * (c.padding || 5))),
            q = {},
            z = this.labelMetrics(),
            g = c.style && c.style.textOverflow,
            w,
            D,
            r = 0,
            B;
        G(c.rotation) || (q.rotation = c.rotation || 0);
        l(f, function (a) {
          (a = k[a]) && a.label && a.label.textPxLength > r && (r = a.label.textPxLength);
        });
        this.maxLabelLength = r;
        if (this.autoRotation) r > e && r > z.h ? q.rotation = this.labelRotation : this.labelRotation = 0;else if (n && (w = e, !g)) for (D = "clip", e = f.length; !p && e--;) {
          if (B = f[e], B = k[B].label) B.styles && "ellipsis" === B.styles.textOverflow ? B.css({
            textOverflow: "clip"
          }) : B.textPxLength > n && B.css({
            width: n + "px"
          }), B.getBBox().height > this.len / f.length - (z.h - z.f) && (B.specificTextOverflow = "ellipsis");
        }
        q.rotation && (w = r > .5 * a.chartHeight ? .33 * a.chartHeight : r, g || (D = "ellipsis"));
        if (this.labelAlign = c.align || this.autoLabelAlign(this.labelRotation)) q.align = this.labelAlign;
        l(f, function (a) {
          var b = (a = k[a]) && a.label,
              h = d.width,
              f = {};
          b && (b.attr(q), w && !h && "nowrap" !== d.whiteSpace && (w < b.textPxLength || "SPAN" === b.element.tagName) ? (f.width = w, g || (f.textOverflow = b.specificTextOverflow || D), b.css(f)) : b.styles && b.styles.width && !f.width && !h && b.css({
            width: null
          }), delete b.specificTextOverflow, a.rotation = q.rotation);
        });
        this.tickRotCorr = b.rotCorr(z.b, this.labelRotation || 0, 0 !== this.side);
      },
      hasData: function hasData() {
        return this.hasVisibleSeries || v(this.min) && v(this.max) && this.tickPositions && 0 < this.tickPositions.length;
      },
      addTitle: function addTitle(a) {
        var b = this.chart.renderer,
            h = this.horiz,
            f = this.opposite,
            c = this.options.title,
            d;
        this.axisTitle || ((d = c.textAlign) || (d = (h ? {
          low: "left",
          middle: "center",
          high: "right"
        } : {
          low: f ? "right" : "left",
          middle: "center",
          high: f ? "left" : "right"
        })[c.align]), this.axisTitle = b.text(c.text, 0, 0, c.useHTML).attr({
          zIndex: 7,
          rotation: c.rotation || 0,
          align: d
        }).addClass("highcharts-axis-title").add(this.axisGroup), this.axisTitle.isNew = !0);
        this.axisTitle.css({
          width: this.len
        });
        this.axisTitle[a ? "show" : "hide"](!0);
      },
      generateTick: function generateTick(a) {
        var b = this.ticks;
        b[a] ? b[a].addLabel() : b[a] = new F(this, a);
      },
      getOffset: function getOffset() {
        var a = this,
            b = a.chart,
            f = b.renderer,
            k = a.options,
            d = a.tickPositions,
            p = a.ticks,
            n = a.horiz,
            e = a.side,
            q = b.inverted && !a.isZAxis ? [1, 0, 3, 2][e] : e,
            z,
            g,
            D = 0,
            r,
            B = 0,
            x = k.title,
            G = k.labels,
            F = 0,
            m = b.axisOffset,
            b = b.clipOffset,
            u = [-1, 1, 1, -1][e],
            M = k.className,
            t = a.axisParent,
            J = this.tickSize("tick");
        z = a.hasData();
        a.showAxis = g = z || w(k.showEmpty, !0);
        a.staggerLines = a.horiz && G.staggerLines;
        a.axisGroup || (a.gridGroup = f.g("grid").attr({
          zIndex: k.gridZIndex || 1
        }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (M || "")).add(t), a.axisGroup = f.g("axis").attr({
          zIndex: k.zIndex || 2
        }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (M || "")).add(t), a.labelGroup = f.g("axis-labels").attr({
          zIndex: G.zIndex || 7
        }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (M || "")).add(t));
        z || a.isLinked ? (l(d, function (b, f) {
          a.generateTick(b, f);
        }), a.renderUnsquish(), a.reserveSpaceDefault = 0 === e || 2 === e || {
          1: "left",
          3: "right"
        }[e] === a.labelAlign, w(G.reserveSpace, "center" === a.labelAlign ? !0 : null, a.reserveSpaceDefault) && l(d, function (a) {
          F = Math.max(p[a].getLabelSize(), F);
        }), a.staggerLines && (F *= a.staggerLines), a.labelOffset = F * (a.opposite ? -1 : 1)) : H(p, function (a, b) {
          a.destroy();
          delete p[b];
        });
        x && x.text && !1 !== x.enabled && (a.addTitle(g), g && !1 !== x.reserveSpace && (a.titleOffset = D = a.axisTitle.getBBox()[n ? "height" : "width"], r = x.offset, B = v(r) ? 0 : w(x.margin, n ? 5 : 10)));
        a.renderLine();
        a.offset = u * w(k.offset, m[e]);
        a.tickRotCorr = a.tickRotCorr || {
          x: 0,
          y: 0
        };
        f = 0 === e ? -a.labelMetrics().h : 2 === e ? a.tickRotCorr.y : 0;
        B = Math.abs(F) + B;
        F && (B = B - f + u * (n ? w(G.y, a.tickRotCorr.y + 8 * u) : G.x));
        a.axisTitleMargin = w(r, B);
        m[e] = Math.max(m[e], a.axisTitleMargin + D + u * a.offset, B, z && d.length && J ? J[0] + u * a.offset : 0);
        k = k.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);
        b[q] = Math.max(b[q], k);
        c(this, "afterGetOffset");
      },
      getLinePath: function getLinePath(a) {
        var b = this.chart,
            f = this.opposite,
            k = this.offset,
            h = this.horiz,
            c = this.left + (f ? this.width : 0) + k,
            k = b.chartHeight - this.bottom - (f ? this.height : 0) + k;
        f && (a *= -1);
        return b.renderer.crispLine(["M", h ? this.left : c, h ? k : this.top, "L", h ? b.chartWidth - this.right : c, h ? k : b.chartHeight - this.bottom], a);
      },
      renderLine: function renderLine() {
        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup));
      },
      getTitlePosition: function getTitlePosition() {
        var a = this.horiz,
            b = this.left,
            f = this.top,
            k = this.len,
            c = this.options.title,
            d = a ? b : f,
            p = this.opposite,
            n = this.offset,
            e = c.x || 0,
            q = c.y || 0,
            z = this.axisTitle,
            g = this.chart.renderer.fontMetrics(c.style && c.style.fontSize, z),
            z = Math.max(z.getBBox(null, 0).height - g.h - 1, 0),
            k = {
          low: d + (a ? 0 : k),
          middle: d + k / 2,
          high: d + (a ? k : 0)
        }[c.align],
            b = (a ? f + this.height : b) + (a ? 1 : -1) * (p ? -1 : 1) * this.axisTitleMargin + [-z, z, g.f, -z][this.side];
        return {
          x: a ? k + e : b + (p ? this.width : 0) + n + e,
          y: a ? b + q - (p ? this.height : 0) + n : k + q
        };
      },
      renderMinorTick: function renderMinorTick(a) {
        var b = this.chart.hasRendered && q(this.oldMin),
            f = this.minorTicks;
        f[a] || (f[a] = new F(this, a, "minor"));
        b && f[a].isNew && f[a].render(null, !0);
        f[a].render(null, !1, 1);
      },
      renderTick: function renderTick(a, b) {
        var f = this.isLinked,
            k = this.ticks,
            h = this.chart.hasRendered && q(this.oldMin);
        if (!f || a >= this.min && a <= this.max) k[a] || (k[a] = new F(this, a)), h && k[a].isNew && k[a].render(b, !0, .1), k[a].render(b);
      },
      render: function render() {
        var b = this,
            f = b.chart,
            d = b.options,
            k = b.isLog,
            p = b.isLinked,
            n = b.tickPositions,
            e = b.axisTitle,
            g = b.ticks,
            w = b.minorTicks,
            D = b.alternateBands,
            r = d.stackLabels,
            B = d.alternateGridColor,
            x = b.tickmarkOffset,
            G = b.axisLine,
            m = b.showAxis,
            u = C(f.renderer.globalAnimation),
            v,
            M;
        b.labelEdge.length = 0;
        b.overlap = !1;
        l([g, w, D], function (a) {
          H(a, function (a) {
            a.isActive = !1;
          });
        });
        if (b.hasData() || p) b.minorTickInterval && !b.categories && l(b.getMinorTickPositions(), function (a) {
          b.renderMinorTick(a);
        }), n.length && (l(n, function (a, f) {
          b.renderTick(a, f);
        }), x && (0 === b.min || b.single) && (g[-1] || (g[-1] = new F(b, -1, null, !0)), g[-1].render(-1))), B && l(n, function (c, h) {
          M = void 0 !== n[h + 1] ? n[h + 1] + x : b.max - x;
          0 === h % 2 && c < b.max && M <= b.max + (f.polar ? -x : x) && (D[c] || (D[c] = new a.PlotLineOrBand(b)), v = c + x, D[c].options = {
            from: k ? b.lin2log(v) : v,
            to: k ? b.lin2log(M) : M,
            color: B
          }, D[c].render(), D[c].isActive = !0);
        }), b._addedPlotLB || (l((d.plotLines || []).concat(d.plotBands || []), function (a) {
          b.addPlotBandOrLine(a);
        }), b._addedPlotLB = !0);
        l([g, w, D], function (a) {
          var b,
              k = [],
              c = u.duration;
          H(a, function (a, b) {
            a.isActive || (a.render(b, !1, 0), a.isActive = !1, k.push(b));
          });
          z(function () {
            for (b = k.length; b--;) {
              a[k[b]] && !a[k[b]].isActive && (a[k[b]].destroy(), delete a[k[b]]);
            }
          }, a !== D && f.hasRendered && c ? c : 0);
        });
        G && (G[G.isPlaced ? "animate" : "attr"]({
          d: this.getLinePath(G.strokeWidth())
        }), G.isPlaced = !0, G[m ? "show" : "hide"](!0));
        e && m && (d = b.getTitlePosition(), q(d.y) ? (e[e.isNew ? "attr" : "animate"](d), e.isNew = !1) : (e.attr("y", -9999), e.isNew = !0));
        r && r.enabled && b.renderStackTotals();
        b.isDirty = !1;
        c(this, "afterRender");
      },
      redraw: function redraw() {
        this.visible && (this.render(), l(this.plotLinesAndBands, function (a) {
          a.render();
        }));
        l(this.series, function (a) {
          a.isDirty = !0;
        });
      },
      keepProps: "extKey hcEvents names series userMax userMin".split(" "),
      destroy: function destroy(a) {
        var f = this,
            h = f.stacks,
            k = f.plotLinesAndBands,
            d;
        c(this, "destroy", {
          keepEvents: a
        });
        a || p(f);
        H(h, function (a, b) {
          t(a);
          h[b] = null;
        });
        l([f.ticks, f.minorTicks, f.alternateBands], function (a) {
          t(a);
        });
        if (k) for (a = k.length; a--;) {
          k[a].destroy();
        }
        l("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" "), function (a) {
          f[a] && (f[a] = f[a].destroy());
        });

        for (d in f.plotLinesAndBandsGroups) {
          f.plotLinesAndBandsGroups[d] = f.plotLinesAndBandsGroups[d].destroy();
        }

        H(f, function (a, k) {
          -1 === b(k, f.keepProps) && delete f[k];
        });
      },
      drawCrosshair: function drawCrosshair(a, b) {
        var f,
            k = this.crosshair,
            h = w(k.snap, !0),
            d,
            p = this.cross;
        c(this, "drawCrosshair", {
          e: a,
          point: b
        });
        a || (a = this.cross && this.cross.e);

        if (this.crosshair && !1 !== (v(b) || !h)) {
          h ? v(b) && (d = w(b.crosshairPos, this.isXAxis ? b.plotX : this.len - b.plotY)) : d = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);
          v(d) && (f = this.getPlotLinePath(b && (this.isXAxis ? b.x : w(b.stackY, b.y)), null, null, null, d) || null);

          if (!v(f)) {
            this.hideCrosshair();
            return;
          }

          h = this.categories && !this.isRadial;
          p || (this.cross = p = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (h ? "category " : "thin ") + k.className).attr({
            zIndex: w(k.zIndex, 2)
          }).add());
          p.show().attr({
            d: f
          });
          h && !k.width && p.attr({
            "stroke-width": this.transA
          });
          this.cross.e = a;
        } else this.hideCrosshair();

        c(this, "afterDrawCrosshair", {
          e: a,
          point: b
        });
      },
      hideCrosshair: function hideCrosshair() {
        this.cross && this.cross.hide();
      }
    });
    return a.Axis = M;
  }(K);

  (function (a) {
    var A = a.Axis,
        C = a.getMagnitude,
        E = a.normalizeTickInterval,
        m = a.timeUnits;

    A.prototype.getTimeTicks = function () {
      return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
    };

    A.prototype.normalizeTimeTickInterval = function (a, e) {
      var g = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
      e = g[g.length - 1];
      var u = m[e[0]],
          t = e[1],
          l;

      for (l = 0; l < g.length && !(e = g[l], u = m[e[0]], t = e[1], g[l + 1] && a <= (u * t[t.length - 1] + m[g[l + 1][0]]) / 2); l++) {
        ;
      }

      u === m.year && a < 5 * u && (t = [1, 2, 5]);
      a = E(a / u, t, "year" === e[0] ? Math.max(C(a / u), 1) : 1);
      return {
        unitRange: u,
        count: a,
        unitName: e[0]
      };
    };
  })(K);

  (function (a) {
    var A = a.Axis,
        C = a.getMagnitude,
        E = a.map,
        m = a.normalizeTickInterval,
        g = a.pick;

    A.prototype.getLogTickPositions = function (a, v, u, t) {
      var e = this.options,
          d = this.len,
          c = [];
      t || (this._minorAutoInterval = null);
      if (.5 <= a) a = Math.round(a), c = this.getLinearTickPositions(a, v, u);else if (.08 <= a) for (var d = Math.floor(v), x, r, n, b, f, e = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; d < u + 1 && !f; d++) {
        for (r = e.length, x = 0; x < r && !f; x++) {
          n = this.log2lin(this.lin2log(d) * e[x]), n > v && (!t || b <= u) && void 0 !== b && c.push(b), b > u && (f = !0), b = n;
        }
      } else v = this.lin2log(v), u = this.lin2log(u), a = t ? this.getMinorTickInterval() : e.tickInterval, a = g("auto" === a ? null : a, this._minorAutoInterval, e.tickPixelInterval / (t ? 5 : 1) * (u - v) / ((t ? d / this.tickPositions.length : d) || 1)), a = m(a, null, C(a)), c = E(this.getLinearTickPositions(a, v, u), this.log2lin), t || (this._minorAutoInterval = a / 5);
      t || (this.tickInterval = a);
      return c;
    };

    A.prototype.log2lin = function (a) {
      return Math.log(a) / Math.LN10;
    };

    A.prototype.lin2log = function (a) {
      return Math.pow(10, a);
    };
  })(K);

  (function (a, A) {
    var C = a.arrayMax,
        E = a.arrayMin,
        m = a.defined,
        g = a.destroyObjectProperties,
        e = a.each,
        v = a.erase,
        u = a.merge,
        t = a.pick;

    a.PlotLineOrBand = function (a, d) {
      this.axis = a;
      d && (this.options = d, this.id = d.id);
    };

    a.PlotLineOrBand.prototype = {
      render: function render() {
        var e = this,
            d = e.axis,
            c = d.horiz,
            g = e.options,
            r = g.label,
            n = e.label,
            b = g.to,
            f = g.from,
            q = g.value,
            G = m(f) && m(b),
            v = m(q),
            B = e.svgElem,
            H = !B,
            w = [],
            p = t(g.zIndex, 0),
            D = g.events,
            w = {
          "class": "highcharts-plot-" + (G ? "band " : "line ") + (g.className || "")
        },
            z = {},
            F = d.chart.renderer,
            M = G ? "bands" : "lines",
            h;
        d.isLog && (f = d.log2lin(f), b = d.log2lin(b), q = d.log2lin(q));
        z.zIndex = p;
        M += "-" + p;
        (h = d.plotLinesAndBandsGroups[M]) || (d.plotLinesAndBandsGroups[M] = h = F.g("plot-" + M).attr(z).add());
        H && (e.svgElem = B = F.path().attr(w).add(h));
        if (v) w = d.getPlotLinePath(q, B.strokeWidth());else if (G) w = d.getPlotBandPath(f, b, g);else return;
        H && w && w.length ? (B.attr({
          d: w
        }), D && a.objectEach(D, function (a, b) {
          B.on(b, function (a) {
            D[b].apply(e, [a]);
          });
        })) : B && (w ? (B.show(), B.animate({
          d: w
        })) : (B.hide(), n && (e.label = n = n.destroy())));
        r && m(r.text) && w && w.length && 0 < d.width && 0 < d.height && !w.isFlat ? (r = u({
          align: c && G && "center",
          x: c ? !G && 4 : 10,
          verticalAlign: !c && G && "middle",
          y: c ? G ? 16 : 10 : G ? 6 : -4,
          rotation: c && !G && 90
        }, r), this.renderLabel(r, w, G, p)) : n && n.hide();
        return e;
      },
      renderLabel: function renderLabel(a, d, c, e) {
        var g = this.label,
            n = this.axis.chart.renderer;
        g || (g = {
          align: a.textAlign || a.align,
          rotation: a.rotation,
          "class": "highcharts-plot-" + (c ? "band" : "line") + "-label " + (a.className || "")
        }, g.zIndex = e, this.label = g = n.text(a.text, 0, 0, a.useHTML).attr(g).add());
        e = d.xBounds || [d[1], d[4], c ? d[6] : d[1]];
        d = d.yBounds || [d[2], d[5], c ? d[7] : d[2]];
        c = E(e);
        n = E(d);
        g.align(a, !1, {
          x: c,
          y: n,
          width: C(e) - c,
          height: C(d) - n
        });
        g.show();
      },
      destroy: function destroy() {
        v(this.axis.plotLinesAndBands, this);
        delete this.axis;
        g(this);
      }
    };
    a.extend(A.prototype, {
      getPlotBandPath: function getPlotBandPath(a, d) {
        var c = this.getPlotLinePath(d, null, null, !0),
            e = this.getPlotLinePath(a, null, null, !0),
            g = [],
            n = this.horiz,
            b = 1,
            f;
        a = a < this.min && d < this.min || a > this.max && d > this.max;
        if (e && c) for (a && (f = e.toString() === c.toString(), b = 0), a = 0; a < e.length; a += 6) {
          n && c[a + 1] === e[a + 1] ? (c[a + 1] += b, c[a + 4] += b) : n || c[a + 2] !== e[a + 2] || (c[a + 2] += b, c[a + 5] += b), g.push("M", e[a + 1], e[a + 2], "L", e[a + 4], e[a + 5], c[a + 4], c[a + 5], c[a + 1], c[a + 2], "z"), g.isFlat = f;
        }
        return g;
      },
      addPlotBand: function addPlotBand(a) {
        return this.addPlotBandOrLine(a, "plotBands");
      },
      addPlotLine: function addPlotLine(a) {
        return this.addPlotBandOrLine(a, "plotLines");
      },
      addPlotBandOrLine: function addPlotBandOrLine(e, d) {
        var c = new a.PlotLineOrBand(this, e).render(),
            g = this.userOptions;
        c && (d && (g[d] = g[d] || [], g[d].push(e)), this.plotLinesAndBands.push(c));
        return c;
      },
      removePlotBandOrLine: function removePlotBandOrLine(a) {
        for (var d = this.plotLinesAndBands, c = this.options, g = this.userOptions, r = d.length; r--;) {
          d[r].id === a && d[r].destroy();
        }

        e([c.plotLines || [], g.plotLines || [], c.plotBands || [], g.plotBands || []], function (c) {
          for (r = c.length; r--;) {
            c[r].id === a && v(c, c[r]);
          }
        });
      },
      removePlotBand: function removePlotBand(a) {
        this.removePlotBandOrLine(a);
      },
      removePlotLine: function removePlotLine(a) {
        this.removePlotBandOrLine(a);
      }
    });
  })(K, U);

  (function (a) {
    var A = a.doc,
        C = a.each,
        E = a.extend,
        m = a.format,
        g = a.isNumber,
        e = a.map,
        v = a.merge,
        u = a.pick,
        t = a.splat,
        l = a.syncTimeout,
        d = a.timeUnits;

    a.Tooltip = function () {
      this.init.apply(this, arguments);
    };

    a.Tooltip.prototype = {
      init: function init(a, d) {
        this.chart = a;
        this.options = d;
        this.crosshairs = [];
        this.now = {
          x: 0,
          y: 0
        };
        this.isHidden = !0;
        this.split = d.split && !a.inverted;
        this.shared = d.shared || this.split;
        this.outside = d.outside && !this.split;
      },
      cleanSplit: function cleanSplit(a) {
        C(this.chart.series, function (c) {
          var d = c && c.tt;
          d && (!d.isActive || a ? c.tt = d.destroy() : d.isActive = !1);
        });
      },
      applyFilter: function applyFilter() {
        var a = this.chart;
        a.renderer.definition({
          tagName: "filter",
          id: "drop-shadow-" + a.index,
          opacity: .5,
          children: [{
            tagName: "feGaussianBlur",
            in: "SourceAlpha",
            stdDeviation: 1
          }, {
            tagName: "feOffset",
            dx: 1,
            dy: 1
          }, {
            tagName: "feComponentTransfer",
            children: [{
              tagName: "feFuncA",
              type: "linear",
              slope: .3
            }]
          }, {
            tagName: "feMerge",
            children: [{
              tagName: "feMergeNode"
            }, {
              tagName: "feMergeNode",
              in: "SourceGraphic"
            }]
          }]
        });
        a.renderer.definition({
          tagName: "style",
          textContent: ".highcharts-tooltip-" + a.index + "{filter:url(#drop-shadow-" + a.index + ")}"
        });
      },
      getLabel: function getLabel() {
        var c = this.chart.renderer,
            d = this.options,
            e;
        this.label || (this.outside && (this.container = e = a.doc.createElement("div"), e.className = "highcharts-tooltip-container", a.css(e, {
          position: "absolute",
          top: "1px",
          pointerEvents: d.style && d.style.pointerEvents
        }), a.doc.body.appendChild(e), this.renderer = c = new a.Renderer(e, 0, 0)), this.label = this.split ? c.g("tooltip") : c.label("", 0, 0, d.shape || "callout", null, null, d.useHTML, null, "tooltip").attr({
          padding: d.padding,
          r: d.borderRadius
        }), this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index), this.outside && (this.label.attr({
          x: this.distance,
          y: this.distance
        }), this.label.xSetter = function (a) {
          e.style.left = a + "px";
        }, this.label.ySetter = function (a) {
          e.style.top = a + "px";
        }), this.label.attr({
          zIndex: 8
        }).add());
        return this.label;
      },
      update: function update(a) {
        this.destroy();
        v(!0, this.chart.options.tooltip.userOptions, a);
        this.init(this.chart, v(!0, this.options, a));
      },
      destroy: function destroy() {
        this.label && (this.label = this.label.destroy());
        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
        this.renderer && (this.renderer = this.renderer.destroy(), a.discardElement(this.container));
        a.clearTimeout(this.hideTimer);
        a.clearTimeout(this.tooltipTimeout);
      },
      move: function move(c, d, e, n) {
        var b = this,
            f = b.now,
            q = !1 !== b.options.animation && !b.isHidden && (1 < Math.abs(c - f.x) || 1 < Math.abs(d - f.y)),
            g = b.followPointer || 1 < b.len;
        E(f, {
          x: q ? (2 * f.x + c) / 3 : c,
          y: q ? (f.y + d) / 2 : d,
          anchorX: g ? void 0 : q ? (2 * f.anchorX + e) / 3 : e,
          anchorY: g ? void 0 : q ? (f.anchorY + n) / 2 : n
        });
        b.getLabel().attr(f);
        q && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
          b && b.move(c, d, e, n);
        }, 32));
      },
      hide: function hide(c) {
        var d = this;
        a.clearTimeout(this.hideTimer);
        c = u(c, this.options.hideDelay, 500);
        this.isHidden || (this.hideTimer = l(function () {
          d.getLabel()[c ? "fadeOut" : "hide"]();
          d.isHidden = !0;
        }, c));
      },
      getAnchor: function getAnchor(a, d) {
        var c = this.chart,
            n = c.pointer,
            b = c.inverted,
            f = c.plotTop,
            q = c.plotLeft,
            g = 0,
            l = 0,
            B,
            H;
        a = t(a);
        this.followPointer && d || n.followTouchMove && d && "touchmove" === d.type ? (void 0 === d.chartX && (d = n.normalize(d)), a = [d.chartX - c.plotLeft, d.chartY - f]) : a[0].tooltipPos ? a = a[0].tooltipPos : (C(a, function (a) {
          B = a.series.yAxis;
          H = a.series.xAxis;
          g += a.plotX + (!b && H ? H.left - q : 0);
          l += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!b && B ? B.top - f : 0);
        }), g /= a.length, l /= a.length, a = [b ? c.plotWidth - l : g, this.shared && !b && 1 < a.length && d ? d.chartY - f : b ? c.plotHeight - g : l]);
        return e(a, Math.round);
      },
      getPosition: function getPosition(a, d, e) {
        var c = this.chart,
            b = this.distance,
            f = {},
            q = c.inverted && e.h || 0,
            g,
            r = this.outside,
            B = r ? A.documentElement.clientWidth - 2 * b : c.chartWidth,
            l = r ? Math.max(A.body.scrollHeight, A.documentElement.scrollHeight, A.body.offsetHeight, A.documentElement.offsetHeight, A.documentElement.clientHeight) : c.chartHeight,
            w = c.pointer.chartPosition,
            p = ["y", l, d, (r ? w.top - b : 0) + e.plotY + c.plotTop, r ? 0 : c.plotTop, r ? l : c.plotTop + c.plotHeight],
            D = ["x", B, a, (r ? w.left - b : 0) + e.plotX + c.plotLeft, r ? 0 : c.plotLeft, r ? B : c.plotLeft + c.plotWidth],
            z = !this.followPointer && u(e.ttBelow, !c.inverted === !!e.negative),
            F = function F(a, k, c, h, d, p) {
          var e = c < h - b,
              n = h + b + c < k,
              g = h - b - c;
          h += b;
          if (z && n) f[a] = h;else if (!z && e) f[a] = g;else if (e) f[a] = Math.min(p - c, 0 > g - q ? g : g - q);else if (n) f[a] = Math.max(d, h + q + c > k ? h : h + q);else return !1;
        },
            x = function x(a, k, c, h) {
          var d;
          h < b || h > k - b ? d = !1 : f[a] = h < c / 2 ? 1 : h > k - c / 2 ? k - c - 2 : h - c / 2;
          return d;
        },
            h = function h(a) {
          var b = p;
          p = D;
          D = b;
          g = a;
        },
            y = function y() {
          !1 !== F.apply(0, p) ? !1 !== x.apply(0, D) || g || (h(!0), y()) : g ? f.x = f.y = 0 : (h(!0), y());
        };

        (c.inverted || 1 < this.len) && h();
        y();
        return f;
      },
      defaultFormatter: function defaultFormatter(a) {
        var c = this.points || t(this),
            d;
        d = [a.tooltipFooterHeaderFormatter(c[0])];
        d = d.concat(a.bodyFormatter(c));
        d.push(a.tooltipFooterHeaderFormatter(c[0], !0));
        return d;
      },
      refresh: function refresh(c, d) {
        var e,
            n = this.options,
            b = c,
            f,
            q = {},
            g = [];
        e = n.formatter || this.defaultFormatter;
        var q = this.shared,
            l;
        n.enabled && (a.clearTimeout(this.hideTimer), this.followPointer = t(b)[0].series.tooltipOptions.followPointer, f = this.getAnchor(b, d), d = f[0], n = f[1], !q || b.series && b.series.noSharedTooltip ? q = b.getLabelConfig() : (C(b, function (a) {
          a.setState("hover");
          g.push(a.getLabelConfig());
        }), q = {
          x: b[0].category,
          y: b[0].y
        }, q.points = g, b = b[0]), this.len = g.length, q = e.call(q, this), l = b.series, this.distance = u(l.tooltipOptions.distance, 16), !1 === q ? this.hide() : (e = this.getLabel(), this.isHidden && e.attr({
          opacity: 1
        }).show(), this.split ? this.renderSplit(q, t(c)) : (e.css({
          width: this.chart.spacingBox.width
        }), e.attr({
          text: q && q.join ? q.join("") : q
        }), e.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + u(b.colorIndex, l.colorIndex)), this.updatePosition({
          plotX: d,
          plotY: n,
          negative: b.negative,
          ttBelow: b.ttBelow,
          h: f[2] || 0
        })), this.isHidden = !1));
      },
      renderSplit: function renderSplit(c, d) {
        var e = this,
            n = [],
            b = this.chart,
            f = b.renderer,
            q = !0,
            g = this.options,
            l = 0,
            B = this.getLabel();
        a.isString(c) && (c = [!1, c]);
        C(c.slice(0, d.length + 1), function (a, c) {
          if (!1 !== a) {
            c = d[c - 1] || {
              isHeader: !0,
              plotX: d[0].plotX
            };
            var p = c.series || e,
                D = p.tt,
                z = "highcharts-color-" + u(c.colorIndex, (c.series || {}).colorIndex, "none");
            D || (p.tt = D = f.label(null, null, null, "callout", null, null, g.useHTML).addClass("highcharts-tooltip-box " + z).attr({
              padding: g.padding,
              r: g.borderRadius
            }).add(B));
            D.isActive = !0;
            D.attr({
              text: a
            });
            a = D.getBBox();
            z = a.width + D.strokeWidth();
            c.isHeader ? (l = a.height, z = Math.max(0, Math.min(c.plotX + b.plotLeft - z / 2, b.chartWidth - z))) : z = c.plotX + b.plotLeft - u(g.distance, 16) - z;
            0 > z && (q = !1);
            a = (c.series && c.series.yAxis && c.series.yAxis.pos) + (c.plotY || 0);
            a -= b.plotTop;
            n.push({
              target: c.isHeader ? b.plotHeight + l : a,
              rank: c.isHeader ? 1 : 0,
              size: p.tt.getBBox().height + 1,
              point: c,
              x: z,
              tt: D
            });
          }
        });
        this.cleanSplit();
        a.distribute(n, b.plotHeight + l);
        C(n, function (a) {
          var f = a.point,
              c = f.series;
          a.tt.attr({
            visibility: void 0 === a.pos ? "hidden" : "inherit",
            x: q || f.isHeader ? a.x : f.plotX + b.plotLeft + u(g.distance, 16),
            y: a.pos + b.plotTop,
            anchorX: f.isHeader ? f.plotX + b.plotLeft : f.plotX + c.xAxis.pos,
            anchorY: f.isHeader ? a.pos + b.plotTop - 15 : f.plotY + c.yAxis.pos
          });
        });
      },
      updatePosition: function updatePosition(a) {
        var c = this.chart,
            d = this.getLabel(),
            e = (this.options.positioner || this.getPosition).call(this, d.width, d.height, a),
            b = a.plotX + c.plotLeft;
        a = a.plotY + c.plotTop;
        var f;
        this.outside && (f = (this.options.borderWidth || 0) + 2 * this.distance, this.renderer.setSize(d.width + f, d.height + f, !1), b += c.pointer.chartPosition.left - e.x, a += c.pointer.chartPosition.top - e.y);
        this.move(Math.round(e.x), Math.round(e.y || 0), b, a);
      },
      getDateFormat: function getDateFormat(a, e, g, n) {
        var b = this.chart.time,
            f = b.dateFormat("%m-%d %H:%M:%S.%L", e),
            c,
            l,
            r = {
          millisecond: 15,
          second: 12,
          minute: 9,
          hour: 6,
          day: 3
        },
            B = "millisecond";

        for (l in d) {
          if (a === d.week && +b.dateFormat("%w", e) === g && "00:00:00.000" === f.substr(6)) {
            l = "week";
            break;
          }

          if (d[l] > a) {
            l = B;
            break;
          }

          if (r[l] && f.substr(r[l]) !== "01-01 00:00:00.000".substr(r[l])) break;
          "week" !== l && (B = l);
        }

        l && (c = n[l]);
        return c;
      },
      getXDateFormat: function getXDateFormat(a, d, e) {
        d = d.dateTimeLabelFormats;
        var c = e && e.closestPointRange;
        return (c ? this.getDateFormat(c, a.x, e.options.startOfWeek, d) : d.day) || d.year;
      },
      tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, d) {
        d = d ? "footer" : "header";
        var c = a.series,
            e = c.tooltipOptions,
            b = e.xDateFormat,
            f = c.xAxis,
            q = f && "datetime" === f.options.type && g(a.key),
            l = e[d + "Format"];
        q && !b && (b = this.getXDateFormat(a, e, f));
        q && b && C(a.point && a.point.tooltipDateKeys || ["key"], function (a) {
          l = l.replace("{point." + a + "}", "{point." + a + ":" + b + "}");
        });
        return m(l, {
          point: a,
          series: c
        }, this.chart.time);
      },
      bodyFormatter: function bodyFormatter(a) {
        return e(a, function (a) {
          var c = a.series.tooltipOptions;
          return (c[(a.point.formatPrefix || "point") + "Formatter"] || a.point.tooltipFormatter).call(a.point, c[(a.point.formatPrefix || "point") + "Format"]);
        });
      }
    };
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.attr,
        E = a.charts,
        m = a.css,
        g = a.defined,
        e = a.each,
        v = a.extend,
        u = a.find,
        t = a.fireEvent,
        l = a.isNumber,
        d = a.isObject,
        c = a.offset,
        x = a.pick,
        r = a.splat,
        n = a.Tooltip;

    a.Pointer = function (a, f) {
      this.init(a, f);
    };

    a.Pointer.prototype = {
      init: function init(a, f) {
        this.options = f;
        this.chart = a;
        this.runChartClick = f.chart.events && !!f.chart.events.click;
        this.pinchDown = [];
        this.lastValidTouch = {};
        n && (a.tooltip = new n(a, f.tooltip), this.followTouchMove = x(f.tooltip.followTouchMove, !0));
        this.setDOMEvents();
      },
      zoomOption: function zoomOption(a) {
        var b = this.chart,
            c = b.options.chart,
            d = c.zoomType || "",
            b = b.inverted;
        /touch/.test(a.type) && (d = x(c.pinchType, d));
        this.zoomX = a = /x/.test(d);
        this.zoomY = d = /y/.test(d);
        this.zoomHor = a && !b || d && b;
        this.zoomVert = d && !b || a && b;
        this.hasZoom = a || d;
      },
      normalize: function normalize(a, f) {
        var b;
        b = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;
        f || (this.chartPosition = f = c(this.chart.container));
        return v(a, {
          chartX: Math.round(b.pageX - f.left),
          chartY: Math.round(b.pageY - f.top)
        });
      },
      getCoordinates: function getCoordinates(a) {
        var b = {
          xAxis: [],
          yAxis: []
        };
        e(this.chart.axes, function (f) {
          b[f.isXAxis ? "xAxis" : "yAxis"].push({
            axis: f,
            value: f.toValue(a[f.horiz ? "chartX" : "chartY"])
          });
        });
        return b;
      },
      findNearestKDPoint: function findNearestKDPoint(a, f, c) {
        var b;
        e(a, function (a) {
          var e = !(a.noSharedTooltip && f) && 0 > a.options.findNearestPointBy.indexOf("y");
          a = a.searchPoint(c, e);
          if ((e = d(a, !0)) && !(e = !d(b, !0))) var e = b.distX - a.distX,
              n = b.dist - a.dist,
              g = (a.series.group && a.series.group.zIndex) - (b.series.group && b.series.group.zIndex),
              e = 0 < (0 !== e && f ? e : 0 !== n ? n : 0 !== g ? g : b.series.index > a.series.index ? -1 : 1);
          e && (b = a);
        });
        return b;
      },
      getPointFromEvent: function getPointFromEvent(a) {
        a = a.target;

        for (var b; a && !b;) {
          b = a.point, a = a.parentNode;
        }

        return b;
      },
      getChartCoordinatesFromPoint: function getChartCoordinatesFromPoint(a, f) {
        var b = a.series,
            c = b.xAxis,
            b = b.yAxis,
            d = x(a.clientX, a.plotX),
            e = a.shapeArgs;
        if (c && b) return f ? {
          chartX: c.len + c.pos - d,
          chartY: b.len + b.pos - a.plotY
        } : {
          chartX: d + c.pos,
          chartY: a.plotY + b.pos
        };
        if (e && e.x && e.y) return {
          chartX: e.x,
          chartY: e.y
        };
      },
      getHoverData: function getHoverData(b, f, c, n, g, l, r) {
        var q,
            p = [],
            D = r && r.isBoosting;
        n = !(!n || !b);
        r = f && !f.stickyTracking ? [f] : a.grep(c, function (a) {
          return a.visible && !(!g && a.directTouch) && x(a.options.enableMouseTracking, !0) && a.stickyTracking;
        });
        f = (q = n ? b : this.findNearestKDPoint(r, g, l)) && q.series;
        q && (g && !f.noSharedTooltip ? (r = a.grep(c, function (a) {
          return a.visible && !(!g && a.directTouch) && x(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
        }), e(r, function (a) {
          var b = u(a.points, function (a) {
            return a.x === q.x && !a.isNull;
          });
          d(b) && (D && (b = a.getPoint(b)), p.push(b));
        })) : p.push(q));
        return {
          hoverPoint: q,
          hoverSeries: f,
          hoverPoints: p
        };
      },
      runPointActions: function runPointActions(b, f) {
        var c = this.chart,
            d = c.tooltip && c.tooltip.options.enabled ? c.tooltip : void 0,
            n = d ? d.shared : !1,
            g = f || c.hoverPoint,
            l = g && g.series || c.hoverSeries,
            l = this.getHoverData(g, l, c.series, !!f || l && l.directTouch && this.isDirectTouch, n, b, {
          isBoosting: c.isBoosting
        }),
            w,
            g = l.hoverPoint;
        w = l.hoverPoints;
        l = l.hoverSeries;
        f = b && "touchmove" === b.type ? !0 === this.followTouchMove : l && l.tooltipOptions.followPointer;
        n = n && l && !l.noSharedTooltip;

        if (g && (g !== c.hoverPoint || d && d.isHidden)) {
          e(c.hoverPoints || [], function (b) {
            -1 === a.inArray(b, w) && b.setState();
          });
          e(w || [], function (a) {
            a.setState("hover");
          });
          if (c.hoverSeries !== l) l.onMouseOver();
          c.hoverPoint && c.hoverPoint.firePointEvent("mouseOut");
          if (!g.series) return;
          g.firePointEvent("mouseOver");
          c.hoverPoints = w;
          c.hoverPoint = g;
          d && d.refresh(n ? w : g, b);
        } else f && d && !d.isHidden && (g = d.getAnchor([{}], b), d.updatePosition({
          plotX: g[0],
          plotY: g[1]
        }));

        this.unDocMouseMove || (this.unDocMouseMove = A(c.container.ownerDocument, "mousemove", function (b) {
          var f = E[a.hoverChartIndex];
          if (f) f.pointer.onDocumentMouseMove(b);
        }));
        e(c.axes, function (f) {
          var c = x(f.crosshair.snap, !0),
              d = c ? a.find(w, function (a) {
            return a.series[f.coll] === f;
          }) : void 0;
          d || !c ? f.drawCrosshair(b, d) : f.hideCrosshair();
        });
      },
      reset: function reset(a, f) {
        var b = this.chart,
            c = b.hoverSeries,
            d = b.hoverPoint,
            n = b.hoverPoints,
            g = b.tooltip,
            l = g && g.shared ? n : d;
        a && l && e(r(l), function (b) {
          b.series.isCartesian && void 0 === b.plotX && (a = !1);
        });
        if (a) g && l && (g.refresh(l), g.shared && n ? e(n, function (a) {
          a.setState(a.state, !0);
          a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a);
          a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a);
        }) : d && (d.setState(d.state, !0), e(b.axes, function (a) {
          a.crosshair && a.drawCrosshair(null, d);
        })));else {
          if (d) d.onMouseOut();
          n && e(n, function (a) {
            a.setState();
          });
          if (c) c.onMouseOut();
          g && g.hide(f);
          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
          e(b.axes, function (a) {
            a.hideCrosshair();
          });
          this.hoverX = b.hoverPoints = b.hoverPoint = null;
        }
      },
      scaleGroups: function scaleGroups(a, f) {
        var b = this.chart,
            c;
        e(b.series, function (d) {
          c = a || d.getPlotBox();
          d.xAxis && d.xAxis.zoomEnabled && d.group && (d.group.attr(c), d.markerGroup && (d.markerGroup.attr(c), d.markerGroup.clip(f ? b.clipRect : null)), d.dataLabelsGroup && d.dataLabelsGroup.attr(c));
        });
        b.clipRect.attr(f || b.clipBox);
      },
      dragStart: function dragStart(a) {
        var b = this.chart;
        b.mouseIsDown = a.type;
        b.cancelClick = !1;
        b.mouseDownX = this.mouseDownX = a.chartX;
        b.mouseDownY = this.mouseDownY = a.chartY;
      },
      drag: function drag(a) {
        var b = this.chart,
            c = b.options.chart,
            d = a.chartX,
            e = a.chartY,
            n = this.zoomHor,
            g = this.zoomVert,
            l = b.plotLeft,
            p = b.plotTop,
            D = b.plotWidth,
            z = b.plotHeight,
            r,
            m = this.selectionMarker,
            h = this.mouseDownX,
            y = this.mouseDownY,
            u = c.panKey && a[c.panKey + "Key"];
        m && m.touch || (d < l ? d = l : d > l + D && (d = l + D), e < p ? e = p : e > p + z && (e = p + z), this.hasDragged = Math.sqrt(Math.pow(h - d, 2) + Math.pow(y - e, 2)), 10 < this.hasDragged && (r = b.isInsidePlot(h - l, y - p), b.hasCartesianSeries && (this.zoomX || this.zoomY) && r && !u && !m && (this.selectionMarker = m = b.renderer.rect(l, p, n ? 1 : D, g ? 1 : z, 0).attr({
          "class": "highcharts-selection-marker",
          zIndex: 7
        }).add()), m && n && (d -= h, m.attr({
          width: Math.abs(d),
          x: (0 < d ? 0 : d) + h
        })), m && g && (d = e - y, m.attr({
          height: Math.abs(d),
          y: (0 < d ? 0 : d) + y
        })), r && !m && c.panning && b.pan(a, c.panning)));
      },
      drop: function drop(a) {
        var b = this,
            c = this.chart,
            d = this.hasPinched;

        if (this.selectionMarker) {
          var n = {
            originalEvent: a,
            xAxis: [],
            yAxis: []
          },
              r = this.selectionMarker,
              u = r.attr ? r.attr("x") : r.x,
              w = r.attr ? r.attr("y") : r.y,
              p = r.attr ? r.attr("width") : r.width,
              D = r.attr ? r.attr("height") : r.height,
              z;
          if (this.hasDragged || d) e(c.axes, function (c) {
            if (c.zoomEnabled && g(c.min) && (d || b[{
              xAxis: "zoomX",
              yAxis: "zoomY"
            }[c.coll]])) {
              var f = c.horiz,
                  h = "touchend" === a.type ? c.minPixelPadding : 0,
                  e = c.toValue((f ? u : w) + h),
                  f = c.toValue((f ? u + p : w + D) - h);
              n[c.coll].push({
                axis: c,
                min: Math.min(e, f),
                max: Math.max(e, f)
              });
              z = !0;
            }
          }), z && t(c, "selection", n, function (a) {
            c.zoom(v(a, d ? {
              animation: !1
            } : null));
          });
          l(c.index) && (this.selectionMarker = this.selectionMarker.destroy());
          d && this.scaleGroups();
        }

        c && l(c.index) && (m(c.container, {
          cursor: c._cursor
        }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
      },
      onContainerMouseDown: function onContainerMouseDown(a) {
        a = this.normalize(a);
        2 !== a.button && (this.zoomOption(a), a.preventDefault && a.preventDefault(), this.dragStart(a));
      },
      onDocumentMouseUp: function onDocumentMouseUp(b) {
        E[a.hoverChartIndex] && E[a.hoverChartIndex].pointer.drop(b);
      },
      onDocumentMouseMove: function onDocumentMouseMove(a) {
        var b = this.chart,
            c = this.chartPosition;
        a = this.normalize(a, c);
        !c || this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();
      },
      onContainerMouseLeave: function onContainerMouseLeave(b) {
        var c = E[a.hoverChartIndex];
        c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);
      },
      onContainerMouseMove: function onContainerMouseMove(b) {
        var c = this.chart;
        g(a.hoverChartIndex) && E[a.hoverChartIndex] && E[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);
        b = this.normalize(b);
        b.returnValue = !1;
        "mousedown" === c.mouseIsDown && this.drag(b);
        !this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);
      },
      inClass: function inClass(a, c) {
        for (var b; a;) {
          if (b = C(a, "class")) {
            if (-1 !== b.indexOf(c)) return !0;
            if (-1 !== b.indexOf("highcharts-container")) return !1;
          }

          a = a.parentNode;
        }
      },
      onTrackerMouseOut: function onTrackerMouseOut(a) {
        var b = this.chart.hoverSeries;
        a = a.relatedTarget || a.toElement;
        this.isDirectTouch = !1;
        if (!(!b || !a || b.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + b.index) && this.inClass(a, "highcharts-tracker"))) b.onMouseOut();
      },
      onContainerClick: function onContainerClick(a) {
        var b = this.chart,
            c = b.hoverPoint,
            d = b.plotLeft,
            e = b.plotTop;
        a = this.normalize(a);
        b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (t(c.series, "click", v(a, {
          point: c
        })), b.hoverPoint && c.firePointEvent("click", a)) : (v(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - d, a.chartY - e) && t(b, "click", a)));
      },
      setDOMEvents: function setDOMEvents() {
        var b = this,
            c = b.chart.container,
            d = c.ownerDocument;

        c.onmousedown = function (a) {
          b.onContainerMouseDown(a);
        };

        c.onmousemove = function (a) {
          b.onContainerMouseMove(a);
        };

        c.onclick = function (a) {
          b.onContainerClick(a);
        };

        this.unbindContainerMouseLeave = A(c, "mouseleave", b.onContainerMouseLeave);
        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = A(d, "mouseup", b.onDocumentMouseUp));
        a.hasTouch && (c.ontouchstart = function (a) {
          b.onContainerTouchStart(a);
        }, c.ontouchmove = function (a) {
          b.onContainerTouchMove(a);
        }, a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = A(d, "touchend", b.onDocumentTouchEnd)));
      },
      destroy: function destroy() {
        var b = this;
        b.unDocMouseMove && b.unDocMouseMove();
        this.unbindContainerMouseLeave();
        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));
        clearInterval(b.tooltipTimeout);
        a.objectEach(b, function (a, c) {
          b[c] = null;
        });
      }
    };
  })(K);

  (function (a) {
    var A = a.charts,
        C = a.each,
        E = a.extend,
        m = a.map,
        g = a.noop,
        e = a.pick;
    E(a.Pointer.prototype, {
      pinchTranslate: function pinchTranslate(a, e, g, l, d, c) {
        this.zoomHor && this.pinchTranslateDirection(!0, a, e, g, l, d, c);
        this.zoomVert && this.pinchTranslateDirection(!1, a, e, g, l, d, c);
      },
      pinchTranslateDirection: function pinchTranslateDirection(a, e, g, l, d, c, m, r) {
        var n = this.chart,
            b = a ? "x" : "y",
            f = a ? "X" : "Y",
            q = "chart" + f,
            u = a ? "width" : "height",
            x = n["plot" + (a ? "Left" : "Top")],
            B,
            H,
            w = r || 1,
            p = n.inverted,
            D = n.bounds[a ? "h" : "v"],
            z = 1 === e.length,
            F = e[0][q],
            v = g[0][q],
            h = !z && e[1][q],
            y = !z && g[1][q],
            t;

        g = function g() {
          !z && 20 < Math.abs(F - h) && (w = r || Math.abs(v - y) / Math.abs(F - h));
          H = (x - v) / w + F;
          B = n["plot" + (a ? "Width" : "Height")] / w;
        };

        g();
        e = H;
        e < D.min ? (e = D.min, t = !0) : e + B > D.max && (e = D.max - B, t = !0);
        t ? (v -= .8 * (v - m[b][0]), z || (y -= .8 * (y - m[b][1])), g()) : m[b] = [v, y];
        p || (c[b] = H - x, c[u] = B);
        c = p ? 1 / w : w;
        d[u] = B;
        d[b] = e;
        l[p ? a ? "scaleY" : "scaleX" : "scale" + f] = w;
        l["translate" + f] = c * x + (v - c * F);
      },
      pinch: function pinch(a) {
        var u = this,
            t = u.chart,
            l = u.pinchDown,
            d = a.touches,
            c = d.length,
            x = u.lastValidTouch,
            r = u.hasZoom,
            n = u.selectionMarker,
            b = {},
            f = 1 === c && (u.inClass(a.target, "highcharts-tracker") && t.runTrackerClick || u.runChartClick),
            q = {};
        1 < c && (u.initiated = !0);
        r && u.initiated && !f && a.preventDefault();
        m(d, function (a) {
          return u.normalize(a);
        });
        "touchstart" === a.type ? (C(d, function (a, b) {
          l[b] = {
            chartX: a.chartX,
            chartY: a.chartY
          };
        }), x.x = [l[0].chartX, l[1] && l[1].chartX], x.y = [l[0].chartY, l[1] && l[1].chartY], C(t.axes, function (a) {
          if (a.zoomEnabled) {
            var b = t.bounds[a.horiz ? "h" : "v"],
                c = a.minPixelPadding,
                d = a.toPixels(e(a.options.min, a.dataMin)),
                f = a.toPixels(e(a.options.max, a.dataMax)),
                p = Math.max(d, f);
            b.min = Math.min(a.pos, Math.min(d, f) - c);
            b.max = Math.max(a.pos + a.len, p + c);
          }
        }), u.res = !0) : u.followTouchMove && 1 === c ? this.runPointActions(u.normalize(a)) : l.length && (n || (u.selectionMarker = n = E({
          destroy: g,
          touch: !0
        }, t.plotBox)), u.pinchTranslate(l, d, b, n, q, x), u.hasPinched = r, u.scaleGroups(b, q), u.res && (u.res = !1, this.reset(!1, 0)));
      },
      touch: function touch(g, m) {
        var u = this.chart,
            l,
            d;
        if (u.index !== a.hoverChartIndex) this.onContainerMouseLeave({
          relatedTarget: !0
        });
        a.hoverChartIndex = u.index;
        1 === g.touches.length ? (g = this.normalize(g), (d = u.isInsidePlot(g.chartX - u.plotLeft, g.chartY - u.plotTop)) && !u.openMenu ? (m && this.runPointActions(g), "touchmove" === g.type && (m = this.pinchDown, l = m[0] ? 4 <= Math.sqrt(Math.pow(m[0].chartX - g.chartX, 2) + Math.pow(m[0].chartY - g.chartY, 2)) : !1), e(l, !0) && this.pinch(g)) : m && this.reset()) : 2 === g.touches.length && this.pinch(g);
      },
      onContainerTouchStart: function onContainerTouchStart(a) {
        this.zoomOption(a);
        this.touch(a, !0);
      },
      onContainerTouchMove: function onContainerTouchMove(a) {
        this.touch(a);
      },
      onDocumentTouchEnd: function onDocumentTouchEnd(e) {
        A[a.hoverChartIndex] && A[a.hoverChartIndex].pointer.drop(e);
      }
    });
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.charts,
        E = a.css,
        m = a.doc,
        g = a.extend,
        e = a.noop,
        v = a.Pointer,
        u = a.removeEvent,
        t = a.win,
        l = a.wrap;

    if (!a.hasTouch && (t.PointerEvent || t.MSPointerEvent)) {
      var d = {},
          c = !!t.PointerEvent,
          x = function x() {
        var c = [];

        c.item = function (a) {
          return this[a];
        };

        a.objectEach(d, function (a) {
          c.push({
            pageX: a.pageX,
            pageY: a.pageY,
            target: a.target
          });
        });
        return c;
      },
          r = function r(c, b, d, g) {
        "touch" !== c.pointerType && c.pointerType !== c.MSPOINTER_TYPE_TOUCH || !C[a.hoverChartIndex] || (g(c), g = C[a.hoverChartIndex].pointer, g[b]({
          type: d,
          target: c.currentTarget,
          preventDefault: e,
          touches: x()
        }));
      };

      g(v.prototype, {
        onContainerPointerDown: function onContainerPointerDown(a) {
          r(a, "onContainerTouchStart", "touchstart", function (a) {
            d[a.pointerId] = {
              pageX: a.pageX,
              pageY: a.pageY,
              target: a.currentTarget
            };
          });
        },
        onContainerPointerMove: function onContainerPointerMove(a) {
          r(a, "onContainerTouchMove", "touchmove", function (a) {
            d[a.pointerId] = {
              pageX: a.pageX,
              pageY: a.pageY
            };
            d[a.pointerId].target || (d[a.pointerId].target = a.currentTarget);
          });
        },
        onDocumentPointerUp: function onDocumentPointerUp(a) {
          r(a, "onDocumentTouchEnd", "touchend", function (a) {
            delete d[a.pointerId];
          });
        },
        batchMSEvents: function batchMSEvents(a) {
          a(this.chart.container, c ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
          a(this.chart.container, c ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
          a(m, c ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
        }
      });
      l(v.prototype, "init", function (a, b, c) {
        a.call(this, b, c);
        this.hasZoom && E(b.container, {
          "-ms-touch-action": "none",
          "touch-action": "none"
        });
      });
      l(v.prototype, "setDOMEvents", function (a) {
        a.apply(this);
        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(A);
      });
      l(v.prototype, "destroy", function (a) {
        this.batchMSEvents(u);
        a.call(this);
      });
    }
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.css,
        E = a.discardElement,
        m = a.defined,
        g = a.each,
        e = a.fireEvent,
        v = a.isFirefox,
        u = a.marginNames,
        t = a.merge,
        l = a.pick,
        d = a.setAnimation,
        c = a.stableSort,
        x = a.win,
        r = a.wrap;

    a.Legend = function (a, b) {
      this.init(a, b);
    };

    a.Legend.prototype = {
      init: function init(a, b) {
        this.chart = a;
        this.setOptions(b);
        b.enabled && (this.render(), A(this.chart, "endResize", function () {
          this.legend.positionCheckboxes();
        }), this.proximate ? this.unchartrender = A(this.chart, "render", function () {
          this.legend.proximatePositions();
          this.legend.positionItems();
        }) : this.unchartrender && this.unchartrender());
      },
      setOptions: function setOptions(a) {
        var b = l(a.padding, 8);
        this.options = a;
        this.itemMarginTop = a.itemMarginTop || 0;
        this.padding = b;
        this.initialItemY = b - 5;
        this.symbolWidth = l(a.symbolWidth, 16);
        this.pages = [];
        this.proximate = "proximate" === a.layout && !this.chart.inverted;
      },
      update: function update(a, b) {
        var c = this.chart;
        this.setOptions(t(!0, this.options, a));
        this.destroy();
        c.isDirtyLegend = c.isDirtyBox = !0;
        l(b, !0) && c.redraw();
        e(this, "afterUpdate");
      },
      colorizeItem: function colorizeItem(a, b) {
        a.legendGroup[b ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
        e(this, "afterColorizeItem", {
          item: a,
          visible: b
        });
      },
      positionItems: function positionItems() {
        g(this.allItems, this.positionItem, this);
        this.chart.isResizing || this.positionCheckboxes();
      },
      positionItem: function positionItem(a) {
        var b = this.options,
            c = b.symbolPadding,
            b = !b.rtl,
            d = a._legendItemPos,
            e = d[0],
            d = d[1],
            g = a.checkbox;
        if ((a = a.legendGroup) && a.element) a[m(a.translateY) ? "animate" : "attr"]({
          translateX: b ? e : this.legendWidth - e - 2 * c - 4,
          translateY: d
        });
        g && (g.x = e, g.y = d);
      },
      destroyItem: function destroyItem(a) {
        var b = a.checkbox;
        g(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (b) {
          a[b] && (a[b] = a[b].destroy());
        });
        b && E(a.checkbox);
      },
      destroy: function destroy() {
        function a(a) {
          this[a] && (this[a] = this[a].destroy());
        }

        g(this.getAllItems(), function (b) {
          g(["legendItem", "legendGroup"], a, b);
        });
        g("clipRect up down pager nav box title group".split(" "), a, this);
        this.display = null;
      },
      positionCheckboxes: function positionCheckboxes() {
        var a = this.group && this.group.alignAttr,
            b,
            c = this.clipHeight || this.legendHeight,
            d = this.titleHeight;
        a && (b = a.translateY, g(this.allItems, function (f) {
          var e = f.checkbox,
              g;
          e && (g = b + d + e.y + (this.scrollOffset || 0) + 3, C(e, {
            left: a.translateX + f.checkboxOffset + e.x - 20 + "px",
            top: g + "px",
            display: g > b - 6 && g < b + c - 6 ? "" : "none"
          }));
        }, this));
      },
      renderTitle: function renderTitle() {
        var a = this.options,
            b = this.padding,
            c = a.title,
            d = 0;
        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, null, null, null, a.useHTML, null, "legend-title").attr({
          zIndex: 1
        }).add(this.group)), a = this.title.getBBox(), d = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
          translateY: d
        }));
        this.titleHeight = d;
      },
      setText: function setText(c) {
        var b = this.options;
        c.legendItem.attr({
          text: b.labelFormat ? a.format(b.labelFormat, c, this.chart.time) : b.labelFormatter.call(c)
        });
      },
      renderItem: function renderItem(a) {
        var b = this.chart,
            c = b.renderer,
            d = this.options,
            e = this.symbolWidth,
            g = d.symbolPadding,
            n = "horizontal" === d.layout ? l(d.itemDistance, 20) : 0,
            r = !d.rtl,
            w = a.legendItem,
            p = !a.series,
            D = !p && a.series.drawLegendSymbol ? a.series : a,
            z = D.options,
            z = this.createCheckboxForItem && z && z.showCheckbox,
            n = e + g + n + (z ? 20 : 0),
            F = d.useHTML,
            m = a.options.className;
        w || (a.legendGroup = c.g("legend-item").addClass("highcharts-" + D.type + "-series highcharts-color-" + a.colorIndex + (m ? " " + m : "") + (p ? " highcharts-series-" + a.index : "")).attr({
          zIndex: 1
        }).add(this.scrollGroup), a.legendItem = w = c.text("", r ? e + g : -g, this.baseline || 0, F).attr({
          align: r ? "left" : "right",
          zIndex: 2
        }).add(a.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(12, w), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, w.attr("y", this.baseline)), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, D.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, w, F), z && this.createCheckboxForItem(a));
        this.colorizeItem(a, a.visible);
        w.css({
          width: (d.itemWidth || d.width || b.spacingBox.width) - n
        });
        this.setText(a);
        b = w.getBBox();
        a.itemWidth = a.checkboxOffset = d.itemWidth || a.legendItemWidth || b.width + n;
        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
        this.totalItemWidth += a.itemWidth;
        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);
      },
      layoutItem: function layoutItem(a) {
        var b = this.options,
            c = this.padding,
            d = "horizontal" === b.layout,
            e = a.itemHeight,
            g = b.itemMarginBottom || 0,
            n = this.itemMarginTop,
            r = d ? l(b.itemDistance, 20) : 0,
            w = b.width,
            p = w || this.chart.spacingBox.width - 2 * c - b.x,
            b = b.alignColumns && this.totalItemWidth > p ? this.maxItemWidth : a.itemWidth;
        d && this.itemX - c + b > p && (this.itemX = c, this.itemY += n + this.lastLineHeight + g, this.lastLineHeight = 0);
        this.lastItemY = n + this.itemY + g;
        this.lastLineHeight = Math.max(e, this.lastLineHeight);
        a._legendItemPos = [this.itemX, this.itemY];
        d ? this.itemX += b : (this.itemY += n + e + g, this.lastLineHeight = e);
        this.offsetWidth = w || Math.max((d ? this.itemX - c - (a.checkbox ? 0 : r) : b) + c, this.offsetWidth);
      },
      getAllItems: function getAllItems() {
        var a = [];
        g(this.chart.series, function (b) {
          var c = b && b.options;
          b && l(c.showInLegend, m(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)));
        });
        e(this, "afterGetAllItems", {
          allItems: a
        });
        return a;
      },
      getAlignment: function getAlignment() {
        var a = this.options;
        return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
      },
      adjustMargins: function adjustMargins(a, b) {
        var c = this.chart,
            d = this.options,
            e = this.getAlignment();
        e && g([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (f, g) {
          f.test(e) && !m(a[g]) && (c[u[g]] = Math.max(c[u[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * d[g % 2 ? "x" : "y"] + l(d.margin, 12) + b[g] + (0 === g && void 0 !== c.options.title.margin ? c.titleOffset + c.options.title.margin : 0)));
        });
      },
      proximatePositions: function proximatePositions() {
        var c = this.chart,
            b = [],
            d = "left" === this.options.align;
        g(this.allItems, function (f) {
          var e, g;
          e = d;
          f.xAxis && f.points && (f.xAxis.options.reversed && (e = !e), e = a.find(e ? f.points : f.points.slice(0).reverse(), function (b) {
            return a.isNumber(b.plotY);
          }), g = f.legendGroup.getBBox().height, b.push({
            target: f.visible ? (e ? e.plotY : f.xAxis.height) - .3 * g : c.plotHeight,
            size: g,
            item: f
          }));
        }, this);
        a.distribute(b, c.plotHeight);
        g(b, function (a) {
          a.item._legendItemPos[1] = c.plotTop - c.spacing[0] + a.pos;
        });
      },
      render: function render() {
        var a = this.chart,
            b = a.renderer,
            d = this.group,
            e,
            l,
            r,
            m = this.box,
            x = this.options,
            w = this.padding;
        this.itemX = w;
        this.itemY = this.initialItemY;
        this.lastItemY = this.offsetWidth = 0;
        d || (this.group = d = b.g("legend").attr({
          zIndex: 7
        }).add(), this.contentGroup = b.g().attr({
          zIndex: 1
        }).add(d), this.scrollGroup = b.g().add(this.contentGroup));
        this.renderTitle();
        e = this.getAllItems();
        c(e, function (a, b) {
          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
        });
        x.reversed && e.reverse();
        this.allItems = e;
        this.display = l = !!e.length;
        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
        g(e, this.renderItem, this);
        g(e, this.layoutItem, this);
        e = (x.width || this.offsetWidth) + w;
        r = this.lastItemY + this.lastLineHeight + this.titleHeight;
        r = this.handleOverflow(r);
        r += w;
        m || (this.box = m = b.rect().addClass("highcharts-legend-box").attr({
          r: x.borderRadius
        }).add(d), m.isNew = !0);
        0 < e && 0 < r && (m[m.isNew ? "attr" : "animate"](m.crisp.call({}, {
          x: 0,
          y: 0,
          width: e,
          height: r
        }, m.strokeWidth())), m.isNew = !1);
        m[l ? "show" : "hide"]();
        "none" === d.getStyle("display") && (e = r = 0);
        this.legendWidth = e;
        this.legendHeight = r;
        l && (b = a.spacingBox, /(lth|ct|rth)/.test(this.getAlignment()) && (b = t(b, {
          y: b.y + a.titleOffset + a.options.title.margin
        })), d.align(t(x, {
          width: e,
          height: r,
          verticalAlign: this.proximate ? "top" : x.verticalAlign
        }), !0, b));
        this.proximate || this.positionItems();
      },
      handleOverflow: function handleOverflow(a) {
        var b = this,
            c = this.chart,
            d = c.renderer,
            e = this.options,
            n = e.y,
            r = this.padding,
            c = c.spacingBox.height + ("top" === e.verticalAlign ? -n : n) - r,
            n = e.maxHeight,
            m,
            w = this.clipRect,
            p = e.navigation,
            D = l(p.animation, !0),
            z = p.arrowSize || 12,
            F = this.nav,
            x = this.pages,
            h,
            y = this.allItems,
            u = function u(a) {
          "number" === typeof a ? w.attr({
            height: a
          }) : w && (b.clipRect = w.destroy(), b.contentGroup.clip());
          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + r + "px,9999px," + (r + a) + "px,0)" : "auto");
        };

        "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (c /= 2);
        n && (c = Math.min(c, n));
        x.length = 0;
        a > c && !1 !== p.enabled ? (this.clipHeight = m = Math.max(c - 20 - this.titleHeight - r, 0), this.currentPage = l(this.currentPage, 1), this.fullHeight = a, g(y, function (a, b) {
          var c = a._legendItemPos[1],
              d = Math.round(a.legendItem.getBBox().height),
              k = x.length;
          if (!k || c - x[k - 1] > m && (h || c) !== x[k - 1]) x.push(h || c), k++;
          a.pageIx = k - 1;
          h && (y[b - 1].pageIx = k - 1);
          b === y.length - 1 && c + d - x[k - 1] > m && (x.push(c), a.pageIx = k);
          c !== h && (h = c);
        }), w || (w = b.clipRect = d.clipRect(0, r, 9999, 0), b.contentGroup.clip(w)), u(m), F || (this.nav = F = d.g().attr({
          zIndex: 1
        }).add(this.group), this.up = d.symbol("triangle", 0, 0, z, z).on("click", function () {
          b.scroll(-1, D);
        }).add(F), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation").add(F), this.down = d.symbol("triangle-down", 0, 0, z, z).on("click", function () {
          b.scroll(1, D);
        }).add(F)), b.scroll(0), a = c) : F && (u(), this.nav = F.destroy(), this.scrollGroup.attr({
          translateY: 1
        }), this.clipHeight = 0);
        return a;
      },
      scroll: function scroll(a, b) {
        var c = this.pages,
            e = c.length;
        a = this.currentPage + a;
        var g = this.clipHeight,
            n = this.pager,
            l = this.padding;
        a > e && (a = e);
        0 < a && (void 0 !== b && d(b, this.chart), this.nav.attr({
          translateX: l,
          translateY: g + this.padding + 7 + this.titleHeight,
          visibility: "visible"
        }), this.up.attr({
          "class": 1 === a ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        }), n.attr({
          text: a + "/" + e
        }), this.down.attr({
          x: 18 + this.pager.getBBox().width,
          "class": a === e ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
        }), this.scrollOffset = -c[a - 1] + this.initialItemY, this.scrollGroup.animate({
          translateY: this.scrollOffset
        }), this.currentPage = a, this.positionCheckboxes());
      }
    };
    a.LegendSymbolMixin = {
      drawRectangle: function drawRectangle(a, b) {
        var c = a.symbolHeight,
            d = a.options.squareSymbol;
        b.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - c) / 2 : 0, a.baseline - c + 1, d ? c : a.symbolWidth, c, l(a.options.symbolRadius, c / 2)).addClass("highcharts-point").attr({
          zIndex: 3
        }).add(b.legendGroup);
      },
      drawLineMarker: function drawLineMarker(a) {
        var b = this.options.marker,
            c,
            d = a.symbolWidth,
            e = a.symbolHeight;
        c = e / 2;
        var g = this.chart.renderer,
            n = this.legendGroup;
        a = a.baseline - Math.round(.3 * a.fontMetrics.b);
        this.legendLine = g.path(["M", 0, a, "L", d, a]).addClass("highcharts-graph").attr({}).add(n);
        b && !1 !== b.enabled && d && (c = Math.min(l(b.radius, c), c), 0 === this.symbol.indexOf("url") && (b = t(b, {
          width: e,
          height: e
        }), c = 0), this.legendSymbol = b = g.symbol(this.symbol, d / 2 - c, a - c, 2 * c, 2 * c, b).addClass("highcharts-point").add(n), b.isMarker = !0);
      }
    };
    (/Trident\/7\.0/.test(x.navigator.userAgent) || v) && r(a.Legend.prototype, "positionItem", function (a, b) {
      var c = this,
          d = function d() {
        b._legendItemPos && a.call(c, b);
      };

      d();
      setTimeout(d);
    });
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.animObject,
        E = a.attr,
        m = a.doc,
        g = a.Axis,
        e = a.createElement,
        v = a.defaultOptions,
        u = a.discardElement,
        t = a.charts,
        l = a.defined,
        d = a.each,
        c = a.extend,
        x = a.find,
        r = a.fireEvent,
        n = a.grep,
        b = a.isNumber,
        f = a.isObject,
        q = a.isString,
        G = a.Legend,
        J = a.marginNames,
        B = a.merge,
        H = a.objectEach,
        w = a.Pointer,
        p = a.pick,
        D = a.pInt,
        z = a.removeEvent,
        F = a.seriesTypes,
        M = a.splat,
        h = a.syncTimeout,
        y = a.win,
        N = a.Chart = function () {
      this.getArgs.apply(this, arguments);
    };

    a.chart = function (a, b, c) {
      return new N(a, b, c);
    };

    c(N.prototype, {
      callbacks: [],
      getArgs: function getArgs() {
        var a = [].slice.call(arguments);
        if (q(a[0]) || a[0].nodeName) this.renderTo = a.shift();
        this.init(a[0], a[1]);
      },
      init: function init(b, c) {
        var d,
            k,
            f = b.series,
            e = b.plotOptions || {};
        r(this, "init", {
          args: arguments
        }, function () {
          b.series = null;
          d = B(v, b);

          for (k in d.plotOptions) {
            d.plotOptions[k].tooltip = e[k] && B(e[k].tooltip) || void 0;
          }

          d.tooltip.userOptions = b.chart && b.chart.forExport && b.tooltip.userOptions || b.tooltip;
          d.series = b.series = f;
          this.userOptions = b;
          var h = d.chart,
              p = h.events;
          this.margin = [];
          this.spacing = [];
          this.bounds = {
            h: {},
            v: {}
          };
          this.labelCollectors = [];
          this.callback = c;
          this.isResizing = 0;
          this.options = d;
          this.axes = [];
          this.series = [];
          this.time = b.time && a.keys(b.time).length ? new a.Time(b.time) : a.time;
          this.hasCartesianSeries = h.showAxes;
          var g = this;
          g.index = t.length;
          t.push(g);
          a.chartCount++;
          p && H(p, function (a, b) {
            A(g, b, a);
          });
          g.xAxis = [];
          g.yAxis = [];
          g.pointCount = g.colorCounter = g.symbolCounter = 0;
          r(g, "afterInit");
          g.firstRender();
        });
      },
      initSeries: function initSeries(b) {
        var c = this.options.chart;
        (c = F[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);
        c = new c();
        c.init(this, b);
        return c;
      },
      orderSeries: function orderSeries(a) {
        var b = this.series;

        for (a = a || 0; a < b.length; a++) {
          b[a] && (b[a].index = a, b[a].name = b[a].getName());
        }
      },
      isInsidePlot: function isInsidePlot(a, b, c) {
        var d = c ? b : a;
        a = c ? a : b;
        return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;
      },
      redraw: function redraw(b) {
        r(this, "beforeRedraw");
        var f = this.axes,
            k = this.series,
            e = this.pointer,
            h = this.legend,
            g = this.isDirtyLegend,
            p,
            z,
            n = this.hasCartesianSeries,
            l = this.isDirtyBox,
            D,
            w = this.renderer,
            q = w.isHidden(),
            m = [];
        this.setResponsive && this.setResponsive(!1);
        a.setAnimation(b, this);
        q && this.temporaryDisplay();
        this.layOutTitles();

        for (b = k.length; b--;) {
          if (D = k[b], D.options.stacking && (p = !0, D.isDirty)) {
            z = !0;
            break;
          }
        }

        if (z) for (b = k.length; b--;) {
          D = k[b], D.options.stacking && (D.isDirty = !0);
        }
        d(k, function (a) {
          a.isDirty && "point" === a.options.legendType && (a.updateTotals && a.updateTotals(), g = !0);
          a.isDirtyData && r(a, "updatedData");
        });
        g && h.options.enabled && (h.render(), this.isDirtyLegend = !1);
        p && this.getStacks();
        n && d(f, function (a) {
          a.updateNames();
          a.setScale();
        });
        this.getMargins();
        n && (d(f, function (a) {
          a.isDirty && (l = !0);
        }), d(f, function (a) {
          var b = a.min + "," + a.max;
          a.extKey !== b && (a.extKey = b, m.push(function () {
            r(a, "afterSetExtremes", c(a.eventArgs, a.getExtremes()));
            delete a.eventArgs;
          }));
          (l || p) && a.redraw();
        }));
        l && this.drawChartBox();
        r(this, "predraw");
        d(k, function (a) {
          (l || a.isDirty) && a.visible && a.redraw();
          a.isDirtyData = !1;
        });
        e && e.reset(!0);
        w.draw();
        r(this, "redraw");
        r(this, "render");
        q && this.temporaryDisplay(!0);
        d(m, function (a) {
          a.call();
        });
      },
      get: function get(a) {
        function b(b) {
          return b.id === a || b.options && b.options.id === a;
        }

        var c,
            d = this.series,
            f;
        c = x(this.axes, b) || x(this.series, b);

        for (f = 0; !c && f < d.length; f++) {
          c = x(d[f].points || [], b);
        }

        return c;
      },
      getAxes: function getAxes() {
        var a = this,
            b = this.options,
            c = b.xAxis = M(b.xAxis || {}),
            b = b.yAxis = M(b.yAxis || {});
        r(this, "getAxes");
        d(c, function (a, b) {
          a.index = b;
          a.isX = !0;
        });
        d(b, function (a, b) {
          a.index = b;
        });
        c = c.concat(b);
        d(c, function (b) {
          new g(a, b);
        });
        r(this, "afterGetAxes");
      },
      getSelectedPoints: function getSelectedPoints() {
        var a = [];
        d(this.series, function (b) {
          a = a.concat(n(b.data || [], function (a) {
            return a.selected;
          }));
        });
        return a;
      },
      getSelectedSeries: function getSelectedSeries() {
        return n(this.series, function (a) {
          return a.selected;
        });
      },
      setTitle: function setTitle(a, b, c) {
        var f = this,
            e = f.options,
            k;
        k = e.title = B(e.title, a);
        e = e.subtitle = B(e.subtitle, b);
        d([["title", a, k], ["subtitle", b, e]], function (a, b) {
          var c = a[0],
              d = f[c],
              e = a[1];
          a = a[2];
          d && e && (f[c] = d = d.destroy());
          a && !d && (f[c] = f.renderer.text(a.text, 0, 0, a.useHTML).attr({
            align: a.align,
            "class": "highcharts-" + c,
            zIndex: a.zIndex || 4
          }).add(), f[c].update = function (a) {
            f.setTitle(!b && a, b && a);
          });
        });
        f.layOutTitles(c);
      },
      layOutTitles: function layOutTitles(a) {
        var b = 0,
            f,
            e = this.renderer,
            k = this.spacingBox;
        d(["title", "subtitle"], function (a) {
          var d = this[a],
              f = this.options[a];
          a = "title" === a ? -3 : f.verticalAlign ? 0 : b + 2;
          var h;
          d && (h = e.fontMetrics(h, d).b, d.css({
            width: (f.width || k.width + f.widthAdjust) + "px"
          }).align(c({
            y: a + h
          }, f), !1, "spacingBox"), f.floating || f.verticalAlign || (b = Math.ceil(b + d.getBBox(f.useHTML).height)));
        }, this);
        f = this.titleOffset !== b;
        this.titleOffset = b;
        !this.isDirtyBox && f && (this.isDirtyBox = this.isDirtyLegend = f, this.hasRendered && p(a, !0) && this.isDirtyBox && this.redraw());
      },
      getChartSize: function getChartSize() {
        var b = this.options.chart,
            c = b.width,
            b = b.height,
            d = this.renderTo;
        l(c) || (this.containerWidth = a.getStyle(d, "width"));
        l(b) || (this.containerHeight = a.getStyle(d, "height"));
        this.chartWidth = Math.max(0, c || this.containerWidth || 600);
        this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
      },
      temporaryDisplay: function temporaryDisplay(b) {
        var c = this.renderTo;
        if (b) for (; c && c.style;) {
          c.hcOrigStyle && (a.css(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (m.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;
        } else for (; c && c.style;) {
          m.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, m.body.appendChild(c));
          if ("none" === a.getStyle(c, "display", !1) || c.hcOricDetached) c.hcOrigStyle = {
            display: c.style.display,
            height: c.style.height,
            overflow: c.style.overflow
          }, b = {
            display: "block",
            overflow: "hidden"
          }, c !== this.renderTo && (b.height = 0), a.css(c, b), c.offsetWidth || c.style.setProperty("display", "block", "important");
          c = c.parentNode;
          if (c === m.body) break;
        }
      },
      setClassName: function setClassName(a) {
        this.container.className = "highcharts-container " + (a || "");
      },
      getContainer: function getContainer() {
        var c,
            d = this.options,
            f = d.chart,
            h,
            g;
        c = this.renderTo;
        var p = a.uniqueKey(),
            z;
        c || (this.renderTo = c = f.renderTo);
        q(c) && (this.renderTo = c = m.getElementById(c));
        c || a.error(13, !0);
        h = D(E(c, "data-highcharts-chart"));
        b(h) && t[h] && t[h].hasRendered && t[h].destroy();
        E(c, "data-highcharts-chart", this.index);
        c.innerHTML = "";
        f.skipClone || c.offsetWidth || this.temporaryDisplay();
        this.getChartSize();
        h = this.chartWidth;
        g = this.chartHeight;
        this.container = c = e("div", {
          id: p
        }, void 0, c);
        this._cursor = c.style.cursor;
        this.renderer = new (a[f.renderer] || a.Renderer)(c, h, g, null, f.forExport, d.exporting && d.exporting.allowHTML);
        this.setClassName(f.className);

        for (z in d.defs) {
          this.renderer.definition(d.defs[z]);
        }

        this.renderer.chartIndex = this.index;
        r(this, "afterGetContainer");
      },
      getMargins: function getMargins(a) {
        var b = this.spacing,
            c = this.margin,
            d = this.titleOffset;
        this.resetMargins();
        d && !l(c[0]) && (this.plotTop = Math.max(this.plotTop, d + this.options.title.margin + b[0]));
        this.legend && this.legend.display && this.legend.adjustMargins(c, b);
        r(this, "getMargins");
        a || this.getAxisMargins();
      },
      getAxisMargins: function getAxisMargins() {
        var a = this,
            b = a.axisOffset = [0, 0, 0, 0],
            c = a.margin;
        a.hasCartesianSeries && d(a.axes, function (a) {
          a.visible && a.getOffset();
        });
        d(J, function (d, f) {
          l(c[f]) || (a[d] += b[f]);
        });
        a.setChartSize();
      },
      reflow: function reflow(b) {
        var c = this,
            d = c.options.chart,
            f = c.renderTo,
            e = l(d.width) && l(d.height),
            k = d.width || a.getStyle(f, "width"),
            d = d.height || a.getStyle(f, "height"),
            f = b ? b.target : y;

        if (!e && !c.isPrinting && k && d && (f === y || f === m)) {
          if (k !== c.containerWidth || d !== c.containerHeight) a.clearTimeout(c.reflowTimeout), c.reflowTimeout = h(function () {
            c.container && c.setSize(void 0, void 0, !1);
          }, b ? 100 : 0);
          c.containerWidth = k;
          c.containerHeight = d;
        }
      },
      setReflow: function setReflow(a) {
        var b = this;
        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = A(y, "resize", function (a) {
          b.reflow(a);
        }), A(this, "destroy", this.unbindReflow));
      },
      setSize: function setSize(b, c, f) {
        var e = this,
            k = e.renderer;
        e.isResizing += 1;
        a.setAnimation(f, e);
        e.oldChartHeight = e.chartHeight;
        e.oldChartWidth = e.chartWidth;
        void 0 !== b && (e.options.chart.width = b);
        void 0 !== c && (e.options.chart.height = c);
        e.getChartSize();
        e.setChartSize(!0);
        k.setSize(e.chartWidth, e.chartHeight, f);
        d(e.axes, function (a) {
          a.isDirty = !0;
          a.setScale();
        });
        e.isDirtyLegend = !0;
        e.isDirtyBox = !0;
        e.layOutTitles();
        e.getMargins();
        e.redraw(f);
        e.oldChartHeight = null;
        r(e, "resize");
        h(function () {
          e && r(e, "endResize", null, function () {
            --e.isResizing;
          });
        }, C(void 0).duration);
      },
      setChartSize: function setChartSize(a) {
        var b = this.inverted,
            c = this.renderer,
            f = this.chartWidth,
            e = this.chartHeight,
            h = this.options.chart,
            k = this.spacing,
            g = this.clipOffset,
            p,
            z,
            n,
            l;
        this.plotLeft = p = Math.round(this.plotLeft);
        this.plotTop = z = Math.round(this.plotTop);
        this.plotWidth = n = Math.max(0, Math.round(f - p - this.marginRight));
        this.plotHeight = l = Math.max(0, Math.round(e - z - this.marginBottom));
        this.plotSizeX = b ? l : n;
        this.plotSizeY = b ? n : l;
        this.plotBorderWidth = h.plotBorderWidth || 0;
        this.spacingBox = c.spacingBox = {
          x: k[3],
          y: k[0],
          width: f - k[3] - k[1],
          height: e - k[0] - k[2]
        };
        this.plotBox = c.plotBox = {
          x: p,
          y: z,
          width: n,
          height: l
        };
        f = 2 * Math.floor(this.plotBorderWidth / 2);
        b = Math.ceil(Math.max(f, g[3]) / 2);
        c = Math.ceil(Math.max(f, g[0]) / 2);
        this.clipBox = {
          x: b,
          y: c,
          width: Math.floor(this.plotSizeX - Math.max(f, g[1]) / 2 - b),
          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(f, g[2]) / 2 - c))
        };
        a || d(this.axes, function (a) {
          a.setAxisSize();
          a.setAxisTranslation();
        });
        r(this, "afterSetChartSize", {
          skipAxes: a
        });
      },
      resetMargins: function resetMargins() {
        var a = this,
            b = a.options.chart;
        d(["margin", "spacing"], function (c) {
          var e = b[c],
              h = f(e) ? e : [e, e, e, e];
          d(["Top", "Right", "Bottom", "Left"], function (d, f) {
            a[c][f] = p(b[c + d], h[f]);
          });
        });
        d(J, function (b, c) {
          a[b] = p(a.margin[c], a.spacing[c]);
        });
        a.axisOffset = [0, 0, 0, 0];
        a.clipOffset = [0, 0, 0, 0];
      },
      drawChartBox: function drawChartBox() {
        var a = this.options.chart,
            b = this.renderer,
            c = this.chartWidth,
            d = this.chartHeight,
            f = this.chartBackground,
            e = this.plotBackground,
            h = this.plotBorder,
            g,
            p,
            z = this.plotLeft,
            n = this.plotTop,
            l = this.plotWidth,
            D = this.plotHeight,
            w = this.plotBox,
            q = this.clipRect,
            m = this.clipBox,
            F = "animate";
        f || (this.chartBackground = f = b.rect().addClass("highcharts-background").add(), F = "attr");
        g = p = f.strokeWidth();
        f[F]({
          x: p / 2,
          y: p / 2,
          width: c - p - g % 2,
          height: d - p - g % 2,
          r: a.borderRadius
        });
        F = "animate";
        e || (F = "attr", this.plotBackground = e = b.rect().addClass("highcharts-plot-background").add());
        e[F](w);
        q ? q.animate({
          width: m.width,
          height: m.height
        }) : this.clipRect = b.clipRect(m);
        F = "animate";
        h || (F = "attr", this.plotBorder = h = b.rect().addClass("highcharts-plot-border").attr({
          zIndex: 1
        }).add());
        h[F](h.crisp({
          x: z,
          y: n,
          width: l,
          height: D
        }, -h.strokeWidth()));
        this.isDirtyBox = !1;
        r(this, "afterDrawChartBox");
      },
      propFromSeries: function propFromSeries() {
        var a = this,
            b = a.options.chart,
            c,
            f = a.options.series,
            e,
            h;
        d(["inverted", "angular", "polar"], function (d) {
          c = F[b.type || b.defaultSeriesType];
          h = b[d] || c && c.prototype[d];

          for (e = f && f.length; !h && e--;) {
            (c = F[f[e].type]) && c.prototype[d] && (h = !0);
          }

          a[d] = h;
        });
      },
      linkSeries: function linkSeries() {
        var a = this,
            b = a.series;
        d(b, function (a) {
          a.linkedSeries.length = 0;
        });
        d(b, function (b) {
          var c = b.options.linkedTo;
          q(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = p(b.options.visible, c.options.visible, b.visible));
        });
        r(this, "afterLinkSeries");
      },
      renderSeries: function renderSeries() {
        d(this.series, function (a) {
          a.translate();
          a.render();
        });
      },
      renderLabels: function renderLabels() {
        var a = this,
            b = a.options.labels;
        b.items && d(b.items, function (d) {
          var f = c(b.style, d.style),
              e = D(f.left) + a.plotLeft,
              h = D(f.top) + a.plotTop + 12;
          delete f.left;
          delete f.top;
          a.renderer.text(d.html, e, h).attr({
            zIndex: 2
          }).css(f).add();
        });
      },
      render: function render() {
        var a = this.axes,
            b = this.renderer,
            c = this.options,
            f,
            e,
            h;
        this.setTitle();
        this.legend = new G(this, c.legend);
        this.getStacks && this.getStacks();
        this.getMargins(!0);
        this.setChartSize();
        c = this.plotWidth;
        f = this.plotHeight = Math.max(this.plotHeight - 21, 0);
        d(a, function (a) {
          a.setScale();
        });
        this.getAxisMargins();
        e = 1.1 < c / this.plotWidth;
        h = 1.05 < f / this.plotHeight;
        if (e || h) d(a, function (a) {
          (a.horiz && e || !a.horiz && h) && a.setTickInterval(!0);
        }), this.getMargins();
        this.drawChartBox();
        this.hasCartesianSeries && d(a, function (a) {
          a.visible && a.render();
        });
        this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({
          zIndex: 3
        }).add());
        this.renderSeries();
        this.renderLabels();
        this.addCredits();
        this.setResponsive && this.setResponsive();
        this.hasRendered = !0;
      },
      addCredits: function addCredits(a) {
        var b = this;
        a = B(!0, this.options.credits, a);
        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
          a.href && (y.location.href = a.href);
        }).attr({
          align: a.position.align,
          zIndex: 8
        }).add().align(a.position), this.credits.update = function (a) {
          b.credits = b.credits.destroy();
          b.addCredits(a);
        });
      },
      destroy: function destroy() {
        var b = this,
            c = b.axes,
            f = b.series,
            e = b.container,
            h,
            g = e && e.parentNode;
        r(b, "destroy");
        b.renderer.forExport ? a.erase(t, b) : t[b.index] = void 0;
        a.chartCount--;
        b.renderTo.removeAttribute("data-highcharts-chart");
        z(b);

        for (h = c.length; h--;) {
          c[h] = c[h].destroy();
        }

        this.scroller && this.scroller.destroy && this.scroller.destroy();

        for (h = f.length; h--;) {
          f[h] = f[h].destroy();
        }

        d("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "), function (a) {
          var c = b[a];
          c && c.destroy && (b[a] = c.destroy());
        });
        e && (e.innerHTML = "", z(e), g && u(e));
        H(b, function (a, c) {
          delete b[c];
        });
      },
      firstRender: function firstRender() {
        var a = this,
            b = a.options;

        if (!a.isReadyToRender || a.isReadyToRender()) {
          a.getContainer();
          a.resetMargins();
          a.setChartSize();
          a.propFromSeries();
          a.getAxes();
          d(b.series || [], function (b) {
            a.initSeries(b);
          });
          a.linkSeries();
          r(a, "beforeRender");
          w && (a.pointer = new w(a, b));
          a.render();
          if (!a.renderer.imgCount && a.onload) a.onload();
          a.temporaryDisplay(!0);
        }
      },
      onload: function onload() {
        d([this.callback].concat(this.callbacks), function (a) {
          a && void 0 !== this.index && a.apply(this, [this]);
        }, this);
        r(this, "load");
        r(this, "render");
        l(this.index) && this.setReflow(this.options.chart.reflow);
        this.onload = null;
      }
    });
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.Chart,
        E = a.each;
    A(C, "afterSetChartSize", function (m) {
      var g = this.options.chart.scrollablePlotArea;
      (g = g && g.minWidth) && !this.renderer.forExport && (this.scrollablePixels = g = Math.max(0, g - this.chartWidth)) && (this.plotWidth += g, this.clipBox.width += g, m.skipAxes || E(this.axes, function (e) {
        1 === e.side ? e.getPlotLinePath = function () {
          var g = this.right,
              m;
          this.right = g - e.chart.scrollablePixels;
          m = a.Axis.prototype.getPlotLinePath.apply(this, arguments);
          this.right = g;
          return m;
        } : (e.setAxisSize(), e.setAxisTranslation());
      }));
    });
    A(C, "render", function () {
      this.scrollablePixels ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
    });

    C.prototype.setUpScrolling = function () {
      this.scrollingContainer = a.createElement("div", {
        className: "highcharts-scrolling"
      }, {
        overflowX: "auto",
        WebkitOverflowScrolling: "touch"
      }, this.renderTo);
      this.innerContainer = a.createElement("div", {
        className: "highcharts-inner-container"
      }, null, this.scrollingContainer);
      this.innerContainer.appendChild(this.container);
      this.setUpScrolling = null;
    };

    C.prototype.applyFixed = function () {
      var m = this.container,
          g,
          e,
          v = !this.fixedDiv;
      v && (this.fixedDiv = a.createElement("div", {
        className: "highcharts-fixed"
      }, {
        position: "absolute",
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: 2
      }, null, !0), this.renderTo.insertBefore(this.fixedDiv, this.renderTo.firstChild), this.fixedRenderer = g = new a.Renderer(this.fixedDiv, 0, 0), this.scrollableMask = g.path().attr({
        fill: a.color(this.options.chart.backgroundColor || "#fff").setOpacity(.85).get(),
        zIndex: -1
      }).addClass("highcharts-scrollable-mask").add(), a.each([this.inverted ? ".highcharts-xaxis" : ".highcharts-yaxis", this.inverted ? ".highcharts-xaxis-labels" : ".highcharts-yaxis-labels", ".highcharts-contextbutton", ".highcharts-credits", ".highcharts-legend", ".highcharts-subtitle", ".highcharts-title", ".highcharts-legend-checkbox"], function (e) {
        a.each(m.querySelectorAll(e), function (a) {
          (a.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(a);
          a.style.pointerEvents = "auto";
        });
      }));
      this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
      e = this.chartWidth + this.scrollablePixels;
      a.stop(this.container);
      this.container.style.width = e + "px";
      this.renderer.boxWrapper.attr({
        width: e,
        height: this.chartHeight,
        viewBox: [0, 0, e, this.chartHeight].join(" ")
      });
      this.chartBackground.attr({
        width: e
      });
      v && (e = this.options.chart.scrollablePlotArea, e.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixels * e.scrollPositionX));
      v = this.axisOffset;
      e = this.plotTop - v[0] - 1;
      var v = this.plotTop + this.plotHeight + v[2],
          u = this.plotLeft + this.plotWidth - this.scrollablePixels;
      this.scrollableMask.attr({
        d: this.scrollablePixels ? ["M", 0, e, "L", this.plotLeft - 1, e, "L", this.plotLeft - 1, v, "L", 0, v, "Z", "M", u, e, "L", this.chartWidth, e, "L", this.chartWidth, v, "L", u, v, "Z"] : ["M", 0, 0]
      });
    };
  })(K);

  (function (a) {
    var A,
        C = a.each,
        E = a.extend,
        m = a.erase,
        g = a.fireEvent,
        e = a.format,
        v = a.isArray,
        u = a.isNumber,
        t = a.pick,
        l = a.removeEvent;

    a.Point = A = function A() {};

    a.Point.prototype = {
      init: function init(a, c, e) {
        var d = a.chart.options.chart.colorCount;
        this.series = a;
        this.applyOptions(c, e);
        a.options.colorByPoint ? (c = a.colorCounter, a.colorCounter++, a.colorCounter === d && (a.colorCounter = 0)) : c = a.colorIndex;
        this.colorIndex = t(this.colorIndex, c);
        a.chart.pointCount++;
        g(this, "afterInit");
        return this;
      },
      applyOptions: function applyOptions(a, c) {
        var d = this.series,
            e = d.options.pointValKey || d.pointValKey;
        a = A.prototype.optionsToObject.call(this, a);
        E(this, a);
        this.options = this.options ? E(this.options, a) : a;
        a.group && delete this.group;
        e && (this.y = this[e]);
        this.isNull = t(this.isValid && !this.isValid(), null === this.x || !u(this.y, !0));
        this.selected && (this.state = "select");
        "name" in this && void 0 === c && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
        void 0 === this.x && d && (this.x = void 0 === c ? d.autoIncrement(this) : c);
        return this;
      },
      setNestedProperty: function setNestedProperty(d, c, e) {
        e = e.split(".");
        a.reduce(e, function (d, e, b, f) {
          d[e] = f.length - 1 === b ? c : a.isObject(d[e], !0) ? d[e] : {};
          return d[e];
        }, d);
        return d;
      },
      optionsToObject: function optionsToObject(d) {
        var c = {},
            e = this.series,
            g = e.options.keys,
            n = g || e.pointArrayMap || ["y"],
            b = n.length,
            f = 0,
            l = 0;
        if (u(d) || null === d) c[n[0]] = d;else if (v(d)) for (!g && d.length > b && (e = _typeof(d[0]), "string" === e ? c.name = d[0] : "number" === e && (c.x = d[0]), f++); l < b;) {
          g && void 0 === d[f] || (0 < n[l].indexOf(".") ? a.Point.prototype.setNestedProperty(c, d[f], n[l]) : c[n[l]] = d[f]), f++, l++;
        } else "object" === _typeof(d) && (c = d, d.dataLabels && (e._hasPointLabels = !0), d.marker && (e._hasPointMarkers = !0));
        return c;
      },
      getClassName: function getClassName() {
        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
      },
      getZone: function getZone() {
        var a = this.series,
            c = a.zones,
            a = a.zoneAxis || "y",
            e = 0,
            g;

        for (g = c[e]; this[a] >= g.value;) {
          g = c[++e];
        }

        this.nonZonedColor || (this.nonZonedColor = this.color);
        this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;
        return g;
      },
      destroy: function destroy() {
        var a = this.series.chart,
            c = a.hoverPoints,
            e;
        a.pointCount--;
        c && (this.setState(), m(c, this), c.length || (a.hoverPoints = null));
        if (this === a.hoverPoint) this.onMouseOut();
        if (this.graphic || this.dataLabel) l(this), this.destroyElements();
        this.legendItem && a.legend.destroyItem(this);

        for (e in this) {
          this[e] = null;
        }
      },
      destroyElements: function destroyElements() {
        for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], c, e = 6; e--;) {
          c = a[e], this[c] && (this[c] = this[c].destroy());
        }
      },
      getLabelConfig: function getLabelConfig() {
        return {
          x: this.category,
          y: this.y,
          color: this.color,
          colorIndex: this.colorIndex,
          key: this.name || this.category,
          series: this.series,
          point: this,
          percentage: this.percentage,
          total: this.total || this.stackTotal
        };
      },
      tooltipFormatter: function tooltipFormatter(a) {
        var c = this.series,
            d = c.tooltipOptions,
            g = t(d.valueDecimals, ""),
            l = d.valuePrefix || "",
            b = d.valueSuffix || "";
        C(c.pointArrayMap || ["y"], function (c) {
          c = "{point." + c;
          if (l || b) a = a.replace(RegExp(c + "}", "g"), l + c + "}" + b);
          a = a.replace(RegExp(c + "}", "g"), c + ":,." + g + "f}");
        });
        return e(a, {
          point: this,
          series: this.series
        }, c.chart.time);
      },
      firePointEvent: function firePointEvent(a, c, e) {
        var d = this,
            l = this.series.options;
        (l.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();
        "click" === a && l.allowPointSelect && (e = function e(a) {
          d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
        });
        g(this, a, c, e);
      },
      visible: !0
    };
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.animObject,
        E = a.arrayMax,
        m = a.arrayMin,
        g = a.correctFloat,
        e = a.defaultOptions,
        v = a.defined,
        u = a.each,
        t = a.erase,
        l = a.extend,
        d = a.fireEvent,
        c = a.grep,
        x = a.isArray,
        r = a.isNumber,
        n = a.isString,
        b = a.merge,
        f = a.objectEach,
        q = a.pick,
        G = a.removeEvent,
        J = a.splat,
        B = a.SVGElement,
        H = a.syncTimeout,
        w = a.win;
    a.Series = a.seriesType("line", null, {
      allowPointSelect: !1,
      showCheckbox: !1,
      animation: {
        duration: 1E3
      },
      events: {},
      marker: {
        enabledThreshold: 2,
        radius: 4,
        states: {
          normal: {
            animation: !0
          },
          hover: {
            animation: {
              duration: 50
            },
            enabled: !0,
            radiusPlus: 2
          }
        }
      },
      point: {
        events: {}
      },
      dataLabels: {
        align: "center",
        formatter: function formatter() {
          return null === this.y ? "" : a.numberFormat(this.y, -1);
        },
        verticalAlign: "bottom",
        x: 0,
        y: 0,
        padding: 5
      },
      cropThreshold: 300,
      pointRange: 0,
      softThreshold: !0,
      states: {
        normal: {
          animation: !0
        },
        hover: {
          animation: {
            duration: 50
          },
          lineWidthPlus: 1,
          marker: {},
          halo: {
            size: 10
          }
        },
        select: {}
      },
      stickyTracking: !0,
      turboThreshold: 1E3,
      findNearestPointBy: "x"
    }, {
      isCartesian: !0,
      pointClass: a.Point,
      sorted: !0,
      requireSorting: !0,
      directTouch: !1,
      axisTypes: ["xAxis", "yAxis"],
      colorCounter: 0,
      parallelArrays: ["x", "y"],
      coll: "series",
      init: function init(a, b) {
        var c = this,
            e,
            g = a.series,
            h;
        c.chart = a;
        c.options = b = c.setOptions(b);
        c.linkedSeries = [];
        c.bindAxes();
        l(c, {
          name: b.name,
          state: "",
          visible: !1 !== b.visible,
          selected: !0 === b.selected
        });
        e = b.events;
        f(e, function (a, b) {
          A(c, b, a);
        });
        if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;
        c.getColor();
        c.getSymbol();
        u(c.parallelArrays, function (a) {
          c[a + "Data"] = [];
        });
        c.setData(b.data, !1);
        c.isCartesian && (a.hasCartesianSeries = !0);
        g.length && (h = g[g.length - 1]);
        c._i = q(h && h._i, -1) + 1;
        a.orderSeries(this.insert(g));
        d(this, "afterInit");
      },
      insert: function insert(a) {
        var b = this.options.index,
            c;

        if (r(b)) {
          for (c = a.length; c--;) {
            if (b >= q(a[c].options.index, a[c]._i)) {
              a.splice(c + 1, 0, this);
              break;
            }
          }

          -1 === c && a.unshift(this);
          c += 1;
        } else a.push(this);

        return q(c, a.length - 1);
      },
      bindAxes: function bindAxes() {
        var b = this,
            c = b.options,
            d = b.chart,
            e;
        u(b.axisTypes || [], function (f) {
          u(d[f], function (a) {
            e = a.options;
            if (c[f] === e.index || void 0 !== c[f] && c[f] === e.id || void 0 === c[f] && 0 === e.index) b.insert(a.series), b[f] = a, a.isDirty = !0;
          });
          b[f] || b.optionalAxis === f || a.error(18, !0);
        });
      },
      updateParallelArrays: function updateParallelArrays(a, b) {
        var c = a.series,
            d = arguments,
            e = r(b) ? function (d) {
          var e = "y" === d && c.toYData ? c.toYData(a) : a[d];
          c[d + "Data"][b] = e;
        } : function (a) {
          Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
        };
        u(c.parallelArrays, e);
      },
      autoIncrement: function autoIncrement() {
        var a = this.options,
            b = this.xIncrement,
            c,
            d = a.pointIntervalUnit,
            e = this.chart.time,
            b = q(b, a.pointStart, 0);
        this.pointInterval = c = q(this.pointInterval, a.pointInterval, 1);
        d && (a = new e.Date(b), "day" === d ? e.set("Date", a, e.get("Date", a) + c) : "month" === d ? e.set("Month", a, e.get("Month", a) + c) : "year" === d && e.set("FullYear", a, e.get("FullYear", a) + c), c = a.getTime() - b);
        this.xIncrement = b + c;
        return b;
      },
      setOptions: function setOptions(a) {
        var c = this.chart,
            f = c.options,
            g = f.plotOptions,
            p = (c.userOptions || {}).plotOptions || {},
            h = g[this.type];
        this.userOptions = a;
        c = b(h, g.series, a);
        this.tooltipOptions = b(e.tooltip, e.plotOptions.series && e.plotOptions.series.tooltip, e.plotOptions[this.type].tooltip, f.tooltip.userOptions, g.series && g.series.tooltip, g[this.type].tooltip, a.tooltip);
        this.stickyTracking = q(a.stickyTracking, p[this.type] && p[this.type].stickyTracking, p.series && p.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : c.stickyTracking);
        null === h.marker && delete c.marker;
        this.zoneAxis = c.zoneAxis;
        a = this.zones = (c.zones || []).slice();
        !c.negativeColor && !c.negativeFillColor || c.zones || a.push({
          value: c[this.zoneAxis + "Threshold"] || c.threshold || 0,
          className: "highcharts-negative"
        });
        a.length && v(a[a.length - 1].value) && a.push({});
        d(this, "afterSetOptions", {
          options: c
        });
        return c;
      },
      getName: function getName() {
        return this.name || "Series " + (this.index + 1);
      },
      getCyclic: function getCyclic(a, b, c) {
        var d,
            e = this.chart,
            f = this.userOptions,
            g = a + "Index",
            p = a + "Counter",
            k = c ? c.length : q(e.options.chart[a + "Count"], e[a + "Count"]);
        b || (d = q(f[g], f["_" + g]), v(d) || (e.series.length || (e[p] = 0), f["_" + g] = d = e[p] % k, e[p] += 1), c && (b = c[d]));
        void 0 !== d && (this[g] = d);
        this[a] = b;
      },
      getColor: function getColor() {
        this.getCyclic("color");
      },
      getSymbol: function getSymbol() {
        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,
      updateData: function updateData(b) {
        var c = this.options,
            d = this.points,
            e = [],
            f,
            h,
            g,
            p = this.requireSorting;
        u(b, function (b) {
          var h;
          h = a.defined(b) && this.pointClass.prototype.optionsToObject.call({
            series: this
          }, b).x;
          r(h) && (h = a.inArray(h, this.xData, g), -1 === h ? e.push(b) : b !== c.data[h] ? (d[h].update(b, !1, null, !1), d[h].touched = !0, p && (g = h)) : d[h] && (d[h].touched = !0), f = !0);
        }, this);
        if (f) for (b = d.length; b--;) {
          h = d[b], h.touched || h.remove(!1), h.touched = !1;
        } else if (b.length === d.length) u(b, function (a, b) {
          d[b].update && a !== c.data[b] && d[b].update(a, !1, null, !1);
        });else return !1;
        u(e, function (a) {
          this.addPoint(a, !1);
        }, this);
        return !0;
      },
      setData: function setData(b, c, d, e) {
        var f = this,
            h = f.points,
            g = h && h.length || 0,
            p,
            k = f.options,
            l = f.chart,
            z = null,
            w = f.xAxis,
            D = k.turboThreshold,
            m = this.xData,
            F = this.yData,
            B = (p = f.pointArrayMap) && p.length,
            t;
        b = b || [];
        p = b.length;
        c = q(c, !0);
        !1 !== e && p && g && !f.cropped && !f.hasGroupedData && f.visible && !f.isSeriesBoosting && (t = this.updateData(b));

        if (!t) {
          f.xIncrement = null;
          f.colorCounter = 0;
          u(this.parallelArrays, function (a) {
            f[a + "Data"].length = 0;
          });

          if (D && p > D) {
            for (d = 0; null === z && d < p;) {
              z = b[d], d++;
            }

            if (r(z)) for (d = 0; d < p; d++) {
              m[d] = this.autoIncrement(), F[d] = b[d];
            } else if (x(z)) {
              if (B) for (d = 0; d < p; d++) {
                z = b[d], m[d] = z[0], F[d] = z.slice(1, B + 1);
              } else for (d = 0; d < p; d++) {
                z = b[d], m[d] = z[0], F[d] = z[1];
              }
            } else a.error(12);
          } else for (d = 0; d < p; d++) {
            void 0 !== b[d] && (z = {
              series: f
            }, f.pointClass.prototype.applyOptions.apply(z, [b[d]]), f.updateParallelArrays(z, d));
          }

          F && n(F[0]) && a.error(14, !0);
          f.data = [];
          f.options.data = f.userOptions.data = b;

          for (d = g; d--;) {
            h[d] && h[d].destroy && h[d].destroy();
          }

          w && (w.minRange = w.userMinRange);
          f.isDirty = l.isDirtyBox = !0;
          f.isDirtyData = !!h;
          d = !1;
        }

        "point" === k.legendType && (this.processData(), this.generatePoints());
        c && l.redraw(d);
      },
      processData: function processData(b) {
        var c = this.xData,
            d = this.yData,
            e = c.length,
            f;
        f = 0;
        var h,
            g,
            p = this.xAxis,
            k,
            l = this.options;
        k = l.cropThreshold;
        var n = this.getExtremesFromAll || l.getExtremesFromAll,
            w = this.isCartesian,
            l = p && p.val2lin,
            r = p && p.isLog,
            m = this.requireSorting,
            q,
            B;
        if (w && !this.isDirty && !p.isDirty && !this.yAxis.isDirty && !b) return !1;
        p && (b = p.getExtremes(), q = b.min, B = b.max);
        w && this.sorted && !n && (!k || e > k || this.forceCrop) && (c[e - 1] < q || c[0] > B ? (c = [], d = []) : this.yData && (c[0] < q || c[e - 1] > B) && (f = this.cropData(this.xData, this.yData, q, B), c = f.xData, d = f.yData, f = f.start, h = !0));

        for (k = c.length || 1; --k;) {
          e = r ? l(c[k]) - l(c[k - 1]) : c[k] - c[k - 1], 0 < e && (void 0 === g || e < g) ? g = e : 0 > e && m && (a.error(15), m = !1);
        }

        this.cropped = h;
        this.cropStart = f;
        this.processedXData = c;
        this.processedYData = d;
        this.closestPointRange = g;
      },
      cropData: function cropData(a, b, c, d, e) {
        var f = a.length,
            g = 0,
            p = f,
            k;
        e = q(e, this.cropShoulder, 1);

        for (k = 0; k < f; k++) {
          if (a[k] >= c) {
            g = Math.max(0, k - e);
            break;
          }
        }

        for (c = k; c < f; c++) {
          if (a[c] > d) {
            p = c + e;
            break;
          }
        }

        return {
          xData: a.slice(g, p),
          yData: b.slice(g, p),
          start: g,
          end: p
        };
      },
      generatePoints: function generatePoints() {
        var a = this.options,
            b = a.data,
            c = this.data,
            d,
            e = this.processedXData,
            f = this.processedYData,
            g = this.pointClass,
            l = e.length,
            k = this.cropStart || 0,
            n,
            w = this.hasGroupedData,
            a = a.keys,
            r,
            m = [],
            q;
        c || w || (c = [], c.length = b.length, c = this.data = c);
        a && w && (this.options.keys = !1);

        for (q = 0; q < l; q++) {
          n = k + q, w ? (r = new g().init(this, [e[q]].concat(J(f[q]))), r.dataGroup = this.groupMap[q]) : (r = c[n]) || void 0 === b[n] || (c[n] = r = new g().init(this, b[n], e[q])), r && (r.index = n, m[q] = r);
        }

        this.options.keys = a;
        if (c && (l !== (d = c.length) || w)) for (q = 0; q < d; q++) {
          q !== k || w || (q += l), c[q] && (c[q].destroyElements(), c[q].plotX = void 0);
        }
        this.data = c;
        this.points = m;
      },
      getExtremes: function getExtremes(a) {
        var b = this.yAxis,
            c = this.processedXData,
            d,
            e = [],
            f = 0;
        d = this.xAxis.getExtremes();
        var g = d.min,
            p = d.max,
            k,
            l,
            n = this.requireSorting ? 1 : 0,
            w,
            q;
        a = a || this.stackedYData || this.processedYData || [];
        d = a.length;

        for (q = 0; q < d; q++) {
          if (l = c[q], w = a[q], k = (r(w, !0) || x(w)) && (!b.positiveValuesOnly || w.length || 0 < w), l = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (c[q + n] || l) >= g && (c[q - n] || l) <= p, k && l) if (k = w.length) for (; k--;) {
            "number" === typeof w[k] && (e[f++] = w[k]);
          } else e[f++] = w;
        }

        this.dataMin = m(e);
        this.dataMax = E(e);
      },
      translate: function translate() {
        this.processedXData || this.processData();
        this.generatePoints();
        var a = this.options,
            b = a.stacking,
            c = this.xAxis,
            e = c.categories,
            f = this.yAxis,
            h = this.points,
            l = h.length,
            n = !!this.modifyValue,
            k = a.pointPlacement,
            w = "between" === k || r(k),
            m = a.threshold,
            B = a.startFromThreshold ? m : 0,
            u,
            t,
            x,
            H,
            G = Number.MAX_VALUE;
        "between" === k && (k = .5);
        r(k) && (k *= q(a.pointRange || c.pointRange));

        for (a = 0; a < l; a++) {
          var J = h[a],
              A = J.x,
              C = J.y;
          t = J.low;
          var E = b && f.stacks[(this.negStacks && C < (B ? 0 : m) ? "-" : "") + this.stackKey],
              K;
          f.positiveValuesOnly && null !== C && 0 >= C && (J.isNull = !0);
          J.plotX = u = g(Math.min(Math.max(-1E5, c.translate(A, 0, 0, 0, 1, k, "flags" === this.type)), 1E5));
          b && this.visible && !J.isNull && E && E[A] && (H = this.getStackIndicator(H, A, this.index), K = E[A], C = K.points[H.key], t = C[0], C = C[1], t === B && H.key === E[A].base && (t = q(r(m) && m, f.min)), f.positiveValuesOnly && 0 >= t && (t = null), J.total = J.stackTotal = K.total, J.percentage = K.total && J.y / K.total * 100, J.stackY = C, K.setOffset(this.pointXOffset || 0, this.barW || 0));
          J.yBottom = v(t) ? Math.min(Math.max(-1E5, f.translate(t, 0, 1, 0, 1)), 1E5) : null;
          n && (C = this.modifyValue(C, J));
          J.plotY = t = "number" === typeof C && Infinity !== C ? Math.min(Math.max(-1E5, f.translate(C, 0, 1, 0, 1)), 1E5) : void 0;
          J.isInside = void 0 !== t && 0 <= t && t <= f.len && 0 <= u && u <= c.len;
          J.clientX = w ? g(c.translate(A, 0, 0, 0, 1, k)) : u;
          J.negative = J.y < (m || 0);
          J.category = e && void 0 !== e[J.x] ? e[J.x] : J.x;
          J.isNull || (void 0 !== x && (G = Math.min(G, Math.abs(u - x))), x = u);
          J.zone = this.zones.length && J.getZone();
        }

        this.closestPointRangePx = G;
        d(this, "afterTranslate");
      },
      getValidPoints: function getValidPoints(a, b) {
        var d = this.chart;
        return c(a || this.points || [], function (a) {
          return b && !d.isInsidePlot(a.plotX, a.plotY, d.inverted) ? !1 : !a.isNull;
        });
      },
      setClip: function setClip(a) {
        var b = this.chart,
            c = this.options,
            d = b.renderer,
            e = b.inverted,
            f = this.clipBox,
            g = f || b.clipBox,
            p = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(),
            k = b[p],
            l = b[p + "m"];
        k || (a && (g.width = 0, e && (g.x = b.plotSizeX), b[p + "m"] = l = d.clipRect(e ? b.plotSizeX + 99 : -99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight)), b[p] = k = d.clipRect(g), k.count = {
          length: 0
        });
        a && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);
        !1 !== c.clip && (this.group.clip(a || f ? k : b.clipRect), this.markerGroup.clip(l), this.sharedClipKey = p);
        a || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && p && b[p] && (f || (b[p] = b[p].destroy()), b[p + "m"] && (b[p + "m"] = b[p + "m"].destroy())));
      },
      animate: function animate(a) {
        var b = this.chart,
            c = C(this.options.animation),
            d;
        a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({
          width: b.plotSizeX,
          x: 0
        }, c), b[d + "m"] && b[d + "m"].animate({
          width: b.plotSizeX + 99,
          x: 0
        }, c), this.animate = null);
      },
      afterAnimate: function afterAnimate() {
        this.setClip();
        d(this, "afterAnimate");
        this.finishedAnimating = !0;
      },
      drawPoints: function drawPoints() {
        var a = this.points,
            b = this.chart,
            c,
            d,
            e,
            f,
            g = this.options.marker,
            l,
            k,
            n,
            w = this[this.specialGroup] || this.markerGroup,
            r,
            m = q(g.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= g.enabledThreshold * g.radius);
        if (!1 !== g.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++) {
          d = a[c], f = d.graphic, l = d.marker || {}, k = !!d.marker, e = m && void 0 === l.enabled || l.enabled, n = d.isInside, e && !d.isNull ? (e = q(l.symbol, this.symbol), r = this.markerAttribs(d, d.selected && "select"), f ? f[n ? "show" : "hide"](!0).animate(r) : n && (0 < r.width || d.hasImage) && (d.graphic = f = b.renderer.symbol(e, r.x, r.y, r.width, r.height, k ? l : g).add(w)), f && f.addClass(d.getClassName(), !0)) : f && (d.graphic = f.destroy());
        }
      },
      markerAttribs: function markerAttribs(a, b) {
        var c = this.options.marker,
            d = a.marker || {},
            e = d.symbol || c.symbol,
            f = q(d.radius, c.radius);
        b && (c = c.states[b], b = d.states && d.states[b], f = q(b && b.radius, c && c.radius, f + (c && c.radiusPlus || 0)));
        a.hasImage = e && 0 === e.indexOf("url");
        a.hasImage && (f = 0);
        a = {
          x: Math.floor(a.plotX) - f,
          y: a.plotY - f
        };
        f && (a.width = a.height = 2 * f);
        return a;
      },
      destroy: function destroy() {
        var b = this,
            c = b.chart,
            e = /AppleWebKit\/533/.test(w.navigator.userAgent),
            g,
            l,
            h = b.data || [],
            n,
            r;
        d(b, "destroy");
        G(b);
        u(b.axisTypes || [], function (a) {
          (r = b[a]) && r.series && (t(r.series, b), r.isDirty = r.forceRedraw = !0);
        });
        b.legendItem && b.chart.legend.destroyItem(b);

        for (l = h.length; l--;) {
          (n = h[l]) && n.destroy && n.destroy();
        }

        b.points = null;
        a.clearTimeout(b.animationTimeout);
        f(b, function (a, b) {
          a instanceof B && !a.survive && (g = e && "group" === b ? "hide" : "destroy", a[g]());
        });
        c.hoverSeries === b && (c.hoverSeries = null);
        t(c.series, b);
        c.orderSeries();
        f(b, function (a, c) {
          delete b[c];
        });
      },
      getGraphPath: function getGraphPath(a, b, c) {
        var d = this,
            e = d.options,
            f = e.step,
            g,
            p = [],
            k = [],
            l;
        a = a || d.points;
        (g = a.reversed) && a.reverse();
        (f = {
          right: 1,
          center: 2
        }[f] || f && 3) && g && (f = 4 - f);
        !e.connectNulls || b || c || (a = this.getValidPoints(a));
        u(a, function (h, g) {
          var n = h.plotX,
              w = h.plotY,
              r = a[g - 1];
          (h.leftCliff || r && r.rightCliff) && !c && (l = !0);
          h.isNull && !v(b) && 0 < g ? l = !e.connectNulls : h.isNull && !b ? l = !0 : (0 === g || l ? g = ["M", h.plotX, h.plotY] : d.getPointSpline ? g = d.getPointSpline(a, h, g) : f ? (g = 1 === f ? ["L", r.plotX, w] : 2 === f ? ["L", (r.plotX + n) / 2, r.plotY, "L", (r.plotX + n) / 2, w] : ["L", n, r.plotY], g.push("L", n, w)) : g = ["L", n, w], k.push(h.x), f && (k.push(h.x), 2 === f && k.push(h.x)), p.push.apply(p, g), l = !1);
        });
        p.xMap = k;
        return d.graphPath = p;
      },
      drawGraph: function drawGraph() {
        var a = this,
            b = (this.gappedPath || this.getGraphPath).call(this),
            c = [["graph", "highcharts-graph"]],
            c = a.getZonesGraphs(c);
        u(c, function (c, d) {
          d = c[0];
          var e = a[d];
          e ? (e.endX = a.preventGraphAnimation ? null : b.xMap, e.animate({
            d: b
          })) : b.length && (a[d] = a.chart.renderer.path(b).addClass(c[1]).attr({
            zIndex: 1
          }).add(a.group));
          e && (e.startX = b.xMap, e.isArea = b.isArea);
        });
      },
      getZonesGraphs: function getZonesGraphs(a) {
        u(this.zones, function (b, c) {
          a.push(["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "")]);
        }, this);
        return a;
      },
      applyZones: function applyZones() {
        var a = this,
            b = this.chart,
            c = b.renderer,
            d = this.zones,
            e,
            f,
            g = this.clips || [],
            l,
            k = this.graph,
            n = this.area,
            w = Math.max(b.chartWidth, b.chartHeight),
            r = this[(this.zoneAxis || "y") + "Axis"],
            m,
            B,
            t = b.inverted,
            H,
            x,
            v,
            G,
            J = !1;
        d.length && (k || n) && r && void 0 !== r.min && (B = r.reversed, H = r.horiz, k && !this.showLine && k.hide(), n && n.hide(), m = r.getExtremes(), u(d, function (d, h) {
          e = B ? H ? b.plotWidth : 0 : H ? 0 : r.toPixels(m.min);
          e = Math.min(Math.max(q(f, e), 0), w);
          f = Math.min(Math.max(Math.round(r.toPixels(q(d.value, m.max), !0)), 0), w);
          J && (e = f = r.toPixels(m.max));
          x = Math.abs(e - f);
          v = Math.min(e, f);
          G = Math.max(e, f);
          r.isXAxis ? (l = {
            x: t ? G : v,
            y: 0,
            width: x,
            height: w
          }, H || (l.x = b.plotHeight - l.x)) : (l = {
            x: 0,
            y: t ? G : v,
            width: w,
            height: x
          }, H && (l.y = b.plotWidth - l.y));
          g[h] ? g[h].animate(l) : (g[h] = c.clipRect(l), k && a["zone-graph-" + h].clip(g[h]), n && a["zone-area-" + h].clip(g[h]));
          J = d.value > m.max;
          a.resetZones && 0 === f && (f = void 0);
        }), this.clips = g);
      },
      invertGroups: function invertGroups(a) {
        function b() {
          u(["group", "markerGroup"], function (b) {
            c[b] && (d.renderer.isVML && c[b].attr({
              width: c.yAxis.len,
              height: c.xAxis.len
            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));
          });
        }

        var c = this,
            d = c.chart,
            e;
        c.xAxis && (e = A(d, "resize", b), A(c, "destroy", e), b(a), c.invertGroups = b);
      },
      plotGroup: function plotGroup(a, b, c, d, e) {
        var f = this[a],
            g = !f;
        g && (this[a] = f = this.chart.renderer.g().attr({
          zIndex: d || .1
        }).add(e));
        f.addClass("highcharts-" + b + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (v(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (f.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
        f.attr({
          visibility: c
        })[g ? "attr" : "animate"](this.getPlotBox());
        return f;
      },
      getPlotBox: function getPlotBox() {
        var a = this.chart,
            b = this.xAxis,
            c = this.yAxis;
        a.inverted && (b = c, c = this.xAxis);
        return {
          translateX: b ? b.left : a.plotLeft,
          translateY: c ? c.top : a.plotTop,
          scaleX: 1,
          scaleY: 1
        };
      },
      render: function render() {
        var a = this,
            b = a.chart,
            c,
            e = a.options,
            f = !!a.animate && b.renderer.isSVG && C(e.animation).duration,
            h = a.visible ? "inherit" : "hidden",
            g = e.zIndex,
            l = a.hasRendered,
            k = b.seriesGroup,
            n = b.inverted;
        c = a.plotGroup("group", "series", h, g, k);
        a.markerGroup = a.plotGroup("markerGroup", "markers", h, g, k);
        f && a.animate(!0);
        c.inverted = a.isCartesian ? n : !1;
        a.drawGraph && (a.drawGraph(), a.applyZones());
        a.drawDataLabels && a.drawDataLabels();
        a.visible && a.drawPoints();
        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
        a.invertGroups(n);
        !1 === e.clip || a.sharedClipKey || l || c.clip(b.clipRect);
        f && a.animate();
        l || (a.animationTimeout = H(function () {
          a.afterAnimate();
        }, f));
        a.isDirty = !1;
        a.hasRendered = !0;
        d(a, "afterRender");
      },
      redraw: function redraw() {
        var a = this.chart,
            b = this.isDirty || this.isDirtyData,
            c = this.group,
            d = this.xAxis,
            e = this.yAxis;
        c && (a.inverted && c.attr({
          width: a.plotWidth,
          height: a.plotHeight
        }), c.animate({
          translateX: q(d && d.left, a.plotLeft),
          translateY: q(e && e.top, a.plotTop)
        }));
        this.translate();
        this.render();
        b && delete this.kdTree;
      },
      kdAxisArray: ["clientX", "plotY"],
      searchPoint: function searchPoint(a, b) {
        var c = this.xAxis,
            d = this.yAxis,
            e = this.chart.inverted;
        return this.searchKDTree({
          clientX: e ? c.len - a.chartY + c.pos : a.chartX - c.pos,
          plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos
        }, b);
      },
      buildKDTree: function buildKDTree() {
        function a(c, d, e) {
          var f, g;
          if (g = c && c.length) return f = b.kdAxisArray[d % e], c.sort(function (a, b) {
            return a[f] - b[f];
          }), g = Math.floor(g / 2), {
            point: c[g],
            left: a(c.slice(0, g), d + 1, e),
            right: a(c.slice(g + 1), d + 1, e)
          };
        }

        this.buildingKdTree = !0;
        var b = this,
            c = -1 < b.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        delete b.kdTree;
        H(function () {
          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);
          b.buildingKdTree = !1;
        }, b.options.kdNow ? 0 : 1);
      },
      searchKDTree: function searchKDTree(a, b) {
        function c(a, b, h, l) {
          var k = b.point,
              n = d.kdAxisArray[h % l],
              p,
              w,
              r = k;
          w = v(a[e]) && v(k[e]) ? Math.pow(a[e] - k[e], 2) : null;
          p = v(a[f]) && v(k[f]) ? Math.pow(a[f] - k[f], 2) : null;
          p = (w || 0) + (p || 0);
          k.dist = v(p) ? Math.sqrt(p) : Number.MAX_VALUE;
          k.distX = v(w) ? Math.sqrt(w) : Number.MAX_VALUE;
          n = a[n] - k[n];
          p = 0 > n ? "left" : "right";
          w = 0 > n ? "right" : "left";
          b[p] && (p = c(a, b[p], h + 1, l), r = p[g] < r[g] ? p : k);
          b[w] && Math.sqrt(n * n) < r[g] && (a = c(a, b[w], h + 1, l), r = a[g] < r[g] ? a : r);
          return r;
        }

        var d = this,
            e = this.kdAxisArray[0],
            f = this.kdAxisArray[1],
            g = b ? "distX" : "dist";
        b = -1 < d.options.findNearestPointBy.indexOf("y") ? 2 : 1;
        this.kdTree || this.buildingKdTree || this.buildKDTree();
        if (this.kdTree) return c(a, this.kdTree, b, b);
      }
    });
  })(K);

  (function (a) {
    var A = a.Axis,
        C = a.Chart,
        E = a.correctFloat,
        m = a.defined,
        g = a.destroyObjectProperties,
        e = a.each,
        v = a.format,
        u = a.objectEach,
        t = a.pick,
        l = a.Series;

    a.StackItem = function (a, c, e, g, l) {
      var b = a.chart.inverted;
      this.axis = a;
      this.isNegative = e;
      this.options = c;
      this.x = g;
      this.total = null;
      this.points = {};
      this.stack = l;
      this.rightCliff = this.leftCliff = 0;
      this.alignOptions = {
        align: c.align || (b ? e ? "left" : "right" : "center"),
        verticalAlign: c.verticalAlign || (b ? "middle" : e ? "bottom" : "top"),
        y: t(c.y, b ? 4 : e ? 14 : -6),
        x: t(c.x, b ? e ? -6 : 6 : 0)
      };
      this.textAlign = c.textAlign || (b ? e ? "right" : "left" : "center");
    };

    a.StackItem.prototype = {
      destroy: function destroy() {
        g(this, this.axis);
      },
      render: function render(a) {
        var c = this.axis.chart,
            d = this.options,
            e = d.format,
            e = e ? v(e, this, c.time) : d.formatter.call(this);
        this.label ? this.label.attr({
          text: e,
          visibility: "hidden"
        }) : this.label = c.renderer.text(e, null, null, d.useHTML).css(d.style).attr({
          align: this.textAlign,
          rotation: d.rotation,
          visibility: "hidden"
        }).add(a);
        this.label.labelrank = c.plotHeight;
      },
      setOffset: function setOffset(a, c) {
        var d = this.axis,
            e = d.chart,
            g = d.translate(d.usePercentage ? 100 : this.total, 0, 0, 0, 1),
            b = d.translate(0),
            b = m(g) && Math.abs(g - b);
        a = e.xAxis[0].translate(this.x) + a;
        d = m(g) && this.getStackBox(e, this, a, g, c, b, d);
        (c = this.label) && d && (c.align(this.alignOptions, null, d), d = c.alignAttr, c[!1 === this.options.crop || e.isInsidePlot(d.x, d.y) ? "show" : "hide"](!0));
      },
      getStackBox: function getStackBox(a, c, e, g, l, b, f) {
        var d = c.axis.reversed,
            n = a.inverted;
        a = f.height + f.pos - (n ? a.plotLeft : a.plotTop);
        c = c.isNegative && !d || !c.isNegative && d;
        return {
          x: n ? c ? g : g - b : e,
          y: n ? a - e - l : c ? a - g - b : a - g,
          width: n ? b : l,
          height: n ? l : b
        };
      }
    };

    C.prototype.getStacks = function () {
      var a = this;
      e(a.yAxis, function (a) {
        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);
      });
      e(a.series, function (c) {
        !c.options.stacking || !0 !== c.visible && !1 !== a.options.chart.ignoreHiddenSeries || (c.stackKey = c.type + t(c.options.stack, ""));
      });
    };

    A.prototype.buildStacks = function () {
      var a = this.series,
          c = t(this.options.reversedStacks, !0),
          e = a.length,
          g;

      if (!this.isXAxis) {
        this.usePercentage = !1;

        for (g = e; g--;) {
          a[c ? g : e - g - 1].setStackedPoints();
        }

        for (g = 0; g < e; g++) {
          a[g].modifyStacks();
        }
      }
    };

    A.prototype.renderStackTotals = function () {
      var a = this.chart,
          c = a.renderer,
          e = this.stacks,
          g = this.stackTotalGroup;
      g || (this.stackTotalGroup = g = c.g("stack-labels").attr({
        visibility: "visible",
        zIndex: 6
      }).add());
      g.translate(a.plotLeft, a.plotTop);
      u(e, function (a) {
        u(a, function (a) {
          a.render(g);
        });
      });
    };

    A.prototype.resetStacks = function () {
      var a = this,
          c = a.stacks;
      a.isXAxis || u(c, function (c) {
        u(c, function (d, e) {
          d.touched < a.stacksTouched ? (d.destroy(), delete c[e]) : (d.total = null, d.cumulative = null);
        });
      });
    };

    A.prototype.cleanStacks = function () {
      var a;
      this.isXAxis || (this.oldStacks && (a = this.stacks = this.oldStacks), u(a, function (a) {
        u(a, function (a) {
          a.cumulative = a.total;
        });
      }));
    };

    l.prototype.setStackedPoints = function () {
      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
        var d = this.processedXData,
            c = this.processedYData,
            e = [],
            g = c.length,
            l = this.options,
            b = l.threshold,
            f = t(l.startFromThreshold && b, 0),
            q = l.stack,
            l = l.stacking,
            u = this.stackKey,
            v = "-" + u,
            B = this.negStacks,
            H = this.yAxis,
            w = H.stacks,
            p = H.oldStacks,
            D,
            z,
            F,
            A,
            h,
            y,
            C;
        H.stacksTouched += 1;

        for (h = 0; h < g; h++) {
          y = d[h], C = c[h], D = this.getStackIndicator(D, y, this.index), A = D.key, F = (z = B && C < (f ? 0 : b)) ? v : u, w[F] || (w[F] = {}), w[F][y] || (p[F] && p[F][y] ? (w[F][y] = p[F][y], w[F][y].total = null) : w[F][y] = new a.StackItem(H, H.options.stackLabels, z, y, q)), F = w[F][y], null !== C ? (F.points[A] = F.points[this.index] = [t(F.cumulative, f)], m(F.cumulative) || (F.base = A), F.touched = H.stacksTouched, 0 < D.index && !1 === this.singleStacks && (F.points[A][0] = F.points[this.index + "," + y + ",0"][0])) : F.points[A] = F.points[this.index] = null, "percent" === l ? (z = z ? u : v, B && w[z] && w[z][y] ? (z = w[z][y], F.total = z.total = Math.max(z.total, F.total) + Math.abs(C) || 0) : F.total = E(F.total + (Math.abs(C) || 0))) : F.total = E(F.total + (C || 0)), F.cumulative = t(F.cumulative, f) + (C || 0), null !== C && (F.points[A].push(F.cumulative), e[h] = F.cumulative);
        }

        "percent" === l && (H.usePercentage = !0);
        this.stackedYData = e;
        H.oldStacks = {};
      }
    };

    l.prototype.modifyStacks = function () {
      var a = this,
          c = a.stackKey,
          g = a.yAxis.stacks,
          l = a.processedXData,
          n,
          b = a.options.stacking;
      a[b + "Stacker"] && e([c, "-" + c], function (c) {
        for (var d = l.length, e, f; d--;) {
          if (e = l[d], n = a.getStackIndicator(n, e, a.index, c), f = (e = g[c] && g[c][e]) && e.points[n.key]) a[b + "Stacker"](f, e, d);
        }
      });
    };

    l.prototype.percentStacker = function (a, c, e) {
      c = c.total ? 100 / c.total : 0;
      a[0] = E(a[0] * c);
      a[1] = E(a[1] * c);
      this.stackedYData[e] = a[1];
    };

    l.prototype.getStackIndicator = function (a, c, e, g) {
      !m(a) || a.x !== c || g && a.key !== g ? a = {
        x: c,
        index: 0,
        key: g
      } : a.index++;
      a.key = [e, c, a.index].join();
      return a;
    };
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.Axis,
        E = a.createElement,
        m = a.css,
        g = a.defined,
        e = a.each,
        v = a.erase,
        u = a.extend,
        t = a.fireEvent,
        l = a.inArray,
        d = a.isNumber,
        c = a.isObject,
        x = a.isArray,
        r = a.merge,
        n = a.objectEach,
        b = a.pick,
        f = a.Point,
        q = a.Series,
        G = a.seriesTypes,
        J = a.setAnimation,
        B = a.splat;
    u(a.Chart.prototype, {
      addSeries: function addSeries(a, c, d) {
        var e,
            f = this;
        a && (c = b(c, !0), t(f, "addSeries", {
          options: a
        }, function () {
          e = f.initSeries(a);
          f.isDirtyLegend = !0;
          f.linkSeries();
          t(f, "afterAddSeries");
          c && f.redraw(d);
        }));
        return e;
      },
      addAxis: function addAxis(a, c, d, e) {
        var f = c ? "xAxis" : "yAxis",
            g = this.options;
        a = r(a, {
          index: this[f].length,
          isX: c
        });
        c = new C(this, a);
        g[f] = B(g[f] || {});
        g[f].push(a);
        b(d, !0) && this.redraw(e);
        return c;
      },
      showLoading: function showLoading(a) {
        var b = this,
            c = b.options,
            d = b.loadingDiv,
            e = function e() {
          d && m(d, {
            left: b.plotLeft + "px",
            top: b.plotTop + "px",
            width: b.plotWidth + "px",
            height: b.plotHeight + "px"
          });
        };

        d || (b.loadingDiv = d = E("div", {
          className: "highcharts-loading highcharts-loading-hidden"
        }, null, b.container), b.loadingSpan = E("span", {
          className: "highcharts-loading-inner"
        }, null, d), A(b, "redraw", e));
        d.className = "highcharts-loading";
        b.loadingSpan.innerHTML = a || c.lang.loading;
        b.loadingShown = !0;
        e();
      },
      hideLoading: function hideLoading() {
        var a = this.loadingDiv;
        a && (a.className = "highcharts-loading highcharts-loading-hidden");
        this.loadingShown = !1;
      },
      propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
      update: function update(a, c, f, m) {
        var p = this,
            w = {
          credits: "addCredits",
          title: "setTitle",
          subtitle: "setSubtitle"
        },
            q = a.chart,
            h,
            u,
            v = [];
        t(p, "update", {
          options: a
        });

        if (q) {
          r(!0, p.options.chart, q);
          "className" in q && p.setClassName(q.className);
          "reflow" in q && p.setReflow(q.reflow);
          if ("inverted" in q || "polar" in q || "type" in q) p.propFromSeries(), h = !0;
          "alignTicks" in q && (h = !0);
          n(q, function (a, b) {
            -1 !== l("chart." + b, p.propsRequireUpdateSeries) && (u = !0);
            -1 !== l(b, p.propsRequireDirtyBox) && (p.isDirtyBox = !0);
          });
        }

        a.plotOptions && r(!0, this.options.plotOptions, a.plotOptions);
        n(a, function (a, b) {
          if (p[b] && "function" === typeof p[b].update) p[b].update(a, !1);else if ("function" === typeof p[w[b]]) p[w[b]](a);
          "chart" !== b && -1 !== l(b, p.propsRequireUpdateSeries) && (u = !0);
        });
        e("xAxis yAxis zAxis series colorAxis pane".split(" "), function (b) {
          var c;
          a[b] && ("series" === b && (c = [], e(p[b], function (a, b) {
            a.options.isInternal || c.push(b);
          })), e(B(a[b]), function (a, d) {
            (d = g(a.id) && p.get(a.id) || p[b][c ? c[d] : d]) && d.coll === b && (d.update(a, !1), f && (d.touched = !0));
            if (!d && f) if ("series" === b) p.addSeries(a, !1).touched = !0;else if ("xAxis" === b || "yAxis" === b) p.addAxis(a, "xAxis" === b, !1).touched = !0;
          }), f && e(p[b], function (a) {
            a.touched || a.options.isInternal ? delete a.touched : v.push(a);
          }));
        });
        e(v, function (a) {
          a.remove(!1);
        });
        h && e(p.axes, function (a) {
          a.update({}, !1);
        });
        u && e(p.series, function (a) {
          a.update({}, !1);
        });
        a.loading && r(!0, p.options.loading, a.loading);
        h = q && q.width;
        q = q && q.height;
        d(h) && h !== p.chartWidth || d(q) && q !== p.chartHeight ? p.setSize(h, q, m) : b(c, !0) && p.redraw(m);
        t(p, "afterUpdate", {
          options: a
        });
      },
      setSubtitle: function setSubtitle(a) {
        this.setTitle(void 0, a);
      }
    });
    u(f.prototype, {
      update: function update(a, d, e, f) {
        function g() {
          l.applyOptions(a);
          null === l.y && h && (l.graphic = h.destroy());
          c(a, !0) && (h && h.element && a && a.marker && void 0 !== a.marker.symbol && (l.graphic = h.destroy()), a && a.dataLabels && l.dataLabel && (l.dataLabel = l.dataLabel.destroy()), l.connector && (l.connector = l.connector.destroy()));
          n = l.index;
          p.updateParallelArrays(l, n);
          k.data[n] = c(k.data[n], !0) || c(a, !0) ? l.options : b(a, k.data[n]);
          p.isDirty = p.isDirtyData = !0;
          !p.fixedBox && p.hasCartesianSeries && (w.isDirtyBox = !0);
          "point" === k.legendType && (w.isDirtyLegend = !0);
          d && w.redraw(e);
        }

        var l = this,
            p = l.series,
            h = l.graphic,
            n,
            w = p.chart,
            k = p.options;
        d = b(d, !0);
        !1 === f ? g() : l.firePointEvent("update", {
          options: a
        }, g);
      },
      remove: function remove(a, b) {
        this.series.removePoint(l(this, this.series.data), a, b);
      }
    });
    u(q.prototype, {
      addPoint: function addPoint(a, c, d, e) {
        var f = this.options,
            g = this.data,
            l = this.chart,
            h = this.xAxis,
            h = h && h.hasNames && h.names,
            p = f.data,
            n,
            k,
            w = this.xData,
            q,
            m;
        c = b(c, !0);
        n = {
          series: this
        };
        this.pointClass.prototype.applyOptions.apply(n, [a]);
        m = n.x;
        q = w.length;
        if (this.requireSorting && m < w[q - 1]) for (k = !0; q && w[q - 1] > m;) {
          q--;
        }
        this.updateParallelArrays(n, "splice", q, 0, 0);
        this.updateParallelArrays(n, q);
        h && n.name && (h[m] = n.name);
        p.splice(q, 0, a);
        k && (this.data.splice(q, 0, null), this.processData());
        "point" === f.legendType && this.generatePoints();
        d && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), this.updateParallelArrays(n, "shift"), p.shift()));
        this.isDirtyData = this.isDirty = !0;
        c && l.redraw(e);
      },
      removePoint: function removePoint(a, c, d) {
        var e = this,
            f = e.data,
            g = f[a],
            l = e.points,
            h = e.chart,
            p = function p() {
          l && l.length === f.length && l.splice(a, 1);
          f.splice(a, 1);
          e.options.data.splice(a, 1);
          e.updateParallelArrays(g || {
            series: e
          }, "splice", a, 1);
          g && g.destroy();
          e.isDirty = !0;
          e.isDirtyData = !0;
          c && h.redraw();
        };

        J(d, h);
        c = b(c, !0);
        g ? g.firePointEvent("remove", null, p) : p();
      },
      remove: function remove(a, c, d) {
        function e() {
          f.destroy();
          g.isDirtyLegend = g.isDirtyBox = !0;
          g.linkSeries();
          b(a, !0) && g.redraw(c);
        }

        var f = this,
            g = f.chart;
        !1 !== d ? t(f, "remove", null, e) : e();
      },
      update: function update(c, d) {
        var f = this,
            g = f.chart,
            n = f.userOptions,
            q = f.oldType || f.type,
            w = c.type || n.type || g.options.chart.type,
            h = G[q].prototype,
            m,
            B = ["group", "markerGroup", "dataLabelsGroup"],
            k = ["navigatorSeries", "baseSeries"],
            v = f.finishedAnimating && {
          animation: !1
        },
            x = ["data", "name", "turboThreshold"],
            H = a.keys(c),
            J = 0 < H.length;
        e(H, function (a) {
          -1 === l(a, x) && (J = !1);
        });
        if (J) c.data && this.setData(c.data, !1), c.name && this.setName(c.name, !1);else {
          k = B.concat(k);
          e(k, function (a) {
            k[a] = f[a];
            delete f[a];
          });
          c = r(n, v, {
            index: f.index,
            pointStart: b(n.pointStart, f.xData[0])
          }, {
            data: f.options.data
          }, c);
          f.remove(!1, null, !1);

          for (m in h) {
            f[m] = void 0;
          }

          G[w || q] ? u(f, G[w || q].prototype) : a.error(17, !0);
          e(k, function (a) {
            f[a] = k[a];
          });
          f.init(g, c);
          c.zIndex !== n.zIndex && e(B, function (a) {
            f[a] && f[a].attr({
              zIndex: c.zIndex
            });
          });
          f.oldType = q;
          g.linkSeries();
        }
        t(this, "afterUpdate");
        b(d, !0) && g.redraw(!1);
      },
      setName: function setName(a) {
        this.name = this.options.name = this.userOptions.name = a;
        this.chart.isDirtyLegend = !0;
      }
    });
    u(C.prototype, {
      update: function update(a, c) {
        var d = this.chart,
            e = a && a.events || {};
        a = r(this.userOptions, a);
        d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);
        n(d.options[this.coll].events, function (a, b) {
          "undefined" === typeof e[b] && (e[b] = void 0);
        });
        this.destroy(!0);
        this.init(d, u(a, {
          events: e
        }));
        d.isDirtyBox = !0;
        b(c, !0) && d.redraw();
      },
      remove: function remove(a) {
        for (var c = this.chart, d = this.coll, f = this.series, g = f.length; g--;) {
          f[g] && f[g].remove(!1);
        }

        v(c.axes, this);
        v(c[d], this);
        x(c.options[d]) ? c.options[d].splice(this.options.index, 1) : delete c.options[d];
        e(c[d], function (a, b) {
          a.options.index = a.userOptions.index = b;
        });
        this.destroy();
        c.isDirtyBox = !0;
        b(a, !0) && c.redraw();
      },
      setTitle: function setTitle(a, b) {
        this.update({
          title: a
        }, b);
      },
      setCategories: function setCategories(a, b) {
        this.update({
          categories: a
        }, b);
      }
    });
  })(K);

  (function (a) {
    var A = a.each,
        C = a.map,
        E = a.pick,
        m = a.Series,
        g = a.seriesType;
    g("area", "line", {
      softThreshold: !1,
      threshold: 0
    }, {
      singleStacks: !1,
      getStackPoints: function getStackPoints(e) {
        var g = [],
            m = [],
            t = this.xAxis,
            l = this.yAxis,
            d = l.stacks[this.stackKey],
            c = {},
            x = this.index,
            r = l.series,
            n = r.length,
            b,
            f = E(l.options.reversedStacks, !0) ? 1 : -1,
            q;
        e = e || this.points;

        if (this.options.stacking) {
          for (q = 0; q < e.length; q++) {
            e[q].leftNull = e[q].rightNull = null, c[e[q].x] = e[q];
          }

          a.objectEach(d, function (a, b) {
            null !== a.total && m.push(b);
          });
          m.sort(function (a, b) {
            return a - b;
          });
          b = C(r, function () {
            return this.visible;
          });
          A(m, function (a, e) {
            var r = 0,
                u,
                w;
            if (c[a] && !c[a].isNull) g.push(c[a]), A([-1, 1], function (g) {
              var l = 1 === g ? "rightNull" : "leftNull",
                  p = 0,
                  r = d[m[e + g]];
              if (r) for (q = x; 0 <= q && q < n;) {
                u = r.points[q], u || (q === x ? c[a][l] = !0 : b[q] && (w = d[a].points[q]) && (p -= w[1] - w[0])), q += f;
              }
              c[a][1 === g ? "rightCliff" : "leftCliff"] = p;
            });else {
              for (q = x; 0 <= q && q < n;) {
                if (u = d[a].points[q]) {
                  r = u[1];
                  break;
                }

                q += f;
              }

              r = l.translate(r, 0, 1, 0, 1);
              g.push({
                isNull: !0,
                plotX: t.translate(a, 0, 0, 0, 1),
                x: a,
                plotY: r,
                yBottom: r
              });
            }
          });
        }

        return g;
      },
      getGraphPath: function getGraphPath(a) {
        var e = m.prototype.getGraphPath,
            g = this.options,
            t = g.stacking,
            l = this.yAxis,
            d,
            c,
            x = [],
            r = [],
            n = this.index,
            b,
            f = l.stacks[this.stackKey],
            q = g.threshold,
            G = l.getThreshold(g.threshold),
            J,
            g = g.connectNulls || "percent" === t,
            B = function B(c, d, e) {
          var g = a[c];
          c = t && f[g.x].points[n];
          var p = g[e + "Null"] || 0;
          e = g[e + "Cliff"] || 0;
          var m,
              w,
              g = !0;
          e || p ? (m = (p ? c[0] : c[1]) + e, w = c[0] + e, g = !!p) : !t && a[d] && a[d].isNull && (m = w = q);
          void 0 !== m && (r.push({
            plotX: b,
            plotY: null === m ? G : l.getThreshold(m),
            isNull: g,
            isCliff: !0
          }), x.push({
            plotX: b,
            plotY: null === w ? G : l.getThreshold(w),
            doCurve: !1
          }));
        };

        a = a || this.points;
        t && (a = this.getStackPoints(a));

        for (d = 0; d < a.length; d++) {
          if (c = a[d].isNull, b = E(a[d].rectPlotX, a[d].plotX), J = E(a[d].yBottom, G), !c || g) g || B(d, d - 1, "left"), c && !t && g || (r.push(a[d]), x.push({
            x: d,
            plotX: b,
            plotY: J
          })), g || B(d, d + 1, "right");
        }

        d = e.call(this, r, !0, !0);
        x.reversed = !0;
        c = e.call(this, x, !0, !0);
        c.length && (c[0] = "L");
        c = d.concat(c);
        e = e.call(this, r, !1, g);
        c.xMap = d.xMap;
        this.areaPath = c;
        return e;
      },
      drawGraph: function drawGraph() {
        this.areaPath = [];
        m.prototype.drawGraph.apply(this);
        var a = this,
            g = this.areaPath,
            u = this.options,
            t = [["area", "highcharts-area"]];
        A(this.zones, function (a, d) {
          t.push(["zone-area-" + d, "highcharts-area highcharts-zone-area-" + d + " " + a.className]);
        });
        A(t, function (e) {
          var d = e[0],
              c = a[d];
          c ? (c.endX = a.preventGraphAnimation ? null : g.xMap, c.animate({
            d: g
          })) : (c = a[d] = a.chart.renderer.path(g).addClass(e[1]).attr({
            zIndex: 0
          }).add(a.group), c.isArea = !0);
          c.startX = g.xMap;
          c.shiftUnit = u.step ? 2 : 1;
        });
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
    });
  })(K);

  (function (a) {
    var A = a.pick;
    a = a.seriesType;
    a("spline", "line", {}, {
      getPointSpline: function getPointSpline(a, E, m) {
        var g = E.plotX,
            e = E.plotY,
            v = a[m - 1];
        m = a[m + 1];
        var u, t, l, d;

        if (v && !v.isNull && !1 !== v.doCurve && !E.isCliff && m && !m.isNull && !1 !== m.doCurve && !E.isCliff) {
          a = v.plotY;
          l = m.plotX;
          m = m.plotY;
          var c = 0;
          u = (1.5 * g + v.plotX) / 2.5;
          t = (1.5 * e + a) / 2.5;
          l = (1.5 * g + l) / 2.5;
          d = (1.5 * e + m) / 2.5;
          l !== u && (c = (d - t) * (l - g) / (l - u) + e - d);
          t += c;
          d += c;
          t > a && t > e ? (t = Math.max(a, e), d = 2 * e - t) : t < a && t < e && (t = Math.min(a, e), d = 2 * e - t);
          d > m && d > e ? (d = Math.max(m, e), t = 2 * e - d) : d < m && d < e && (d = Math.min(m, e), t = 2 * e - d);
          E.rightContX = l;
          E.rightContY = d;
        }

        E = ["C", A(v.rightContX, v.plotX), A(v.rightContY, v.plotY), A(u, g), A(t, e), g, e];
        v.rightContX = v.rightContY = null;
        return E;
      }
    });
  })(K);

  (function (a) {
    var A = a.seriesTypes.area.prototype,
        C = a.seriesType;
    C("areaspline", "spline", a.defaultPlotOptions.area, {
      getStackPoints: A.getStackPoints,
      getGraphPath: A.getGraphPath,
      drawGraph: A.drawGraph,
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle
    });
  })(K);

  (function (a) {
    var A = a.animObject,
        C = a.each,
        E = a.extend,
        m = a.isNumber,
        g = a.merge,
        e = a.pick,
        v = a.Series,
        u = a.seriesType,
        t = a.svg;
    u("column", "line", {
      borderRadius: 0,
      crisp: !0,
      groupPadding: .2,
      marker: null,
      pointPadding: .1,
      minPointLength: 0,
      cropThreshold: 50,
      pointRange: null,
      states: {
        hover: {
          halo: !1
        }
      },
      dataLabels: {
        align: null,
        verticalAlign: null,
        y: null
      },
      softThreshold: !1,
      startFromThreshold: !0,
      stickyTracking: !1,
      tooltip: {
        distance: 6
      },
      threshold: 0
    }, {
      cropShoulder: 0,
      directTouch: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      negStacks: !0,
      init: function init() {
        v.prototype.init.apply(this, arguments);
        var a = this,
            d = a.chart;
        d.hasRendered && C(d.series, function (c) {
          c.type === a.type && (c.isDirty = !0);
        });
      },
      getColumnMetrics: function getColumnMetrics() {
        var a = this,
            d = a.options,
            c = a.xAxis,
            g = a.yAxis,
            m = c.options.reversedStacks,
            m = c.reversed && !m || !c.reversed && m,
            n,
            b = {},
            f = 0;
        !1 === d.grouping ? f = 1 : C(a.chart.series, function (c) {
          var d = c.options,
              e = c.yAxis,
              l;
          c.type !== a.type || !c.visible && a.chart.options.chart.ignoreHiddenSeries || g.len !== e.len || g.pos !== e.pos || (d.stacking ? (n = c.stackKey, void 0 === b[n] && (b[n] = f++), l = b[n]) : !1 !== d.grouping && (l = f++), c.columnIndex = l);
        });
        var q = Math.min(Math.abs(c.transA) * (c.ordinalSlope || d.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),
            u = q * d.groupPadding,
            t = (q - 2 * u) / (f || 1),
            d = Math.min(d.maxPointWidth || c.len, e(d.pointWidth, t * (1 - 2 * d.pointPadding)));
        a.columnMetrics = {
          width: d,
          offset: (t - d) / 2 + (u + ((a.columnIndex || 0) + (m ? 1 : 0)) * t - q / 2) * (m ? -1 : 1)
        };
        return a.columnMetrics;
      },
      crispCol: function crispCol(a, d, c, e) {
        var g = this.chart,
            l = this.borderWidth,
            b = -(l % 2 ? .5 : 0),
            l = l % 2 ? .5 : 1;
        g.inverted && g.renderer.isVML && (l += 1);
        this.options.crisp && (c = Math.round(a + c) + b, a = Math.round(a) + b, c -= a);
        e = Math.round(d + e) + l;
        b = .5 >= Math.abs(d) && .5 < e;
        d = Math.round(d) + l;
        e -= d;
        b && e && (--d, e += 1);
        return {
          x: a,
          y: d,
          width: c,
          height: e
        };
      },
      translate: function translate() {
        var a = this,
            d = a.chart,
            c = a.options,
            g = a.dense = 2 > a.closestPointRange * a.xAxis.transA,
            g = a.borderWidth = e(c.borderWidth, g ? 0 : 1),
            m = a.yAxis,
            n = c.threshold,
            b = a.translatedThreshold = m.getThreshold(n),
            f = e(c.minPointLength, 5),
            q = a.getColumnMetrics(),
            u = q.width,
            t = a.barW = Math.max(u, 1 + 2 * g),
            B = a.pointXOffset = q.offset;
        d.inverted && (b -= .5);
        c.pointPadding && (t = Math.ceil(t));
        v.prototype.translate.apply(a);
        C(a.points, function (c) {
          var g = e(c.yBottom, b),
              l = 999 + Math.abs(g),
              l = Math.min(Math.max(-l, c.plotY), m.len + l),
              q = c.plotX + B,
              r = t,
              v = Math.min(l, g),
              x,
              h = Math.max(l, g) - v;
          f && Math.abs(h) < f && (h = f, x = !m.reversed && !c.negative || m.reversed && c.negative, c.y === n && a.dataMax <= n && m.min < n && (x = !x), v = Math.abs(v - b) > f ? g - f : b - (x ? f : 0));
          c.barX = q;
          c.pointWidth = u;
          c.tooltipPos = d.inverted ? [m.len + m.pos - d.plotLeft - l, a.xAxis.len - q - r / 2, h] : [q + r / 2, l + m.pos - d.plotTop, h];
          c.shapeType = "rect";
          c.shapeArgs = a.crispCol.apply(a, c.isNull ? [q, b, r, 0] : [q, v, r, h]);
        });
      },
      getSymbol: a.noop,
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      drawGraph: function drawGraph() {
        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
      },
      drawPoints: function drawPoints() {
        var a = this,
            d = this.chart,
            c = a.options,
            e = d.renderer,
            r = c.animationLimit || 250,
            n;
        C(a.points, function (b) {
          var f = b.graphic,
              l = f && d.pointCount < r ? "animate" : "attr";

          if (m(b.plotY) && null !== b.y) {
            n = b.shapeArgs;
            if (f) f[l](g(n));else b.graphic = f = e[b.shapeType](n).add(b.group || a.group);
            c.borderRadius && f.attr({
              r: c.borderRadius
            });
            f.addClass(b.getClassName(), !0);
          } else f && (b.graphic = f.destroy());
        });
      },
      animate: function animate(a) {
        var d = this,
            c = this.yAxis,
            e = d.options,
            g = this.chart.inverted,
            l = {},
            b = g ? "translateX" : "translateY",
            f;
        t && (a ? (l.scaleY = .001, a = Math.min(c.pos + c.len, Math.max(c.pos, c.toPixels(e.threshold))), g ? l.translateX = a - c.len : l.translateY = a, d.group.attr(l)) : (f = d.group.attr(b), d.group.animate({
          scaleY: 1
        }, E(A(d.options.animation), {
          step: function step(a, e) {
            l[b] = f + e.pos * (c.pos - f);
            d.group.attr(l);
          }
        })), d.animate = null));
      },
      remove: function remove() {
        var a = this,
            d = a.chart;
        d.hasRendered && C(d.series, function (c) {
          c.type === a.type && (c.isDirty = !0);
        });
        v.prototype.remove.apply(a, arguments);
      }
    });
  })(K);

  (function (a) {
    a = a.seriesType;
    a("bar", "column", null, {
      inverted: !0
    });
  })(K);

  (function (a) {
    var A = a.Series;
    a = a.seriesType;
    a("scatter", "line", {
      lineWidth: 0,
      findNearestPointBy: "xy",
      marker: {
        enabled: !0
      },
      tooltip: {
        headerFormat: "<span class=\"highcharts-color-{point.colorIndex}\">\u25CF</span> <span class=\"highcharts-header\"> {series.name}</span><br/>",
        pointFormat: "x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e"
      }
    }, {
      sorted: !1,
      requireSorting: !1,
      noSharedTooltip: !0,
      trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
      takeOrdinalPosition: !1,
      drawGraph: function drawGraph() {
        this.options.lineWidth && A.prototype.drawGraph.call(this);
      }
    });
  })(K);

  (function (a) {
    var A = a.deg2rad,
        C = a.isNumber,
        E = a.pick,
        m = a.relativeLength;
    a.CenteredSeriesMixin = {
      getCenter: function getCenter() {
        var a = this.options,
            e = this.chart,
            v = 2 * (a.slicedOffset || 0),
            u = e.plotWidth - 2 * v,
            e = e.plotHeight - 2 * v,
            t = a.center,
            t = [E(t[0], "50%"), E(t[1], "50%"), a.size || "100%", a.innerSize || 0],
            l = Math.min(u, e),
            d,
            c;

        for (d = 0; 4 > d; ++d) {
          c = t[d], a = 2 > d || 2 === d && /%$/.test(c), t[d] = m(c, [u, e, l, t[2]][d]) + (a ? v : 0);
        }

        t[3] > t[2] && (t[3] = t[2]);
        return t;
      },
      getStartAndEndRadians: function getStartAndEndRadians(a, e) {
        a = C(a) ? a : 0;
        e = C(e) && e > a && 360 > e - a ? e : a + 360;
        return {
          start: A * (a + -90),
          end: A * (e + -90)
        };
      }
    };
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.CenteredSeriesMixin,
        E = a.defined,
        m = a.each,
        g = a.extend,
        e = C.getStartAndEndRadians,
        v = a.inArray,
        u = a.noop,
        t = a.pick,
        l = a.Point,
        d = a.Series,
        c = a.seriesType,
        x = a.setAnimation;
    c("pie", "line", {
      center: [null, null],
      clip: !1,
      colorByPoint: !0,
      dataLabels: {
        allowOverlap: !0,
        distance: 30,
        enabled: !0,
        formatter: function formatter() {
          return this.point.isNull ? void 0 : this.point.name;
        },
        x: 0
      },
      ignoreHiddenPoint: !0,
      legendType: "point",
      marker: null,
      size: null,
      showInLegend: !1,
      slicedOffset: 10,
      stickyTracking: !1,
      tooltip: {
        followPointer: !0
      }
    }, {
      isCartesian: !1,
      requireSorting: !1,
      directTouch: !0,
      noSharedTooltip: !0,
      trackerGroups: ["group", "dataLabelsGroup"],
      axisTypes: [],
      pointAttribs: a.seriesTypes.column.prototype.pointAttribs,
      animate: function animate(a) {
        var c = this,
            b = c.points,
            d = c.startAngleRad;
        a || (m(b, function (a) {
          var b = a.graphic,
              e = a.shapeArgs;
          b && (b.attr({
            r: a.startR || c.center[3] / 2,
            start: d,
            end: d
          }), b.animate({
            r: e.r,
            start: e.start,
            end: e.end
          }, c.options.animation));
        }), c.animate = null);
      },
      updateTotals: function updateTotals() {
        var a,
            c = 0,
            b = this.points,
            d = b.length,
            e,
            g = this.options.ignoreHiddenPoint;

        for (a = 0; a < d; a++) {
          e = b[a], c += g && !e.visible ? 0 : e.isNull ? 0 : e.y;
        }

        this.total = c;

        for (a = 0; a < d; a++) {
          e = b[a], e.percentage = 0 < c && (e.visible || !g) ? e.y / c * 100 : 0, e.total = c;
        }
      },
      generatePoints: function generatePoints() {
        d.prototype.generatePoints.call(this);
        this.updateTotals();
      },
      translate: function translate(a) {
        this.generatePoints();
        var c = 0,
            b = this.options,
            d = b.slicedOffset,
            g = d + (b.borderWidth || 0),
            l,
            m,
            r,
            u = e(b.startAngle, b.endAngle),
            w = this.startAngleRad = u.start,
            u = (this.endAngleRad = u.end) - w,
            p = this.points,
            v,
            z = b.dataLabels.distance,
            b = b.ignoreHiddenPoint,
            x,
            A = p.length,
            h;
        a || (this.center = a = this.getCenter());

        this.getX = function (b, c, d) {
          r = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + d.labelDistance), 1));
          return a[0] + (c ? -1 : 1) * Math.cos(r) * (a[2] / 2 + d.labelDistance);
        };

        for (x = 0; x < A; x++) {
          h = p[x];
          h.labelDistance = t(h.options.dataLabels && h.options.dataLabels.distance, z);
          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, h.labelDistance);
          l = w + c * u;
          if (!b || h.visible) c += h.percentage / 100;
          m = w + c * u;
          h.shapeType = "arc";
          h.shapeArgs = {
            x: a[0],
            y: a[1],
            r: a[2] / 2,
            innerR: a[3] / 2,
            start: Math.round(1E3 * l) / 1E3,
            end: Math.round(1E3 * m) / 1E3
          };
          r = (m + l) / 2;
          r > 1.5 * Math.PI ? r -= 2 * Math.PI : r < -Math.PI / 2 && (r += 2 * Math.PI);
          h.slicedTranslation = {
            translateX: Math.round(Math.cos(r) * d),
            translateY: Math.round(Math.sin(r) * d)
          };
          m = Math.cos(r) * a[2] / 2;
          v = Math.sin(r) * a[2] / 2;
          h.tooltipPos = [a[0] + .7 * m, a[1] + .7 * v];
          h.half = r < -Math.PI / 2 || r > Math.PI / 2 ? 1 : 0;
          h.angle = r;
          l = Math.min(g, h.labelDistance / 5);
          h.labelPos = [a[0] + m + Math.cos(r) * h.labelDistance, a[1] + v + Math.sin(r) * h.labelDistance, a[0] + m + Math.cos(r) * l, a[1] + v + Math.sin(r) * l, a[0] + m, a[1] + v, 0 > h.labelDistance ? "center" : h.half ? "right" : "left", r];
        }
      },
      drawGraph: null,
      drawPoints: function drawPoints() {
        var a = this,
            c = a.chart.renderer,
            b,
            d,
            e;
        m(a.points, function (f) {
          d = f.graphic;
          f.isNull ? d && (f.graphic = d.destroy()) : (e = f.shapeArgs, b = f.getTranslate(), d ? d.setRadialReference(a.center).animate(g(e, b)) : f.graphic = d = c[f.shapeType](e).setRadialReference(a.center).attr(b).add(a.group), d.attr({
            visibility: f.visible ? "inherit" : "hidden"
          }), d.addClass(f.getClassName()));
        });
      },
      searchPoint: u,
      sortByAngle: function sortByAngle(a, c) {
        a.sort(function (a, d) {
          return void 0 !== a.angle && (d.angle - a.angle) * c;
        });
      },
      drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,
      getCenter: C.getCenter,
      getSymbol: u
    }, {
      init: function init() {
        l.prototype.init.apply(this, arguments);
        var a = this,
            c;
        a.name = t(a.name, "Slice");

        c = function c(b) {
          a.slice("select" === b.type);
        };

        A(a, "select", c);
        A(a, "unselect", c);
        return a;
      },
      isValid: function isValid() {
        return a.isNumber(this.y, !0) && 0 <= this.y;
      },
      setVisible: function setVisible(a, c) {
        var b = this,
            d = b.series,
            e = d.chart,
            g = d.options.ignoreHiddenPoint;
        c = t(c, g);
        a !== b.visible && (b.visible = b.options.visible = a = void 0 === a ? !b.visible : a, d.options.data[v(b, d.data)] = b.options, m(["graphic", "dataLabel", "connector", "shadowGroup"], function (c) {
          if (b[c]) b[c][a ? "show" : "hide"](!0);
        }), b.legendItem && e.legend.colorizeItem(b, a), a || "hover" !== b.state || b.setState(""), g && (d.isDirty = !0), c && e.redraw());
      },
      slice: function slice(a, c, b) {
        var d = this.series;
        x(b, d.chart);
        t(c, !0);
        this.sliced = this.options.sliced = E(a) ? a : !this.sliced;
        d.options.data[v(this, d.data)] = this.options;
        this.graphic.animate(this.getTranslate());
      },
      getTranslate: function getTranslate() {
        return this.sliced ? this.slicedTranslation : {
          translateX: 0,
          translateY: 0
        };
      },
      haloPath: function haloPath(a) {
        var c = this.shapeArgs;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {
          innerR: this.shapeArgs.r - 1,
          start: c.start,
          end: c.end
        });
      }
    });
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.arrayMax,
        E = a.defined,
        m = a.each,
        g = a.extend,
        e = a.format,
        v = a.map,
        u = a.merge,
        t = a.noop,
        l = a.pick,
        d = a.relativeLength,
        c = a.Series,
        x = a.seriesTypes,
        r = a.some,
        n = a.stableSort;

    a.distribute = function (b, c, d) {
      function e(a, b) {
        return a.target - b.target;
      }

      var f,
          g = !0,
          q = b,
          w = [],
          p;
      p = 0;
      var u = q.reducedLen || c;

      for (f = b.length; f--;) {
        p += b[f].size;
      }

      if (p > u) {
        n(b, function (a, b) {
          return (b.rank || 0) - (a.rank || 0);
        });

        for (p = f = 0; p <= u;) {
          p += b[f].size, f++;
        }

        w = b.splice(f - 1, b.length);
      }

      n(b, e);

      for (b = v(b, function (a) {
        return {
          size: a.size,
          targets: [a.target],
          align: l(a.align, .5)
        };
      }); g;) {
        for (f = b.length; f--;) {
          g = b[f], p = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = Math.min(Math.max(0, p - g.size * g.align), c - g.size);
        }

        f = b.length;

        for (g = !1; f--;) {
          0 < f && b[f - 1].pos + b[f - 1].size > b[f].pos && (b[f - 1].size += b[f].size, b[f - 1].targets = b[f - 1].targets.concat(b[f].targets), b[f - 1].align = .5, b[f - 1].pos + b[f - 1].size > c && (b[f - 1].pos = c - b[f - 1].size), b.splice(f, 1), g = !0);
        }
      }

      q.push.apply(q, w);
      f = 0;
      r(b, function (b) {
        var e = 0;
        if (r(b.targets, function () {
          q[f].pos = b.pos + e;
          if (Math.abs(q[f].pos - q[f].target) > d) return m(q.slice(0, f + 1), function (a) {
            delete a.pos;
          }), q.reducedLen = (q.reducedLen || c) - .1 * c, q.reducedLen > .1 * c && a.distribute(q, c, d), !0;
          e += q[f].size;
          f++;
        })) return !0;
      });
      n(q, e);
    };

    c.prototype.drawDataLabels = function () {
      function b(a, b) {
        var c = b.filter;
        return c ? (b = c.operator, a = a[c.property], c = c.value, "\x3e" === b && a > c || "\x3c" === b && a < c || "\x3e\x3d" === b && a >= c || "\x3c\x3d" === b && a <= c || "\x3d\x3d" === b && a == c || "\x3d\x3d\x3d" === b && a === c ? !0 : !1) : !0;
      }

      var c = this,
          d = c.chart,
          g = c.options,
          n = g.dataLabels,
          r = c.points,
          t,
          w,
          p = c.hasRendered || 0,
          v,
          z,
          x = l(n.defer, !!g.animation),
          C = d.renderer;
      if (n.enabled || c._hasPointLabels) c.dlProcessOptions && c.dlProcessOptions(n), z = c.plotGroup("dataLabelsGroup", "data-labels", x && !p ? "hidden" : "visible", n.zIndex || 6), x && (z.attr({
        opacity: +p
      }), p || A(c, "afterAnimate", function () {
        c.visible && z.show(!0);
        z[g.animation ? "animate" : "attr"]({
          opacity: 1
        }, {
          duration: 200
        });
      })), w = n, m(r, function (f) {
        var g,
            h = f.dataLabel,
            k,
            p,
            m = f.connector,
            q = !h,
            r;
        t = f.dlOptions || f.options && f.options.dataLabels;
        (g = l(t && t.enabled, w.enabled) && !f.isNull) && (g = !0 === b(f, t || n));
        g && (n = u(w, t), k = f.getLabelConfig(), r = n[f.formatPrefix + "Format"] || n.format, v = E(r) ? e(r, k, d.time) : (n[f.formatPrefix + "Formatter"] || n.formatter).call(k, n), k = n.rotation, p = {
          r: n.borderRadius || 0,
          rotation: k,
          padding: n.padding,
          zIndex: 1
        }, a.objectEach(p, function (a, b) {
          void 0 === a && delete p[b];
        }));
        !h || g && E(v) ? g && E(v) && (h ? p.text = v : (h = f.dataLabel = k ? C.text(v, 0, -9999, n.useHTML).addClass("highcharts-data-label") : C.label(v, 0, -9999, n.shape, null, null, n.useHTML, null, "data-label"), h.addClass(" highcharts-data-label-color-" + f.colorIndex + " " + (n.className || "") + (n.useHTML ? " highcharts-tracker" : ""))), h.attr(p), h.added || h.add(z), c.alignDataLabel(f, h, n, null, q)) : (f.dataLabel = h = h.destroy(), m && (f.connector = m.destroy()));
      });
      a.fireEvent(this, "afterDrawDataLabels");
    };

    c.prototype.alignDataLabel = function (a, c, d, e, n) {
      var b = this.chart,
          f = b.inverted,
          m = l(a.dlBox && a.dlBox.centerX, a.plotX, -9999),
          p = l(a.plotY, -9999),
          q = c.getBBox(),
          r,
          u = d.rotation,
          t = d.align,
          h = this.visible && (a.series.forceDL || b.isInsidePlot(m, Math.round(p), f) || e && b.isInsidePlot(m, f ? e.x + 1 : e.y + e.height - 1, f)),
          v = "justify" === l(d.overflow, "justify");
      if (h && (r = b.renderer.fontMetrics(void 0, c).b, e = g({
        x: f ? this.yAxis.len - p : m,
        y: Math.round(f ? this.xAxis.len - m : p),
        width: 0,
        height: 0
      }, e), g(d, {
        width: q.width,
        height: q.height
      }), u ? (v = !1, m = b.renderer.rotCorr(r, u), m = {
        x: e.x + d.x + e.width / 2 + m.x,
        y: e.y + d.y + {
          top: 0,
          middle: .5,
          bottom: 1
        }[d.verticalAlign] * e.height
      }, c[n ? "attr" : "animate"](m).attr({
        align: t
      }), p = (u + 720) % 360, p = 180 < p && 360 > p, "left" === t ? m.y -= p ? q.height : 0 : "center" === t ? (m.x -= q.width / 2, m.y -= q.height / 2) : "right" === t && (m.x -= q.width, m.y -= p ? 0 : q.height), c.placed = !0, c.alignAttr = m) : (c.align(d, null, e), m = c.alignAttr), v && 0 <= e.height ? a.isLabelJustified = this.justifyDataLabel(c, d, m, q, e, n) : l(d.crop, !0) && (h = b.isInsidePlot(m.x, m.y) && b.isInsidePlot(m.x + q.width, m.y + q.height)), d.shape && !u)) c[n ? "attr" : "animate"]({
        anchorX: f ? b.plotWidth - a.plotY : a.plotX,
        anchorY: f ? b.plotHeight - a.plotX : a.plotY
      });
      h || (c.attr({
        y: -9999
      }), c.placed = !1);
    };

    c.prototype.justifyDataLabel = function (a, c, d, e, g, l) {
      var b = this.chart,
          f = c.align,
          n = c.verticalAlign,
          m,
          q,
          r = a.box ? 0 : a.padding || 0;
      m = d.x + r;
      0 > m && ("right" === f ? c.align = "left" : c.x = -m, q = !0);
      m = d.x + e.width - r;
      m > b.plotWidth && ("left" === f ? c.align = "right" : c.x = b.plotWidth - m, q = !0);
      m = d.y + r;
      0 > m && ("bottom" === n ? c.verticalAlign = "top" : c.y = -m, q = !0);
      m = d.y + e.height - r;
      m > b.plotHeight && ("top" === n ? c.verticalAlign = "bottom" : c.y = b.plotHeight - m, q = !0);
      q && (a.placed = !l, a.align(c, null, g));
      return q;
    };

    x.pie && (x.pie.prototype.drawDataLabels = function () {
      var b = this,
          d = b.data,
          e,
          g = b.chart,
          n = b.options.dataLabels,
          r = l(n.connectorPadding, 10),
          u = l(n.connectorWidth, 1),
          w = g.plotWidth,
          p = g.plotHeight,
          t = Math.round(g.chartWidth / 3),
          v,
          x = b.center,
          A = x[2] / 2,
          h = x[1],
          y,
          N,
          k,
          I,
          K = [[], []],
          Q,
          O,
          P,
          L,
          R = [0, 0, 0, 0];
      b.visible && (n.enabled || b._hasPointLabels) && (m(d, function (a) {
        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
          width: "auto"
        }).css({
          width: "auto",
          textOverflow: "clip"
        }), a.dataLabel.shortened = !1);
      }), c.prototype.drawDataLabels.apply(b), m(d, function (a) {
        a.dataLabel && (a.visible ? (K[a.half].push(a), a.dataLabel._pos = null, a.dataLabel.getBBox().width > t && (a.dataLabel.css({
          width: .7 * t
        }), a.dataLabel.shortened = !0)) : a.dataLabel = a.dataLabel.destroy());
      }), m(K, function (c, d) {
        var f,
            q,
            u = c.length,
            t = [],
            v;
        if (u) for (b.sortByAngle(c, d - .5), 0 < b.maxLabelDistance && (f = Math.max(0, h - A - b.maxLabelDistance), q = Math.min(h + A + b.maxLabelDistance, g.plotHeight), m(c, function (a) {
          0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, h - A - a.labelDistance), a.bottom = Math.min(h + A + a.labelDistance, g.plotHeight), v = a.dataLabel.getBBox().height || 21, a.distributeBox = {
            target: a.labelPos[1] - a.top + v / 2,
            size: v,
            rank: a.y
          }, t.push(a.distributeBox));
        }), f = q + v - f, a.distribute(t, f, f / 5)), L = 0; L < u; L++) {
          e = c[L], k = e.labelPos, y = e.dataLabel, P = !1 === e.visible ? "hidden" : "inherit", O = f = k[1], t && E(e.distributeBox) && (void 0 === e.distributeBox.pos ? P = "hidden" : (I = e.distributeBox.size, O = e.top + e.distributeBox.pos)), delete e.positionIndex, Q = n.justify ? x[0] + (d ? -1 : 1) * (A + e.labelDistance) : b.getX(O < e.top + 2 || O > e.bottom - 2 ? f : O, d, e), y._attr = {
            visibility: P,
            align: k[6]
          }, y._pos = {
            x: Q + n.x + ({
              left: r,
              right: -r
            }[k[6]] || 0),
            y: O + n.y - 10
          }, k.x = Q, k.y = O, l(n.crop, !0) && (N = y.getBBox().width, f = null, Q - N < r && 1 === d ? (f = Math.round(N - Q + r), R[3] = Math.max(f, R[3])) : Q + N > w - r && 0 === d && (f = Math.round(Q + N - w + r), R[1] = Math.max(f, R[1])), 0 > O - I / 2 ? R[0] = Math.max(Math.round(-O + I / 2), R[0]) : O + I / 2 > p && (R[2] = Math.max(Math.round(O + I / 2 - p), R[2])), y.sideOverflow = f);
        }
      }), 0 === C(R) || this.verifyDataLabelOverflow(R)) && (this.placeDataLabels(), u && m(this.points, function (a) {
        var c;
        v = a.connector;

        if ((y = a.dataLabel) && y._pos && a.visible && 0 < a.labelDistance) {
          P = y._attr.visibility;
          if (c = !v) a.connector = v = g.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + a.colorIndex + (a.className ? " " + a.className : "")).add(b.dataLabelsGroup);
          v[c ? "attr" : "animate"]({
            d: b.connectorPath(a.labelPos)
          });
          v.attr("visibility", P);
        } else v && (a.connector = v.destroy());
      }));
    }, x.pie.prototype.connectorPath = function (a) {
      var b = a.x,
          c = a.y;
      return l(this.options.dataLabels.softConnector, !0) ? ["M", b + ("left" === a[6] ? 5 : -5), c, "C", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], "L", a[4], a[5]] : ["M", b + ("left" === a[6] ? 5 : -5), c, "L", a[2], a[3], "L", a[4], a[5]];
    }, x.pie.prototype.placeDataLabels = function () {
      m(this.points, function (a) {
        var b = a.dataLabel;
        b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({
          width: b._attr.width + "px",
          textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
        }), b.shortened = !0), b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b && b.attr({
          y: -9999
        }));
      }, this);
    }, x.pie.prototype.alignDataLabel = t, x.pie.prototype.verifyDataLabelOverflow = function (a) {
      var b = this.center,
          c = this.options,
          e = c.center,
          g = c.minSize || 80,
          l,
          n = null !== c.size;
      n || (null !== e[0] ? l = Math.max(b[2] - Math.max(a[1], a[3]), g) : (l = Math.max(b[2] - a[1] - a[3], g), b[0] += (a[3] - a[1]) / 2), null !== e[1] ? l = Math.max(Math.min(l, b[2] - Math.max(a[0], a[2])), g) : (l = Math.max(Math.min(l, b[2] - a[0] - a[2]), g), b[1] += (a[0] - a[2]) / 2), l < b[2] ? (b[2] = l, b[3] = Math.min(d(c.innerSize || 0, l), l), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : n = !0);
      return n;
    });
    x.column && (x.column.prototype.alignDataLabel = function (a, d, e, g, n) {
      var b = this.chart.inverted,
          f = a.series,
          m = a.dlBox || a.shapeArgs,
          p = l(a.below, a.plotY > l(this.translatedThreshold, f.yAxis.len)),
          q = l(e.inside, !!this.options.stacking);
      m && (g = u(m), 0 > g.y && (g.height += g.y, g.y = 0), m = g.y + g.height - f.yAxis.len, 0 < m && (g.height -= m), b && (g = {
        x: f.yAxis.len - g.y - g.height,
        y: f.xAxis.len - g.x - g.width,
        width: g.height,
        height: g.width
      }), q || (b ? (g.x += p ? 0 : g.width, g.width = 0) : (g.y += p ? g.height : 0, g.height = 0)));
      e.align = l(e.align, !b || q ? "center" : p ? "right" : "left");
      e.verticalAlign = l(e.verticalAlign, b || q ? "middle" : p ? "top" : "bottom");
      c.prototype.alignDataLabel.call(this, a, d, e, g, n);
      a.isLabelJustified && a.contrastColor && a.dataLabel.css({
        color: a.contrastColor
      });
    });
  })(K);

  (function (a) {
    var A = a.Chart,
        C = a.each,
        E = a.objectEach,
        m = a.pick;
    a = a.addEvent;
    a(A, "render", function () {
      var a = [];
      C(this.labelCollectors || [], function (e) {
        a = a.concat(e());
      });
      C(this.yAxis || [], function (e) {
        e.options.stackLabels && !e.options.stackLabels.allowOverlap && E(e.stacks, function (e) {
          E(e, function (e) {
            a.push(e.label);
          });
        });
      });
      C(this.series || [], function (e) {
        var g = e.options.dataLabels,
            u = e.dataLabelCollections || ["dataLabel"];
        (g.enabled || e._hasPointLabels) && !g.allowOverlap && e.visible && C(u, function (g) {
          C(e.points, function (e) {
            e[g] && (e[g].labelrank = m(e.labelrank, e.shapeArgs && e.shapeArgs.height), a.push(e[g]));
          });
        });
      });
      this.hideOverlappingLabels(a);
    });

    A.prototype.hideOverlappingLabels = function (a) {
      var e = a.length,
          g = this.renderer,
          m,
          t,
          l,
          d,
          c,
          x,
          r = function r(a, b, c, d, e, g, l, m) {
        return !(e > a + c || e + l < a || g > b + d || g + m < b);
      };

      l = function l(a) {
        var b,
            c,
            d,
            e = 2 * (a.box ? 0 : a.padding || 0);
        d = 0;
        if (a && (!a.alignAttr || a.placed)) return b = a.alignAttr || {
          x: a.attr("x"),
          y: a.attr("y")
        }, c = a.parentGroup, a.width || (d = a.getBBox(), a.width = d.width, a.height = d.height, d = g.fontMetrics(null, a.element).h), {
          x: b.x + (c.translateX || 0),
          y: b.y + (c.translateY || 0) - d,
          width: a.width - e,
          height: a.height - e
        };
      };

      for (t = 0; t < e; t++) {
        if (m = a[t]) m.oldOpacity = m.opacity, m.newOpacity = 1, m.absoluteBox = l(m);
      }

      a.sort(function (a, b) {
        return (b.labelrank || 0) - (a.labelrank || 0);
      });

      for (t = 0; t < e; t++) {
        for (x = (l = a[t]) && l.absoluteBox, m = t + 1; m < e; ++m) {
          if (c = (d = a[m]) && d.absoluteBox, x && c && l !== d && 0 !== l.newOpacity && 0 !== d.newOpacity && (c = r(x.x, x.y, x.width, x.height, c.x, c.y, c.width, c.height))) (l.labelrank < d.labelrank ? l : d).newOpacity = 0;
        }
      }

      C(a, function (a) {
        var b, c;
        a && (c = a.newOpacity, a.oldOpacity !== c && (a.alignAttr && a.placed ? (c ? a.show(!0) : b = function b() {
          a.hide();
        }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)) : a.attr({
          opacity: c
        })), a.isOld = !0);
      });
    };
  })(K);

  (function (a) {
    var A = a.addEvent,
        C = a.Chart,
        E = a.createElement,
        m = a.css,
        g = a.defaultOptions,
        e = a.defaultPlotOptions,
        v = a.each,
        u = a.extend,
        t = a.fireEvent,
        l = a.hasTouch,
        d = a.inArray,
        c = a.isObject,
        x = a.Legend,
        r = a.merge,
        n = a.pick,
        b = a.Point,
        f = a.Series,
        q = a.seriesTypes,
        G = a.svg,
        J;
    J = a.TrackerMixin = {
      drawTrackerPoint: function drawTrackerPoint() {
        var a = this,
            b = a.chart.pointer,
            c = function c(a) {
          var c = b.getPointFromEvent(a);
          void 0 !== c && (b.isDirectTouch = !0, c.onMouseOver(a));
        };

        v(a.points, function (a) {
          a.graphic && (a.graphic.element.point = a);
          a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);
        });
        a._hasTracking || (v(a.trackerGroups, function (d) {
          if (a[d] && (a[d].addClass("highcharts-tracker").on("mouseover", c).on("mouseout", function (a) {
            b.onTrackerMouseOut(a);
          }), l)) a[d].on("touchstart", c);
        }), a._hasTracking = !0);
        t(this, "afterDrawTracker");
      },
      drawTrackerGraph: function drawTrackerGraph() {
        var a = this,
            b = a.options.trackByArea,
            c = [].concat(b ? a.areaPath : a.graphPath),
            d = c.length,
            e = a.chart,
            f = e.pointer,
            g = e.renderer,
            m = e.options.tooltip.snap,
            h = a.tracker,
            n,
            q = function q() {
          if (e.hoverSeries !== a) a.onMouseOver();
        },
            k = "rgba(192,192,192," + (G ? .0001 : .002) + ")";

        if (d && !b) for (n = d + 1; n--;) {
          "M" === c[n] && c.splice(n + 1, 0, c[n + 1] - m, c[n + 2], "L"), (n && "M" === c[n] || n === d) && c.splice(n, 0, "L", c[n - 2] + m, c[n - 1]);
        }
        h ? h.attr({
          d: c
        }) : a.graph && (a.tracker = g.path(c).attr({
          "stroke-linejoin": "round",
          visibility: a.visible ? "visible" : "hidden",
          stroke: k,
          fill: b ? k : "none",
          "stroke-width": a.graph.strokeWidth() + (b ? 0 : 2 * m),
          zIndex: 2
        }).add(a.group), v([a.tracker, a.markerGroup], function (a) {
          a.addClass("highcharts-tracker").on("mouseover", q).on("mouseout", function (a) {
            f.onTrackerMouseOut(a);
          });
          if (l) a.on("touchstart", q);
        }));
        t(this, "afterDrawTracker");
      }
    };
    q.column && (q.column.prototype.drawTracker = J.drawTrackerPoint);
    q.pie && (q.pie.prototype.drawTracker = J.drawTrackerPoint);
    q.scatter && (q.scatter.prototype.drawTracker = J.drawTrackerPoint);
    u(x.prototype, {
      setItemEvents: function setItemEvents(a, c, d) {
        var e = this.chart.renderer.boxWrapper,
            f = "highcharts-legend-" + (a instanceof b ? "point" : "series") + "-active";
        (d ? c : a.legendGroup).on("mouseover", function () {
          a.setState("hover");
          e.addClass(f);
        }).on("mouseout", function () {
          e.removeClass(f);
          a.setState();
        }).on("click", function (b) {
          var c = function c() {
            a.setVisible && a.setVisible();
          };

          e.removeClass(f);
          b = {
            browserEvent: b
          };
          a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : t(a, "legendItemClick", b, c);
        });
      },
      createCheckboxForItem: function createCheckboxForItem(a) {
        a.checkbox = E("input", {
          type: "checkbox",
          className: "highcharts-legend-checkbox",
          checked: a.selected,
          defaultChecked: a.selected
        }, this.options.itemCheckboxStyle, this.chart.container);
        A(a.checkbox, "click", function (b) {
          t(a.series || a, "checkboxClick", {
            checked: b.target.checked,
            item: a
          }, function () {
            a.select();
          });
        });
      }
    });
    u(C.prototype, {
      showResetZoom: function showResetZoom() {
        function a() {
          b.zoomOut();
        }

        var b = this,
            c = g.lang,
            d = b.options.chart.resetZoomButton,
            e = d.theme,
            f = e.states,
            l = "chart" === d.relativeTo ? null : "plotBox";
        t(this, "beforeShowResetZoom", null, function () {
          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, e, f && f.hover).attr({
            align: d.position.align,
            title: c.resetZoomTitle
          }).addClass("highcharts-reset-zoom").add().align(d.position, !1, l);
        });
      },
      zoomOut: function zoomOut() {
        t(this, "selection", {
          resetSelection: !0
        }, this.zoom);
      },
      zoom: function zoom(a) {
        var b,
            d = this.pointer,
            e = !1,
            f;
        !a || a.resetSelection ? (v(this.axes, function (a) {
          b = a.zoom();
        }), d.initiated = !1) : v(a.xAxis.concat(a.yAxis), function (a) {
          var c = a.axis;
          d[c.isXAxis ? "zoomX" : "zoomY"] && (b = c.zoom(a.min, a.max), c.displayBtn && (e = !0));
        });
        f = this.resetZoomButton;
        e && !f ? this.showResetZoom() : !e && c(f) && (this.resetZoomButton = f.destroy());
        b && this.redraw(n(this.options.chart.animation, a && a.animation, 100 > this.pointCount));
      },
      pan: function pan(a, b) {
        var c = this,
            d = c.hoverPoints,
            e;
        d && v(d, function (a) {
          a.setState();
        });
        v("xy" === b ? [1, 0] : [1], function (b) {
          b = c[b ? "xAxis" : "yAxis"][0];
          var d = b.horiz,
              f = a[d ? "chartX" : "chartY"],
              d = d ? "mouseDownX" : "mouseDownY",
              g = c[d],
              l = (b.pointRange || 0) / 2,
              m = b.reversed && !c.inverted || !b.reversed && c.inverted ? -1 : 1,
              k = b.getExtremes(),
              n = b.toValue(g - f, !0) + l * m,
              m = b.toValue(g + b.len - f, !0) - l * m,
              p = m < n,
              g = p ? m : n,
              n = p ? n : m,
              m = Math.min(k.dataMin, l ? k.min : b.toValue(b.toPixels(k.min) - b.minPixelPadding)),
              l = Math.max(k.dataMax, l ? k.max : b.toValue(b.toPixels(k.max) + b.minPixelPadding)),
              p = m - g;
          0 < p && (n += p, g = m);
          p = n - l;
          0 < p && (n = l, g -= p);
          b.series.length && g !== k.min && n !== k.max && (b.setExtremes(g, n, !1, !1, {
            trigger: "pan"
          }), e = !0);
          c[d] = f;
        });
        e && c.redraw(!1);
        m(c.container, {
          cursor: "move"
        });
      }
    });
    u(b.prototype, {
      select: function select(a, b) {
        var c = this,
            e = c.series,
            f = e.chart;
        a = n(a, !c.selected);
        c.firePointEvent(a ? "select" : "unselect", {
          accumulate: b
        }, function () {
          c.selected = c.options.selected = a;
          e.options.data[d(c, e.data)] = c.options;
          c.setState(a && "select");
          b || v(f.getSelectedPoints(), function (a) {
            a.selected && a !== c && (a.selected = a.options.selected = !1, e.options.data[d(a, e.data)] = a.options, a.setState(""), a.firePointEvent("unselect"));
          });
        });
      },
      onMouseOver: function onMouseOver(a) {
        var b = this.series.chart,
            c = b.pointer;
        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);
        c.runPointActions(a, this);
      },
      onMouseOut: function onMouseOut() {
        var a = this.series.chart;
        this.firePointEvent("mouseOut");
        v(a.hoverPoints || [], function (a) {
          a.setState();
        });
        a.hoverPoints = a.hoverPoint = null;
      },
      importEvents: function importEvents() {
        if (!this.hasImportedEvents) {
          var b = this,
              c = r(b.series.options.point, b.options).events;
          b.events = c;
          a.objectEach(c, function (a, c) {
            A(b, c, a);
          });
          this.hasImportedEvents = !0;
        }
      },
      setState: function setState(a, b) {
        var c = Math.floor(this.plotX),
            d = this.plotY,
            f = this.series,
            g = f.options.states[a || "normal"] || {},
            l = e[f.type].marker && f.options.marker,
            m = l && !1 === l.enabled,
            h = l && l.states && l.states[a || "normal"] || {},
            q = !1 === h.enabled,
            r = f.stateMarkerGraphic,
            k = this.marker || {},
            u = f.chart,
            v = f.halo,
            x,
            B = l && f.markerAttribs;
        a = a || "";

        if (!(a === this.state && !b || this.selected && "select" !== a || !1 === g.enabled || a && (q || m && !1 === h.enabled) || a && k.states && k.states[a] && !1 === k.states[a].enabled)) {
          B && (x = f.markerAttribs(this, a));
          if (this.graphic) this.state && this.graphic.removeClass("highcharts-point-" + this.state), a && this.graphic.addClass("highcharts-point-" + a), x && this.graphic.animate(x, n(u.options.chart.animation, h.animation, l.animation)), r && r.hide();else {
            if (a && h) if (l = k.symbol || f.symbol, r && r.currentSymbol !== l && (r = r.destroy()), r) r[b ? "animate" : "attr"]({
              x: x.x,
              y: x.y
            });else l && (f.stateMarkerGraphic = r = u.renderer.symbol(l, x.x, x.y, x.width, x.height).add(f.markerGroup), r.currentSymbol = l);
            r && (r[a && u.isInsidePlot(c, d, u.inverted) ? "show" : "hide"](), r.element.point = this);
          }
          (c = g.halo) && c.size ? (v || (f.halo = v = u.renderer.path().add((this.graphic || r).parentGroup)), v.show()[b ? "animate" : "attr"]({
            d: this.haloPath(c.size)
          }), v.attr({
            "class": "highcharts-halo highcharts-color-" + n(this.colorIndex, f.colorIndex) + (this.className ? " " + this.className : ""),
            zIndex: -1
          }), v.point = this) : v && v.point && v.point.haloPath && v.animate({
            d: v.point.haloPath(0)
          }, null, v.hide);
          this.state = a;
          t(this, "afterSetState");
        }
      },
      haloPath: function haloPath(a) {
        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
      }
    });
    u(f.prototype, {
      onMouseOver: function onMouseOver() {
        var a = this.chart,
            b = a.hoverSeries;
        if (b && b !== this) b.onMouseOut();
        this.options.events.mouseOver && t(this, "mouseOver");
        this.setState("hover");
        a.hoverSeries = this;
      },
      onMouseOut: function onMouseOut() {
        var a = this.options,
            b = this.chart,
            c = b.tooltip,
            d = b.hoverPoint;
        b.hoverSeries = null;
        if (d) d.onMouseOut();
        this && a.events.mouseOut && t(this, "mouseOut");
        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();
        this.setState();
      },
      setState: function setState(a) {
        var b = this;
        a = a || "";
        b.state !== a && (v([b.group, b.markerGroup, b.dataLabelsGroup], function (c) {
          c && (b.state && c.removeClass("highcharts-series-" + b.state), a && c.addClass("highcharts-series-" + a));
        }), b.state = a);
      },
      setVisible: function setVisible(a, b) {
        var c = this,
            d = c.chart,
            e = c.legendItem,
            f,
            g = d.options.chart.ignoreHiddenSeries,
            l = c.visible;
        f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !l : a) ? "show" : "hide";
        v(["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"], function (a) {
          if (c[a]) c[a][f]();
        });
        if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();
        e && d.legend.colorizeItem(c, a);
        c.isDirty = !0;
        c.options.stacking && v(d.series, function (a) {
          a.options.stacking && a.visible && (a.isDirty = !0);
        });
        v(c.linkedSeries, function (b) {
          b.setVisible(a, !1);
        });
        g && (d.isDirtyBox = !0);
        t(c, f);
        !1 !== b && d.redraw();
      },
      show: function show() {
        this.setVisible(!0);
      },
      hide: function hide() {
        this.setVisible(!1);
      },
      select: function select(a) {
        this.selected = a = void 0 === a ? !this.selected : a;
        this.checkbox && (this.checkbox.checked = a);
        t(this, a ? "select" : "unselect");
      },
      drawTracker: J.drawTrackerGraph
    });
  })(K);

  (function (a) {
    var A = a.Chart,
        C = a.each,
        E = a.inArray,
        m = a.isArray,
        g = a.isObject,
        e = a.pick,
        v = a.splat;

    A.prototype.setResponsive = function (e) {
      var g = this.options.responsive,
          l = [],
          d = this.currentResponsive;
      g && g.rules && C(g.rules, function (c) {
        void 0 === c._id && (c._id = a.uniqueKey());
        this.matchResponsiveRule(c, l, e);
      }, this);
      var c = a.merge.apply(0, a.map(l, function (c) {
        return a.find(g.rules, function (a) {
          return a._id === c;
        }).chartOptions;
      })),
          l = l.toString() || void 0;
      l !== (d && d.ruleIds) && (d && this.update(d.undoOptions, e), l ? (this.currentResponsive = {
        ruleIds: l,
        mergedOptions: c,
        undoOptions: this.currentOptions(c)
      }, this.update(c, e)) : this.currentResponsive = void 0);
    };

    A.prototype.matchResponsiveRule = function (a, g) {
      var l = a.condition;
      (l.callback || function () {
        return this.chartWidth <= e(l.maxWidth, Number.MAX_VALUE) && this.chartHeight <= e(l.maxHeight, Number.MAX_VALUE) && this.chartWidth >= e(l.minWidth, 0) && this.chartHeight >= e(l.minHeight, 0);
      }).call(this) && g.push(a._id);
    };

    A.prototype.currentOptions = function (e) {
      function t(d, c, e, l) {
        var n;
        a.objectEach(d, function (a, d) {
          if (!l && -1 < E(d, ["series", "xAxis", "yAxis"])) for (a = v(a), e[d] = [], n = 0; n < a.length; n++) {
            c[d][n] && (e[d][n] = {}, t(a[n], c[d][n], e[d][n], l + 1));
          } else g(a) ? (e[d] = m(a) ? [] : {}, t(a, c[d] || {}, e[d], l + 1)) : e[d] = c[d] || null;
        });
      }

      var l = {};
      t(e, this.options, l, 0);
      return l;
    };
  })(K);

  return K;
});

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Highcharts;

},{}],54:[function(require,module,exports){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ref = require('/gen/prismjs.js');

var global = {
  Prism: Prism
};
var _module = undefined;
var hitextPrismjs;

var _define = function define() {
  var fn = arguments[arguments.length - 1];
  hitextPrismjs = fn();
  _define = undefined;
};

_define.amd = true;
!function (e) {
  if ("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof _module) _module.exports = e();else if ("function" == typeof _define && _define.amd) _define([], e);else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).hitextPrismjs = e();
  }
}(function () {
  return function () {
    return function e(n, t, o) {
      function i(f, u) {
        if (!t[f]) {
          if (!n[f]) {
            var s = "function" == typeof require && require;
            if (!u && s) return s(f, !0);
            if (r) return r(f, !0);
            var p = new Error("Cannot find module '" + f + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }

          var d = t[f] = {
            exports: {}
          };
          n[f][0].call(d.exports, function (e) {
            return i(n[f][1][e] || e);
          }, d, d.exports, e, n, t, o);
        }

        return t[f].exports;
      }

      for (var r = "function" == typeof require && require, f = 0; f < o.length; f++) {
        i(o[f]);
      }

      return i;
    };
  }()({
    1: [function (e, n, t) {
      (function (t) {
        var _ref = t.Prism || e("prismjs"),
            o = _ref.tokenize,
            i = _ref.languages;

        n.exports = function (e) {
          return function (n, t) {
            function r(e, n) {
              e.forEach(function (e) {
                "string" != typeof e && function (e, n) {
                  t("prism", n, n + e.length, e.type), Array.isArray(e.content) && r(e.content, n);
                }(e, n), n += e.length;
              });
            }

            r(o(n, i[e]), 0);
          };
        }, n.exports.printer = {
          html: {
            hooks: {
              prism: {
                open: function open(e) {
                  return '<span class="token ' + e + '">';
                },
                close: function close() {
                  return "</span>";
                }
              }
            }
          }
        };
      }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
      prismjs: void 0
    }]
  }, {}, [1])(1);
});
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hitextPrismjs;

},{"/gen/prismjs.js":57}],55:[function(require,module,exports){
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = {};
var _module = undefined;
var hitext;

var _define = function define() {
  var fn = arguments[arguments.length - 1];
  hitext = fn();
  _define = undefined;
};

_define.amd = true;
!function (e) {
  if ("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof _module) _module.exports = e();else if ("function" == typeof _define && _define.amd) _define([], e);else {
    ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).hitext = e();
  }
}(function () {
  return function () {
    return function e(n, r, t) {
      function a(i, l) {
        if (!r[i]) {
          if (!n[i]) {
            var s = "function" == typeof require && require;
            if (!l && s) return s(i, !0);
            if (o) return o(i, !0);
            var c = new Error("Cannot find module '" + i + "'");
            throw c.code = "MODULE_NOT_FOUND", c;
          }

          var u = r[i] = {
            exports: {}
          };
          n[i][0].call(u.exports, function (e) {
            return a(n[i][1][e] || e);
          }, u, u.exports, e, n, r, t);
        }

        return r[i].exports;
      }

      for (var o = "function" == typeof require && require, i = 0; i < t.length; i++) {
        a(t[i]);
      }

      return a;
    };
  }()({
    1: [function (e, n, r) {
      "use strict";

      var t = e("color-convert"),
          a = function a(e, n) {
        return function () {
          return "\x1B[".concat(e.apply(t, arguments) + n, "m");
        };
      },
          o = function o(e, n) {
        return function () {
          var r = e.apply(t, arguments);
          return "\x1B[".concat(38 + n, ";5;").concat(r, "m");
        };
      },
          i = function i(e, n) {
        return function () {
          var r = e.apply(t, arguments);
          return "\x1B[".concat(38 + n, ";2;").concat(r[0], ";").concat(r[1], ";").concat(r[2], "m");
        };
      };

      Object.defineProperty(n, "exports", {
        enumerable: !0,
        get: function get() {
          var e = new Map(),
              n = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29]
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              gray: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39]
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49]
            }
          };
          n.color.grey = n.color.gray;

          var _arr = Object.keys(n);

          for (var _i = 0; _i < _arr.length; _i++) {
            var _r = _arr[_i];
            var _t = n[_r];

            var _arr3 = Object.keys(_t);

            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
              var _r2 = _arr3[_i3];
              var _a = _t[_r2];
              n[_r2] = {
                open: "\x1B[".concat(_a[0], "m"),
                close: "\x1B[".concat(_a[1], "m")
              }, _t[_r2] = n[_r2], e.set(_a[0], _a[1]);
            }

            Object.defineProperty(n, _r, {
              value: _t,
              enumerable: !1
            }), Object.defineProperty(n, "codes", {
              value: e,
              enumerable: !1
            });
          }

          var r = function r(e) {
            return e;
          },
              l = function l(e, n, r) {
            return [e, n, r];
          };

          n.color.close = "[39m", n.bgColor.close = "[49m", n.color.ansi = {
            ansi: a(r, 0)
          }, n.color.ansi256 = {
            ansi256: o(r, 0)
          }, n.color.ansi16m = {
            rgb: i(l, 0)
          }, n.bgColor.ansi = {
            ansi: a(r, 10)
          }, n.bgColor.ansi256 = {
            ansi256: o(r, 10)
          }, n.bgColor.ansi16m = {
            rgb: i(l, 10)
          };

          var _arr2 = Object.keys(t);

          for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
            var _e = _arr2[_i2];
            if ("object" != _typeof(t[_e])) continue;
            var _r3 = t[_e];
            "ansi16" === _e && (_e = "ansi"), "ansi16" in _r3 && (n.color.ansi[_e] = a(_r3.ansi16, 0), n.bgColor.ansi[_e] = a(_r3.ansi16, 10)), "ansi256" in _r3 && (n.color.ansi256[_e] = o(_r3.ansi256, 0), n.bgColor.ansi256[_e] = o(_r3.ansi256, 10)), "rgb" in _r3 && (n.color.ansi16m[_e] = i(_r3.rgb, 0), n.bgColor.ansi16m[_e] = i(_r3.rgb, 10));
          }

          return n;
        }
      });
    }, {
      "color-convert": 3
    }],
    2: [function (e, n, r) {
      var t = e("color-name"),
          a = {};

      for (var o in t) {
        t.hasOwnProperty(o) && (a[t[o]] = o);
      }

      var i = n.exports = {
        rgb: {
          channels: 3,
          labels: "rgb"
        },
        hsl: {
          channels: 3,
          labels: "hsl"
        },
        hsv: {
          channels: 3,
          labels: "hsv"
        },
        hwb: {
          channels: 3,
          labels: "hwb"
        },
        cmyk: {
          channels: 4,
          labels: "cmyk"
        },
        xyz: {
          channels: 3,
          labels: "xyz"
        },
        lab: {
          channels: 3,
          labels: "lab"
        },
        lch: {
          channels: 3,
          labels: "lch"
        },
        hex: {
          channels: 1,
          labels: ["hex"]
        },
        keyword: {
          channels: 1,
          labels: ["keyword"]
        },
        ansi16: {
          channels: 1,
          labels: ["ansi16"]
        },
        ansi256: {
          channels: 1,
          labels: ["ansi256"]
        },
        hcg: {
          channels: 3,
          labels: ["h", "c", "g"]
        },
        apple: {
          channels: 3,
          labels: ["r16", "g16", "b16"]
        },
        gray: {
          channels: 1,
          labels: ["gray"]
        }
      };

      for (var l in i) {
        if (i.hasOwnProperty(l)) {
          if (!("channels" in i[l])) throw new Error("missing channels property: " + l);
          if (!("labels" in i[l])) throw new Error("missing channel labels property: " + l);
          if (i[l].labels.length !== i[l].channels) throw new Error("channel and label counts mismatch: " + l);
          var s = i[l].channels,
              c = i[l].labels;
          delete i[l].channels, delete i[l].labels, Object.defineProperty(i[l], "channels", {
            value: s
          }), Object.defineProperty(i[l], "labels", {
            value: c
          });
        }
      }

      i.rgb.hsl = function (e) {
        var n,
            r,
            t = e[0] / 255,
            a = e[1] / 255,
            o = e[2] / 255,
            i = Math.min(t, a, o),
            l = Math.max(t, a, o),
            s = l - i;
        return l === i ? n = 0 : t === l ? n = (a - o) / s : a === l ? n = 2 + (o - t) / s : o === l && (n = 4 + (t - a) / s), (n = Math.min(60 * n, 360)) < 0 && (n += 360), r = (i + l) / 2, [n, 100 * (l === i ? 0 : r <= .5 ? s / (l + i) : s / (2 - l - i)), 100 * r];
      }, i.rgb.hsv = function (e) {
        var n,
            r,
            t,
            a,
            o,
            i = e[0] / 255,
            l = e[1] / 255,
            s = e[2] / 255,
            c = Math.max(i, l, s),
            u = c - Math.min(i, l, s),
            h = function h(e) {
          return (c - e) / 6 / u + .5;
        };

        return 0 === u ? a = o = 0 : (o = u / c, n = h(i), r = h(l), t = h(s), i === c ? a = t - r : l === c ? a = 1 / 3 + n - t : s === c && (a = 2 / 3 + r - n), a < 0 ? a += 1 : a > 1 && (a -= 1)), [360 * a, 100 * o, 100 * c];
      }, i.rgb.hwb = function (e) {
        var n = e[0],
            r = e[1],
            t = e[2];
        return [i.rgb.hsl(e)[0], 100 * (1 / 255 * Math.min(n, Math.min(r, t))), 100 * (t = 1 - 1 / 255 * Math.max(n, Math.max(r, t)))];
      }, i.rgb.cmyk = function (e) {
        var n,
            r = e[0] / 255,
            t = e[1] / 255,
            a = e[2] / 255;
        return [100 * ((1 - r - (n = Math.min(1 - r, 1 - t, 1 - a))) / (1 - n) || 0), 100 * ((1 - t - n) / (1 - n) || 0), 100 * ((1 - a - n) / (1 - n) || 0), 100 * n];
      }, i.rgb.keyword = function (e) {
        var n = a[e];
        if (n) return n;
        var r,
            o,
            i,
            l = 1 / 0;

        for (var s in t) {
          if (t.hasOwnProperty(s)) {
            var c = t[s],
                u = (o = e, i = c, Math.pow(o[0] - i[0], 2) + Math.pow(o[1] - i[1], 2) + Math.pow(o[2] - i[2], 2));
            u < l && (l = u, r = s);
          }
        }

        return r;
      }, i.keyword.rgb = function (e) {
        return t[e];
      }, i.rgb.xyz = function (e) {
        var n = e[0] / 255,
            r = e[1] / 255,
            t = e[2] / 255;
        return [100 * (.4124 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .3576 * (r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92) + .1805 * (t = t > .04045 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92)), 100 * (.2126 * n + .7152 * r + .0722 * t), 100 * (.0193 * n + .1192 * r + .9505 * t)];
      }, i.rgb.lab = function (e) {
        var n = i.rgb.xyz(e),
            r = n[0],
            t = n[1],
            a = n[2];
        return t /= 100, a /= 108.883, r = (r /= 95.047) > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, [116 * (t = t > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116) - 16, 500 * (r - t), 200 * (t - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))];
      }, i.hsl.rgb = function (e) {
        var n,
            r,
            t,
            a,
            o,
            i = e[0] / 360,
            l = e[1] / 100,
            s = e[2] / 100;
        if (0 === l) return [o = 255 * s, o, o];
        n = 2 * s - (r = s < .5 ? s * (1 + l) : s + l - s * l), a = [0, 0, 0];

        for (var c = 0; c < 3; c++) {
          (t = i + 1 / 3 * -(c - 1)) < 0 && t++, t > 1 && t--, o = 6 * t < 1 ? n + 6 * (r - n) * t : 2 * t < 1 ? r : 3 * t < 2 ? n + (r - n) * (2 / 3 - t) * 6 : n, a[c] = 255 * o;
        }

        return a;
      }, i.hsl.hsv = function (e) {
        var n = e[0],
            r = e[1] / 100,
            t = e[2] / 100,
            a = r,
            o = Math.max(t, .01);
        return r *= (t *= 2) <= 1 ? t : 2 - t, a *= o <= 1 ? o : 2 - o, [n, 100 * (0 === t ? 2 * a / (o + a) : 2 * r / (t + r)), 100 * ((t + r) / 2)];
      }, i.hsv.rgb = function (e) {
        var n = e[0] / 60,
            r = e[1] / 100,
            t = e[2] / 100,
            a = Math.floor(n) % 6,
            o = n - Math.floor(n),
            i = 255 * t * (1 - r),
            l = 255 * t * (1 - r * o),
            s = 255 * t * (1 - r * (1 - o));

        switch (t *= 255, a) {
          case 0:
            return [t, s, i];

          case 1:
            return [l, t, i];

          case 2:
            return [i, t, s];

          case 3:
            return [i, l, t];

          case 4:
            return [s, i, t];

          case 5:
            return [t, i, l];
        }
      }, i.hsv.hsl = function (e) {
        var n,
            r,
            t,
            a = e[0],
            o = e[1] / 100,
            i = e[2] / 100,
            l = Math.max(i, .01);
        return t = (2 - o) * i, r = o * l, [a, 100 * (r = (r /= (n = (2 - o) * l) <= 1 ? n : 2 - n) || 0), 100 * (t /= 2)];
      }, i.hwb.rgb = function (e) {
        var n,
            r,
            t,
            a,
            o,
            i,
            l,
            s = e[0] / 360,
            c = e[1] / 100,
            u = e[2] / 100,
            h = c + u;

        switch (h > 1 && (c /= h, u /= h), r = 1 - u, t = 6 * s - (n = Math.floor(6 * s)), 0 != (1 & n) && (t = 1 - t), a = c + t * (r - c), n) {
          default:
          case 6:
          case 0:
            o = r, i = a, l = c;
            break;

          case 1:
            o = a, i = r, l = c;
            break;

          case 2:
            o = c, i = r, l = a;
            break;

          case 3:
            o = c, i = a, l = r;
            break;

          case 4:
            o = a, i = c, l = r;
            break;

          case 5:
            o = r, i = c, l = a;
        }

        return [255 * o, 255 * i, 255 * l];
      }, i.cmyk.rgb = function (e) {
        var n = e[0] / 100,
            r = e[1] / 100,
            t = e[2] / 100,
            a = e[3] / 100;
        return [255 * (1 - Math.min(1, n * (1 - a) + a)), 255 * (1 - Math.min(1, r * (1 - a) + a)), 255 * (1 - Math.min(1, t * (1 - a) + a))];
      }, i.xyz.rgb = function (e) {
        var n,
            r,
            t,
            a = e[0] / 100,
            o = e[1] / 100,
            i = e[2] / 100;
        return r = -.9689 * a + 1.8758 * o + .0415 * i, t = .0557 * a + -.204 * o + 1.057 * i, n = (n = 3.2406 * a + -1.5372 * o + -.4986 * i) > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, t = t > .0031308 ? 1.055 * Math.pow(t, 1 / 2.4) - .055 : 12.92 * t, [255 * (n = Math.min(Math.max(0, n), 1)), 255 * (r = Math.min(Math.max(0, r), 1)), 255 * (t = Math.min(Math.max(0, t), 1))];
      }, i.xyz.lab = function (e) {
        var n = e[0],
            r = e[1],
            t = e[2];
        return r /= 100, t /= 108.883, n = (n /= 95.047) > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [116 * (r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) - 16, 500 * (n - r), 200 * (r - (t = t > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116))];
      }, i.lab.xyz = function (e) {
        var n,
            r,
            t,
            a = e[0],
            o = e[1],
            i = e[2];
        n = o / 500 + (r = (a + 16) / 116), t = r - i / 200;
        var l = Math.pow(r, 3),
            s = Math.pow(n, 3),
            c = Math.pow(t, 3);
        return r = l > .008856 ? l : (r - 16 / 116) / 7.787, n = s > .008856 ? s : (n - 16 / 116) / 7.787, t = c > .008856 ? c : (t - 16 / 116) / 7.787, [n *= 95.047, r *= 100, t *= 108.883];
      }, i.lab.lch = function (e) {
        var n,
            r = e[0],
            t = e[1],
            a = e[2];
        return (n = 360 * Math.atan2(a, t) / 2 / Math.PI) < 0 && (n += 360), [r, Math.sqrt(t * t + a * a), n];
      }, i.lch.lab = function (e) {
        var n,
            r = e[0],
            t = e[1];
        return n = e[2] / 360 * 2 * Math.PI, [r, t * Math.cos(n), t * Math.sin(n)];
      }, i.rgb.ansi16 = function (e) {
        var n = e[0],
            r = e[1],
            t = e[2],
            a = 1 in arguments ? arguments[1] : i.rgb.hsv(e)[2];
        if (0 === (a = Math.round(a / 50))) return 30;
        var o = 30 + (Math.round(t / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
        return 2 === a && (o += 60), o;
      }, i.hsv.ansi16 = function (e) {
        return i.rgb.ansi16(i.hsv.rgb(e), e[2]);
      }, i.rgb.ansi256 = function (e) {
        var n = e[0],
            r = e[1],
            t = e[2];
        return n === r && r === t ? n < 8 ? 16 : n > 248 ? 231 : Math.round((n - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(n / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(t / 255 * 5);
      }, i.ansi16.rgb = function (e) {
        var n = e % 10;
        if (0 === n || 7 === n) return e > 50 && (n += 3.5), [n = n / 10.5 * 255, n, n];
        var r = .5 * (1 + ~~(e > 50));
        return [(1 & n) * r * 255, (n >> 1 & 1) * r * 255, (n >> 2 & 1) * r * 255];
      }, i.ansi256.rgb = function (e) {
        if (e >= 232) {
          var n = 10 * (e - 232) + 8;
          return [n, n, n];
        }

        var r;
        return e -= 16, [Math.floor(e / 36) / 5 * 255, Math.floor((r = e % 36) / 6) / 5 * 255, r % 6 / 5 * 255];
      }, i.rgb.hex = function (e) {
        var n = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase();
        return "000000".substring(n.length) + n;
      }, i.hex.rgb = function (e) {
        var n = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!n) return [0, 0, 0];
        var r = n[0];
        3 === n[0].length && (r = r.split("").map(function (e) {
          return e + e;
        }).join(""));
        var t = parseInt(r, 16);
        return [t >> 16 & 255, t >> 8 & 255, 255 & t];
      }, i.rgb.hcg = function (e) {
        var n,
            r,
            t = e[0] / 255,
            a = e[1] / 255,
            o = e[2] / 255,
            i = Math.max(Math.max(t, a), o),
            l = Math.min(Math.min(t, a), o),
            s = i - l;
        return n = s < 1 ? l / (1 - s) : 0, r = s <= 0 ? 0 : i === t ? (a - o) / s % 6 : i === a ? 2 + (o - t) / s : 4 + (t - a) / s + 4, r /= 6, [360 * (r %= 1), 100 * s, 100 * n];
      }, i.hsl.hcg = function (e) {
        var n = e[1] / 100,
            r = e[2] / 100,
            t = 1,
            a = 0;
        return (t = r < .5 ? 2 * n * r : 2 * n * (1 - r)) < 1 && (a = (r - .5 * t) / (1 - t)), [e[0], 100 * t, 100 * a];
      }, i.hsv.hcg = function (e) {
        var n = e[1] / 100,
            r = e[2] / 100,
            t = n * r,
            a = 0;
        return t < 1 && (a = (r - t) / (1 - t)), [e[0], 100 * t, 100 * a];
      }, i.hcg.rgb = function (e) {
        var n = e[0] / 360,
            r = e[1] / 100,
            t = e[2] / 100;
        if (0 === r) return [255 * t, 255 * t, 255 * t];
        var a,
            o = [0, 0, 0],
            i = n % 1 * 6,
            l = i % 1,
            s = 1 - l;

        switch (Math.floor(i)) {
          case 0:
            o[0] = 1, o[1] = l, o[2] = 0;
            break;

          case 1:
            o[0] = s, o[1] = 1, o[2] = 0;
            break;

          case 2:
            o[0] = 0, o[1] = 1, o[2] = l;
            break;

          case 3:
            o[0] = 0, o[1] = s, o[2] = 1;
            break;

          case 4:
            o[0] = l, o[1] = 0, o[2] = 1;
            break;

          default:
            o[0] = 1, o[1] = 0, o[2] = s;
        }

        return a = (1 - r) * t, [255 * (r * o[0] + a), 255 * (r * o[1] + a), 255 * (r * o[2] + a)];
      }, i.hcg.hsv = function (e) {
        var n = e[1] / 100,
            r = n + e[2] / 100 * (1 - n),
            t = 0;
        return r > 0 && (t = n / r), [e[0], 100 * t, 100 * r];
      }, i.hcg.hsl = function (e) {
        var n = e[1] / 100,
            r = e[2] / 100 * (1 - n) + .5 * n,
            t = 0;
        return r > 0 && r < .5 ? t = n / (2 * r) : r >= .5 && r < 1 && (t = n / (2 * (1 - r))), [e[0], 100 * t, 100 * r];
      }, i.hcg.hwb = function (e) {
        var n = e[1] / 100,
            r = n + e[2] / 100 * (1 - n);
        return [e[0], 100 * (r - n), 100 * (1 - r)];
      }, i.hwb.hcg = function (e) {
        var n = e[1] / 100,
            r = 1 - e[2] / 100,
            t = r - n,
            a = 0;
        return t < 1 && (a = (r - t) / (1 - t)), [e[0], 100 * t, 100 * a];
      }, i.apple.rgb = function (e) {
        return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
      }, i.rgb.apple = function (e) {
        return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
      }, i.gray.rgb = function (e) {
        return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
      }, i.gray.hsl = i.gray.hsv = function (e) {
        return [0, 0, e[0]];
      }, i.gray.hwb = function (e) {
        return [0, 100, e[0]];
      }, i.gray.cmyk = function (e) {
        return [0, 0, 0, e[0]];
      }, i.gray.lab = function (e) {
        return [e[0], 0, 0];
      }, i.gray.hex = function (e) {
        var n = 255 & Math.round(e[0] / 100 * 255),
            r = ((n << 16) + (n << 8) + n).toString(16).toUpperCase();
        return "000000".substring(r.length) + r;
      }, i.rgb.gray = function (e) {
        return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
      };
    }, {
      "color-name": 5
    }],
    3: [function (e, n, r) {
      var t = e("./conversions"),
          a = e("./route"),
          o = {};
      Object.keys(t).forEach(function (e) {
        o[e] = {}, Object.defineProperty(o[e], "channels", {
          value: t[e].channels
        }), Object.defineProperty(o[e], "labels", {
          value: t[e].labels
        });
        var n = a(e);
        Object.keys(n).forEach(function (r) {
          var t = n[r];
          o[e][r] = function (e) {
            var n = function n(_n) {
              if (void 0 === _n || null === _n) return _n;
              arguments.length > 1 && (_n = Array.prototype.slice.call(arguments));
              var r = e(_n);
              if ("object" == _typeof(r)) for (var t = r.length, a = 0; a < t; a++) {
                r[a] = Math.round(r[a]);
              }
              return r;
            };

            return "conversion" in e && (n.conversion = e.conversion), n;
          }(t), o[e][r].raw = function (e) {
            var n = function n(_n2) {
              return void 0 === _n2 || null === _n2 ? _n2 : (arguments.length > 1 && (_n2 = Array.prototype.slice.call(arguments)), e(_n2));
            };

            return "conversion" in e && (n.conversion = e.conversion), n;
          }(t);
        });
      }), n.exports = o;
    }, {
      "./conversions": 2,
      "./route": 4
    }],
    4: [function (e, n, r) {
      var t = e("./conversions");

      function a(e) {
        var n = function () {
          for (var e = {}, n = Object.keys(t), r = n.length, a = 0; a < r; a++) {
            e[n[a]] = {
              distance: -1,
              parent: null
            };
          }

          return e;
        }(),
            r = [e];

        for (n[e].distance = 0; r.length;) {
          for (var a = r.pop(), o = Object.keys(t[a]), i = o.length, l = 0; l < i; l++) {
            var s = o[l],
                c = n[s];
            -1 === c.distance && (c.distance = n[a].distance + 1, c.parent = a, r.unshift(s));
          }
        }

        return n;
      }

      function o(e, n) {
        return function (r) {
          return n(e(r));
        };
      }

      function i(e, n) {
        for (var r = [n[e].parent, e], a = t[n[e].parent][e], i = n[e].parent; n[i].parent;) {
          r.unshift(n[i].parent), a = o(t[n[i].parent][i], a), i = n[i].parent;
        }

        return a.conversion = r, a;
      }

      n.exports = function (e) {
        for (var n = a(e), r = {}, t = Object.keys(n), o = t.length, l = 0; l < o; l++) {
          var s = t[l];
          null !== n[s].parent && (r[s] = i(s, n));
        }

        return r;
      };
    }, {
      "./conversions": 2
    }],
    5: [function (e, n, r) {
      n.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };
    }, {}],
    6: [function (e, n, r) {
      n.exports = {
        match: e("./match"),
        spotlight: e("./spotlight")
      };
    }, {
      "./match": 7,
      "./spotlight": 8
    }],
    7: [function (e, n, r) {
      function t(e, n, r, t) {
        e(n || "match", r, t);
      }

      n.exports = function (e, n) {
        if (e instanceof RegExp) {
          var _r4 = -1 !== e.flags.indexOf("g") ? e.flags : e.flags + "g",
              a = new RegExp(e, _r4);

          return function (e, r) {
            var o;

            for (; o = a.exec(e);) {
              t(r, n, o.index, o.index + o[0].length);
            }
          };
        }

        return e = String(e), function (r, a) {
          var o = -1;

          for (; -1 !== (o = r.indexOf(e, o + 1));) {
            t(a, n, o, o + e.length);
          }
        };
      };
    }, {}],
    8: [function (e, n, r) {
      n.exports = function () {
        for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {
          e[_key] = arguments[_key];
        }

        return function (n, r) {
          return e.forEach(function (e) {
            return r.apply(void 0, ["spotlight"].concat(_toConsumableArray(e)));
          });
        };
      };
    }, {}],
    9: [function (e, n, r) {
      var t = e("./utils"),
          a = t.ensureArray,
          o = t.ensureFunction,
          i = e("./generator"),
          l = e("./printer");

      function s(e) {
        return l[e] || (e && "object" == _typeof(e) ? e : l.noop);
      }

      function c(e, n) {
        var r = [];
        return a(n).forEach(function (n) {
          o(n)(e, function (e, n, t, a) {
            return r.push({
              type: e,
              start: n,
              end: t,
              data: a
            });
          });
        }), r;
      }

      function u(e, n, r) {
        r = s(r);
        var t = o(r.print, function (e) {
          return e;
        }),
            a = o(r.createContext, function () {})(),
            i = [];
        var l = r.hooks || {},
            c = [],
            u = o(r.start, function () {
          return "";
        })(a),
            h = 1 / 0,
            g = 0;
        l = Object.keys(l).reduce(function (e, n) {
          return c.push(n), e[n] = {
            open: o(l[n].open, function () {
              return "";
            }),
            close: o(l[n].close, function () {
              return "";
            })
          }, e;
        }, {}), n = n.slice().sort(function (e, n) {
          return e.start - n.start || n.end - e.end || c.indexOf(e.type) - c.indexOf(n.type);
        });

        var f = function f(n) {
          g !== n && (u += t(e.substring(g, n), a), g = n);
        },
            b = function b(e) {
          return l[i[e].type].open(i[e].data, a) || "";
        },
            p = function p(e) {
          return l[i[e].type].close(i[e].data, a) || "";
        },
            d = function d(e) {
          for (; h <= e;) {
            f(h);

            for (var _e2 = i.length - 1; _e2 >= 0 && i[_e2].end === h; _e2--) {
              u += p(_e2), i.pop();
            }

            h = 1 / 0;

            for (var _e3 = 0; _e3 < i.length; _e3++) {
              i[_e3].end < h && (h = i[_e3].end);
            }
          }
        };

        for (var _e4 = 0; _e4 < n.length; _e4++) {
          var _r5 = n[_e4];
          var _t2 = 0;

          if (!1 !== l.hasOwnProperty(_r5.type) && !(_r5.start > _r5.end) && Number.isFinite(_r5.start) && Number.isFinite(_r5.end)) {
            for (d(_r5.start), f(_r5.start), _t2 = 0; _t2 < i.length; _t2++) {
              if (i[_t2].end < _r5.end) {
                for (var _e5 = i.length - 1; _e5 >= _t2; _e5--) {
                  u += p(_e5);
                }

                break;
              }
            }

            for (i.splice(_t2, 0, _r5); _t2 < i.length; _t2++) {
              u += b(_t2);
            }

            _r5.end < h && (h = _r5.end);
          }
        }

        d(e.length), f(e.length);

        for (var _e6 = i.length - 1; _e6 >= 0; _e6--) {
          u += p(_e6);
        }

        return u += o(r.finish, function () {})(a) || "";
      }

      function h(e, n) {
        return n = s(n), o(n.finalize, String).call(n, e);
      }

      function g(e, n, r) {
        var t = u(e, c(e, n), r);
        return t = h(t, r);
      }

      function f(e, n) {
        return e = a(e), {
          use: function use(r) {
            return f(e.concat(r), n);
          },
          printer: function printer(n) {
            return f(e, n);
          },
          decorate: function decorate(r) {
            return g(r, e, n);
          }
        };
      }

      f.printer = l, f.generator = i, f.generateRanges = c, f.print = u, f.finalize = h, f.decorate = g, f.utils = t, n.exports = f;
    }, {
      "./generator": 6,
      "./printer": 12,
      "./utils": 15
    }],
    10: [function (e, n, r) {
      n.exports = function () {
        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return Object.assign({}, this, e, {
          hooks: Object.assign({}, this.hooks, e.hooks)
        });
      };
    }, {}],
    11: [function (e, n, r) {
      n.exports = {
        fork: e("./fork"),
        start: function start() {
          return "<div>";
        },
        finish: function finish() {
          return "</div>";
        },
        print: function print(e) {
          return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        hooks: {
          syntax: {
            open: function open(e) {
              return '<span class="syntax--' + e + '">';
            },
            close: function close() {
              return "</span>";
            }
          },
          spotlight: {
            open: function open() {
              return '<span class="spotlight">';
            },
            close: function close() {
              return "</span>";
            }
          },
          match: {
            open: function open() {
              return '<span class="match">';
            },
            close: function close() {
              return "</span>";
            }
          }
        }
      };
    }, {
      "./fork": 10
    }],
    12: [function (e, n, r) {
      n.exports = {
        noop: e("./noop"),
        html: e("./html"),
        tty: e("./tty")
      };
    }, {
      "./html": 11,
      "./noop": 13,
      "./tty": 14
    }],
    13: [function (e, n, r) {
      n.exports = {
        fork: e("./fork")
      };
    }, {
      "./fork": 10
    }],
    14: [function (e, n, r) {
      var t = e("ansi-styles"),
          a = l("reset"),
          o = l("bgBlue", "white"),
          i = function (e) {
        var n = {};

        for (var _r6 in e) {
          n[_r6] = Array.isArray(e[_r6]) ? l.apply(void 0, _toConsumableArray(e[_r6])) : l(e[_r6]);
        }

        return n;
      }({
        string: "yellow",
        comment: "gray",
        keyword: "red",
        key: "cyan",
        value: "cyan"
      });

      function l() {
        for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          e[_key2] = arguments[_key2];
        }

        return e.reduce(function (e, n) {
          switch (!0) {
            case n in t.color:
              e.color = t.color[n].open;
              break;

            case n in t.bgColor:
              e.bgColor = t.bgColor[n].open;
              break;

            case "reset" === n:
              e.color = "[39m", e.bgColor = "[49m";
          }

          return e;
        }, {});
      }

      function s(e) {
        return {
          open: function open(n, r) {
            var t = e(n) || {};
            r.stack.push(r.style), r.style = Object.assign({}, r.style, t);
          },
          close: function close(e, n) {
            n.style = n.stack.pop();
          }
        };
      }

      function c(e, n) {
        var r = "";

        for (var _t3 in e) {
          if (e[_t3] !== n[_t3]) switch (_t3) {
            case "color":
            case "bgColor":
              r += n[_t3] || "";
          }
        }

        return r;
      }

      n.exports = {
        fork: e("./fork"),
        createContext: function createContext() {
          return {
            printed: a,
            style: a,
            stack: []
          };
        },
        start: function start(e) {
          return c({}, e.printed);
        },
        finish: function finish(e) {
          return c(e.printed, e.style);
        },
        print: function print(e, n) {
          if (n.printed !== n.style) {
            var _r7 = c(n.printed, n.style);

            if (n.printed = n.style, _r7) return _r7 + e;
          }

          return e;
        },
        hooks: {
          syntax: s(function (e) {
            return i[e];
          }),
          spotlight: s(function () {
            return o;
          })
        }
      };
    }, {
      "./fork": 10,
      "ansi-styles": 1
    }],
    15: [function (e, n, r) {
      var t = function t() {};

      n.exports = {
        ensureFunction: function ensureFunction(e, n) {
          return "function" == typeof e ? e : n || t;
        },
        ensureArray: function ensureArray(e) {
          return Array.isArray(e) ? e : [];
        }
      };
    }, {}]
  }, {}, [9])(9);
});
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hitext;

},{}],56:[function(require,module,exports){
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = {};
var _module = undefined;
var jora;

var _define = function define() {
  var fn = arguments[arguments.length - 1];
  jora = fn();
  _define = undefined;
};

_define.amd = true;

(function (f) {
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof _module !== "undefined") {
    _module.exports = f();
  } else if (typeof _define === "function" && _define.amd) {
    _define([], f);
  } else {
    var g;

    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }

    g.jora = f();
  }
})(function () {
  var define, module, exports;
  return function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }

          var p = n[i] = {
            exports: {}
          };
          e[i][0].call(p.exports, function (r) {
            var n = e[i][1][r];
            return o(n || r);
          }, p, p.exports, r, e, n, t);
        }

        return n[i].exports;
      }

      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
        o(t[i]);
      }

      return o;
    }

    return r;
  }()({
    1: [function (require, module, exports) {
      /* parser generated by jison 0.4.18 */

      /*
        Returns a Parser object of the following structure:
      
        Parser: {
          yy: {}
        }
      
        Parser.prototype: {
          yy: {},
          trace: function(),
          symbols_: {associative list: name ==> number},
          terminals_: {associative list: number ==> name},
          productions_: [...],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
          table: [...],
          defaultActions: {...},
          parseError: function(str, hash),
          parse: function(input),
      
          lexer: {
              EOF: 1,
              parseError: function(str, hash),
              setInput: function(input),
              input: function(),
              unput: function(str),
              more: function(),
              less: function(n),
              pastInput: function(),
              upcomingInput: function(),
              showPosition: function(),
              test_match: function(regex_match_array, rule_index),
              next: function(),
              lex: function(),
              begin: function(condition),
              popState: function(),
              _currentRules: function(),
              topState: function(),
              pushState: function(condition),
      
              options: {
                  ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                  flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                  backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
              },
      
              performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
              rules: [...],
              conditions: {associative list: name ==> set},
          }
        }
      
      
        token location info (@$, _$, etc.): {
          first_line: n,
          last_line: n,
          first_column: n,
          last_column: n,
          range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
        }
      
      
        the parseError function receives a 'hash' object with these members for lexer and parser errors: {
          text:        (matched text)
          token:       (the produced terminal token, if any)
          line:        (yylineno)
        }
        while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
          loc:         (yylloc)
          expected:    (string describing the set of expected tokens)
          recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
        }
      */
      var parser = function () {
        var o = function o(k, v, _o, l) {
          for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
            ;
          }

          return _o;
        },
            $V0 = [1, 5],
            $V1 = [1, 15],
            $V2 = [1, 6],
            $V3 = [1, 7],
            $V4 = [1, 8],
            $V5 = [1, 11],
            $V6 = [1, 14],
            $V7 = [1, 16],
            $V8 = [1, 17],
            $V9 = [1, 18],
            $Va = [1, 19],
            $Vb = [1, 26],
            $Vc = [1, 27],
            $Vd = [1, 28],
            $Ve = [1, 25],
            $Vf = [1, 30],
            $Vg = [1, 31],
            $Vh = [1, 32],
            $Vi = [1, 33],
            $Vj = [1, 34],
            $Vk = [1, 35],
            $Vl = [1, 36],
            $Vm = [1, 37],
            $Vn = [1, 38],
            $Vo = [1, 39],
            $Vp = [1, 40],
            $Vq = [1, 41],
            $Vr = [1, 42],
            $Vs = [5, 9, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 43, 46, 48],
            $Vt = [1, 45],
            $Vu = [1, 48],
            $Vv = [1, 49],
            $Vw = [1, 50],
            $Vx = [5, 9, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 34, 40, 41, 42, 43, 46, 48],
            $Vy = [1, 54],
            $Vz = [5, 9, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 40, 41, 42, 43, 46, 48],
            $VA = [1, 58],
            $VB = [1, 59],
            $VC = [5, 9, 19, 20, 43, 46, 48],
            $VD = [2, 52],
            $VE = [46, 48],
            $VF = [5, 9, 17, 18, 19, 20, 43, 46, 48],
            $VG = [5, 9, 17, 18, 19, 20, 23, 24, 29, 43, 46, 48],
            $VH = [5, 9, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28, 29, 43, 46, 48],
            $VI = [9, 46];

        var parser = {
          trace: function trace() {},
          yy: {},
          symbols_: {
            "error": 2,
            "root": 3,
            "e": 4,
            "EOF": 5,
            "data": 6,
            "SELF": 7,
            "(": 8,
            ")": 9,
            "STRING": 10,
            "NUMBER": 11,
            "REGEXP": 12,
            "function": 13,
            "array": 14,
            "query": 15,
            "NOT": 16,
            "IN": 17,
            "NOTIN": 18,
            "AND": 19,
            "OR": 20,
            "+": 21,
            "-": 22,
            "=": 23,
            "!=": 24,
            "<": 25,
            "<=": 26,
            ">": 27,
            ">=": 28,
            "~=": 29,
            "dataRoot": 30,
            "@": 31,
            "#": 32,
            "$": 33,
            "SYMBOL": 34,
            "object": 35,
            "path": 36,
            "recursive": 37,
            "filter": 38,
            "method": 39,
            ".": 40,
            "..": 41,
            "[": 42,
            "]": 43,
            "arguments": 44,
            "argumentList": 45,
            ",": 46,
            "{": 47,
            "}": 48,
            "properties": 49,
            "property": 50,
            ":": 51,
            "...": 52,
            "arrayItems": 53,
            "$accept": 0,
            "$end": 1
          },
          terminals_: {
            2: "error",
            5: "EOF",
            7: "SELF",
            8: "(",
            9: ")",
            10: "STRING",
            11: "NUMBER",
            12: "REGEXP",
            16: "NOT",
            17: "IN",
            18: "NOTIN",
            19: "AND",
            20: "OR",
            21: "+",
            22: "-",
            23: "=",
            24: "!=",
            25: "<",
            26: "<=",
            27: ">",
            28: ">=",
            29: "~=",
            31: "@",
            32: "#",
            33: "$",
            34: "SYMBOL",
            40: ".",
            41: "..",
            42: "[",
            43: "]",
            46: ",",
            47: "{",
            48: "}",
            51: ":",
            52: "..."
          },
          productions_: [0, [3, 2], [3, 1], [4, 1], [4, 1], [4, 3], [4, 4], [4, 1], [4, 1], [4, 1], [4, 1], [4, 1], [4, 2], [4, 2], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [6, 1], [6, 2], [6, 1], [30, 1], [30, 1], [30, 1], [30, 1], [30, 1], [15, 1], [15, 1], [15, 1], [15, 1], [36, 2], [36, 3], [36, 4], [36, 5], [37, 2], [37, 3], [37, 4], [37, 5], [38, 3], [38, 4], [39, 4], [39, 5], [39, 6], [44, 0], [44, 1], [45, 1], [45, 3], [35, 2], [35, 3], [49, 1], [49, 3], [50, 1], [50, 3], [50, 1], [50, 2], [14, 2], [14, 3], [14, 5], [53, 1], [53, 3], [13, 3]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate
          /* action[1] */
          , $$
          /* vstack */
          , _$
          /* lstack */
          ) {
            /* this == yyval */
            var $0 = $$.length - 1;

            switch (yystate) {
              case 1:
                return this.$ = $$[$0 - 1];
                break;

              case 2:
                return this.$ = ["data"];
                break;

              case 3:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 27:
              case 29:
              case 34:
              case 35:
              case 36:
              case 37:
              case 38:
              case 53:
              case 58:
              case 67:
                this.$ = ["", $$[$0], ""];
                break;

              case 4:
                this.$ = ["(current) => self(current, subject)"];
                break;

              case 5:
                this.$ = ["self(current, subject)"];
                break;

              case 6:
                this.$ = ["self(", $$[$0 - 1], ", subject)"];
                break;

              case 12:
              case 28:
                this.$ = ["((current) => ", $$[$0], ")(", $$[$0 - 1], ")"];
                break;

              case 13:
                this.$ = ["!fn.bool(", $$[$0], ")"];
                break;

              case 14:
                this.$ = ["fn.in(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 15:
                this.$ = ["!fn.in(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 16:
                this.$ = ["fn.bool(", $$[$0 - 2], ") && fn.bool(", $$[$0], ") ? ", $$[$0], " : false"];
                break;

              case 17:
                this.$ = ["fn.bool(", $$[$0 - 2], ") ? ", $$[$0 - 2], " : ", $$[$0], ""];
                break;

              case 18:
                this.$ = ["fn.add(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 19:
                this.$ = ["fn.sub(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 20:
                this.$ = ["fn.eq(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 21:
                this.$ = ["fn.ne(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 22:
                this.$ = ["fn.lt(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 23:
                this.$ = ["fn.lte(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 24:
                this.$ = ["fn.gt(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 25:
                this.$ = ["fn.gte(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 26:
                this.$ = ["fn.regexp(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 30:
                this.$ = ["data"];
                break;

              case 31:
                this.$ = ["subject"];
                break;

              case 32:
                this.$ = ["current"];
                break;

              case 33:
              case 39:
                this.$ = ["fn.get(current, ", $$[$0], ")"];
                break;

              case 40:
                this.$ = ["fn.get(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 41:
                this.$ = ["fn.get(current, (current) => ", $$[$0 - 1], ")"];
                break;

              case 42:
                this.$ = ["fn.get(", $$[$0 - 4], ", (current) => ", $$[$0 - 1], ")"];
                break;

              case 43:
                this.$ = ["fn.recursive(current, ", $$[$0], ")"];
                break;

              case 44:
                this.$ = ["fn.recursive(", $$[$0 - 2], ", ", $$[$0], ")"];
                break;

              case 45:
                this.$ = ["fn.recursive(current, (current) => ", $$[$0 - 1], ")"];
                break;

              case 46:
                this.$ = ["fn.recursive(", $$[$0 - 4], ", (current) => ", $$[$0 - 1], ")"];
                break;

              case 47:
                this.$ = ["fn.filter(current, (current) => ", $$[$0 - 1], ")"];
                break;

              case 48:
                this.$ = ["fn.filter(", $$[$0 - 3], ", (current) => ", $$[$0 - 1], ")"];
                break;

              case 49:
              case 50:
                this.$ = ["method[", $$[$0 - 3], "](current", $$[$0 - 1], ")"];
                break;

              case 51:
                this.$ = ["method[", $$[$0 - 3], "](", $$[$0 - 5], "", $$[$0 - 1], ")"];
                break;

              case 52:
                this.$ = [""];
                break;

              case 54:
                this.$ = [", ", $$[$0], ""];
                break;

              case 55:
              case 59:
              case 68:
                this.$ = ["", $$[$0 - 2], ", ", $$[$0], ""];
                break;

              case 56:
                this.$ = ["{}"];
                break;

              case 57:
                this.$ = ["({ ", $$[$0 - 1], " })"];
                break;

              case 60:
                this.$ = ["", $$[$0], ": fn.get(current, ", $$[$0], ")"];
                break;

              case 61:
                this.$ = ["", $$[$0 - 2], ": ", $$[$0], ""];
                break;

              case 62:
                this.$ = ["...current"];
                break;

              case 63:
                this.$ = ["...", $$[$0], ""];
                break;

              case 64:
                this.$ = ["[]"];
                break;

              case 65:
                this.$ = ["fn.toArray(", $$[$0 - 1], ")"];
                break;

              case 66:
                this.$ = ["[", $$[$0 - 3], ", ", $$[$0 - 1], "]"];
                break;

              case 69:
                this.$ = ["(current) => ", $$[$0 - 1], ""];
                break;
            }
          },
          table: [{
            3: 1,
            4: 2,
            5: [1, 3],
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            1: [3]
          }, {
            5: [1, 29],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }, {
            1: [2, 2]
          }, o($Vs, [2, 3]), o($Vs, [2, 4], {
            8: [1, 43]
          }), o($Vs, [2, 7]), o($Vs, [2, 8]), o($Vs, [2, 9]), o($Vs, [2, 10]), o($Vs, [2, 11], {
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            15: 44,
            34: $Vt,
            40: $Vb,
            41: $Vc,
            42: $Vd
          }), {
            4: 46,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($Vs, [2, 27], {
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            15: 47,
            34: $Vt,
            40: $Vb,
            41: $Vc,
            42: $Vd
          }), o($Vs, [2, 29], {
            40: $Vu,
            41: $Vv,
            42: $Vw
          }), {
            4: 51,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 53,
            6: 4,
            7: $V0,
            8: $V1,
            9: [1, 52],
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($Vx, [2, 30]), o($Vx, [2, 31]), o($Vx, [2, 32]), o($Vx, [2, 33], {
            8: $Vy
          }), o($Vx, [2, 34]), o($Vz, [2, 35]), o($Vz, [2, 36]), o($Vz, [2, 37]), o($Vz, [2, 38]), {
            34: $VA,
            48: [1, 55],
            49: 56,
            50: 57,
            52: $VB
          }, {
            8: [1, 61],
            34: [1, 60]
          }, {
            8: [1, 63],
            34: [1, 62]
          }, {
            4: 64,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            1: [2, 1]
          }, {
            4: 65,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 66,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 67,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 68,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 69,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 70,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 71,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 72,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 73,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 74,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 75,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 76,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 77,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            4: 79,
            6: 4,
            7: $V0,
            8: $V1,
            9: [1, 78],
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($Vs, [2, 12], {
            40: $Vu,
            41: $Vv,
            42: $Vw
          }), {
            8: $Vy
          }, o($VC, [2, 13], {
            17: $Vf,
            18: $Vg,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o($Vs, [2, 28], {
            40: $Vu,
            41: $Vv,
            42: $Vw
          }), {
            8: [1, 81],
            34: [1, 80]
          }, {
            8: [1, 83],
            34: [1, 82]
          }, {
            4: 84,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: [1, 85],
            28: $Vq,
            29: $Vr
          }, o($Vx, [2, 64]), {
            9: [1, 86],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr,
            46: [1, 87]
          }, {
            4: 90,
            6: 4,
            7: $V0,
            8: $V1,
            9: $VD,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            44: 88,
            45: 89,
            47: $Ve
          }, o($Vx, [2, 56]), {
            46: [1, 92],
            48: [1, 91]
          }, o($VE, [2, 58]), o($VE, [2, 60], {
            51: [1, 93]
          }), o($VE, [2, 62], {
            30: 12,
            15: 13,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            6: 94,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }), o($Vz, [2, 39], {
            8: [1, 95]
          }), {
            4: 96,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($Vz, [2, 43]), {
            4: 97,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr,
            43: [1, 98]
          }, o($VF, [2, 14], {
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o($VF, [2, 15], {
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o($VC, [2, 16], {
            17: $Vf,
            18: $Vg,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o([5, 9, 20, 43, 46, 48], [2, 17], {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o($Vs, [2, 18]), o($Vs, [2, 19]), o($VG, [2, 20], {
            21: $Vj,
            22: $Vk,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq
          }), o($VG, [2, 21], {
            21: $Vj,
            22: $Vk,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq
          }), o($VH, [2, 22], {
            21: $Vj,
            22: $Vk
          }), o($VH, [2, 23], {
            21: $Vj,
            22: $Vk
          }), o($VH, [2, 24], {
            21: $Vj,
            22: $Vk
          }), o($VH, [2, 25], {
            21: $Vj,
            22: $Vk
          }), o($VG, [2, 26], {
            21: $Vj,
            22: $Vk,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq
          }), o($Vs, [2, 5]), {
            9: [1, 99],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }, o($Vz, [2, 40], {
            8: [1, 100]
          }), {
            4: 101,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($Vz, [2, 44]), {
            4: 102,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr,
            43: [1, 103]
          }, o($Vs, [2, 69], {
            6: 4,
            13: 9,
            14: 10,
            30: 12,
            15: 13,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            4: 75,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            16: $V5,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }), o($Vx, [2, 65]), {
            4: 105,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve,
            53: 104
          }, {
            9: [1, 106]
          }, {
            9: [2, 53],
            46: [1, 107]
          }, o($VI, [2, 54], {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o($Vx, [2, 57]), {
            34: $VA,
            50: 108,
            52: $VB
          }, {
            4: 109,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($VE, [2, 63]), {
            4: 90,
            6: 4,
            7: $V0,
            8: $V1,
            9: $VD,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            44: 110,
            45: 89,
            47: $Ve
          }, {
            9: [1, 111],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }, {
            9: [1, 112],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }, o($Vz, [2, 47]), o($Vs, [2, 6]), {
            4: 90,
            6: 4,
            7: $V0,
            8: $V1,
            9: $VD,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            44: 113,
            45: 89,
            47: $Ve
          }, {
            9: [1, 114],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }, {
            9: [1, 115],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }, o($Vz, [2, 48]), {
            9: [1, 116]
          }, {
            9: [2, 67],
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr,
            46: [1, 117]
          }, o($Vz, [2, 49]), {
            4: 118,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve
          }, o($VE, [2, 59]), o($VE, [2, 61], {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), {
            9: [1, 119]
          }, o($Vz, [2, 41]), o($Vz, [2, 45]), {
            9: [1, 120]
          }, o($Vz, [2, 42]), o($Vz, [2, 46]), o($Vx, [2, 66]), {
            4: 105,
            6: 4,
            7: $V0,
            8: $V1,
            10: $V2,
            11: $V3,
            12: $V4,
            13: 9,
            14: 10,
            15: 13,
            16: $V5,
            25: $V6,
            30: 12,
            31: $V7,
            32: $V8,
            33: $V9,
            34: $Va,
            35: 20,
            36: 21,
            37: 22,
            38: 23,
            39: 24,
            40: $Vb,
            41: $Vc,
            42: $Vd,
            47: $Ve,
            53: 121
          }, o($VI, [2, 55], {
            17: $Vf,
            18: $Vg,
            19: $Vh,
            20: $Vi,
            21: $Vj,
            22: $Vk,
            23: $Vl,
            24: $Vm,
            25: $Vn,
            26: $Vo,
            27: $Vp,
            28: $Vq,
            29: $Vr
          }), o($Vz, [2, 50]), o($Vz, [2, 51]), {
            9: [2, 68]
          }],
          defaultActions: {
            3: [2, 2],
            29: [2, 1],
            121: [2, 68]
          },
          parseError: function parseError(str, hash) {
            if (hash.recoverable) {
              this.trace(str);
            } else {
              var error = new Error(str);
              error.hash = hash;
              throw error;
            }
          },
          parse: function parse(input) {
            var self = this,
                stack = [0],
                tstack = [],
                vstack = [null],
                lstack = [],
                table = this.table,
                yytext = '',
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer = Object.create(this.lexer);
            var sharedState = {
              yy: {}
            };

            for (var k in this.yy) {
              if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                sharedState.yy[k] = this.yy[k];
              }
            }

            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;

            if (typeof lexer.yylloc == 'undefined') {
              lexer.yylloc = {};
            }

            var yyloc = lexer.yylloc;
            lstack.push(yyloc);
            var ranges = lexer.options && lexer.options.ranges;

            if (typeof sharedState.yy.parseError === 'function') {
              this.parseError = sharedState.yy.parseError;
            } else {
              this.parseError = Object.getPrototypeOf(this).parseError;
            }

            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }

            _token_stack: var lex = function lex() {
              var token;
              token = lexer.lex() || EOF;

              if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
              }

              return token;
            };

            var symbol,
                preErrorSymbol,
                state,
                action,
                a,
                r,
                yyval = {},
                p,
                len,
                newState,
                expected;

            while (true) {
              state = stack[stack.length - 1];

              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == 'undefined') {
                  symbol = lex();
                }

                action = table[state] && table[state][symbol];
              }

              if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];

                for (p in table[state]) {
                  if (this.terminals_[p] && p > TERROR) {
                    expected.push('\'' + this.terminals_[p] + '\'');
                  }
                }

                if (lexer.showPosition) {
                  errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                  errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }

                this.parseError(errStr, {
                  text: lexer.match,
                  token: this.terminals_[symbol] || symbol,
                  line: lexer.yylineno,
                  loc: yyloc,
                  expected: expected
                });
              }

              if (action[0] instanceof Array && action.length > 1) {
                throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
              }

              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(lexer.yytext);
                  lstack.push(lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;

                  if (!preErrorSymbol) {
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;

                    if (recovering > 0) {
                      recovering--;
                    }
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }

                  break;

                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                  };

                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }

                  r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

                  if (typeof r !== 'undefined') {
                    return r;
                  }

                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }

                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;

                case 3:
                  return true;
              }
            }

            return true;
          }
        };
        /* generated by jison-lex 0.3.4 */

        var lexer = function () {
          var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            // resets the lexer, sets new input
            setInput: function setInput(input, yy) {
              this.yy = yy || this.yy || {};
              this._input = input;
              this._more = this._backtrack = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = '';
              this.conditionStack = ['INITIAL'];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };

              if (this.options.ranges) {
                this.yylloc.range = [0, 0];
              }

              this.offset = 0;
              return this;
            },
            // consumes and returns one char from the input
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);

              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }

              if (this.options.ranges) {
                this.yylloc.range[1]++;
              }

              this._input = this._input.slice(1);
              return ch;
            },
            // unshifts one char (or a string) into the input
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;

              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);

              if (lines.length - 1) {
                this.yylineno -= lines.length - 1;
              }

              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };

              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }

              this.yyleng = this.yytext.length;
              return this;
            },
            // When called from action, caches matched text and appends it on next action
            more: function more() {
              this._more = true;
              return this;
            },
            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function reject() {
              if (this.options.backtrack_lexer) {
                this._backtrack = true;
              } else {
                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }

              return this;
            },
            // retain first n characters of the match
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            // displays already matched input, i.e. for error messages
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },
            // displays upcoming input, i.e. for error messages
            upcomingInput: function upcomingInput() {
              var next = this.match;

              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }

              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },
            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function test_match(match, indexed_rule) {
              var token, lines, backup;

              if (this.options.backtrack_lexer) {
                // save context
                backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                };

                if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
                }
              }

              lines = match[0].match(/(?:\r\n?|\n).*/g);

              if (lines) {
                this.yylineno += lines.length;
              }

              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;

              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }

              this._more = false;
              this._backtrack = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

              if (this.done && this._input) {
                this.done = false;
              }

              if (token) {
                return token;
              } else if (this._backtrack) {
                // recover context
                for (var k in backup) {
                  this[k] = backup[k];
                }

                return false; // rule action called reject() implying the next rule should be tested instead.
              }

              return false;
            },
            // return next match in input
            next: function next() {
              if (this.done) {
                return this.EOF;
              }

              if (!this._input) {
                this.done = true;
              }

              var token, match, tempMatch, index;

              if (!this._more) {
                this.yytext = '';
                this.match = '';
              }

              var rules = this._currentRules();

              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);

                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;

                  if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);

                    if (token !== false) {
                      return token;
                    } else if (this._backtrack) {
                      match = false;
                      continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                      // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                      return false;
                    }
                  } else if (!this.options.flex) {
                    break;
                  }
                }
              }

              if (match) {
                token = this.test_match(match, rules[index]);

                if (token !== false) {
                  return token;
                } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)


                return false;
              }

              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
            },
            // return next match that has a token
            lex: function lex() {
              var r = this.next();

              if (r) {
                return r;
              } else {
                return this.lex();
              }
            },
            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
              var n = this.conditionStack.length - 1;

              if (n > 0) {
                return this.conditionStack.pop();
              } else {
                return this.conditionStack[0];
              }
            },
            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
              if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              } else {
                return this.conditions["INITIAL"].rules;
              }
            },
            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
              n = this.conditionStack.length - 1 - Math.abs(n || 0);

              if (n >= 0) {
                return this.conditionStack[n];
              } else {
                return "INITIAL";
              }
            },
            // alias for begin(condition)
            pushState: function pushState(condition) {
              this.begin(condition);
            },
            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
              return this.conditionStack.length;
            },
            options: {},
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
              var YYSTATE = YY_START;

              switch ($avoiding_name_collisions) {
                case 0:
                  return "-";
                  break;

                case 1:
                  return "+";
                  break;

                case 2:
                  return "(";
                  break;

                case 3:
                  return ")";
                  break;

                case 4:
                  return "[";
                  break;

                case 5:
                  return "]";
                  break;

                case 6:
                  return "{";
                  break;

                case 7:
                  return "}";
                  break;

                case 8:
                  return "=";
                  break;

                case 9:
                  return "!=";
                  break;

                case 10:
                  return "~=";
                  break;

                case 11:
                  return ">=";
                  break;

                case 12:
                  return "<=";
                  break;

                case 13:
                  return "<";
                  break;

                case 14:
                  return ">";
                  break;

                case 15:
                  return "AND";
                  break;

                case 16:
                  return "OR";
                  break;

                case 17:
                  return "IN";
                  break;

                case 18:
                  return "NOTIN";
                  break;

                case 19:
                  return "NOT";
                  break;

                case 20:
                  return "SELF";
                  break;

                case 21:
                  return "NUMBER";
                  break;

                case 22:
                  return "STRING";
                  break;

                case 23:
                  return "REGEXP";
                  break;

                case 24:
                  yy_.yytext = JSON.stringify(yy_.yytext);
                  return "SYMBOL";
                  break;

                case 25:
                  return "SYMBOL";
                  break;

                case 26:
                  return yy_.yytext.trim();
                  break;

                case 27:
                  return ",";
                  break;

                case 28:
                  return ":";
                  break;

                case 29:
                  return "@";
                  break;

                case 30:
                  return "#";
                  break;

                case 31:
                  return "$";
                  break;

                case 32:
                  /* a comment */
                  break;

                case 33:
                  return "EOF";
                  break;
              }
            },
            rules: [/^(?:(\s*)-(\s*))/, /^(?:(\s*)\+(\s*))/, /^(?:\((\s*))/, /^(?:(\s*)\))/, /^(?:(\s*)\[(\s*))/, /^(?:(\s*)\])/, /^(?:\{(\s*))/, /^(?:(\s*)\})/, /^(?:(\s*)=(\s*))/, /^(?:(\s*)!=(\s*))/, /^(?:(\s*)~=(\s*))/, /^(?:(\s*)>=(\s*))/, /^(?:(\s*)<=(\s*))/, /^(?:(\s*)<(\s*))/, /^(?:(\s*)>(\s*))/, /^(?:(\s+)and(\s+))/, /^(?:(\s+)or(\s+))/, /^(?:(\s+)in(\s+))/, /^(?:(\s+)not(\s+)in(\s+))/, /^(?:not?(\s+))/, /^(?:::self)/, /^(?:[0-9]+(?:\.[0-9]+)?\b)/, /^(?:"(?:\\.|[^"])*")/, /^(?:\/.+\/i?)/, /^(?:[a-zA-Z_][a-zA-Z_$0-9]*)/, /^(?:'(?:\\.|[^'])*')/, /^(?:(\s*)\.{1,3})/, /^(?:(\s*),(\s*))/, /^(?:(\s*):(\s*))/, /^(?:@)/, /^(?:#)/, /^(?:\$)/, /^(?:(\s*)\/\/.*?(\n|$))/, /^(?:$)/],
            conditions: {
              "INITIAL": {
                "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33],
                "inclusive": true
              }
            }
          };
          return lexer;
        }();

        parser.lexer = lexer;

        function Parser() {
          this.yy = {};
        }

        Parser.prototype = parser;
        parser.Parser = Parser;
        return new Parser();
      }();

      ;
      module.exports = parser;
    }, {}],
    2: [function (require, module, exports) {
      var parser = require('./parser');

      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var cache = Object.create(null);
      var TYPE_ARRAY = 1;
      var TYPE_OBJECT = 2;
      var TYPE_SCALAR = 3;

      function noop() {}

      function self(value) {
        return value;
      }

      function getPropertyValue(value, property) {
        return value && hasOwnProperty.call(value, property) ? value[property] : undefined;
      }

      function isPlainObject(value) {
        return value && _typeof(value) === 'object' && value.constructor === Object;
      }

      function addToSet(value, set) {
        if (value !== undefined) {
          if (Array.isArray(value)) {
            value.forEach(function (item) {
              return set.add(item);
            });
          } else {
            set.add(value);
          }
        }
      }

      var buildin = Object.freeze({
        type: function type(value) {
          if (Array.isArray(value)) {
            return TYPE_ARRAY;
          }

          if (isPlainObject(value)) {
            return TYPE_OBJECT;
          }

          return TYPE_SCALAR;
        },
        bool: function bool(data) {
          switch (this.type(data)) {
            case TYPE_ARRAY:
              return data.length > 0;

            case TYPE_OBJECT:
              for (var key in data) {
                if (hasOwnProperty.call(data, key)) {
                  return true;
                }
              }

              return false;

            default:
              return Boolean(data);
          }
        },
        toArray: function toArray(value) {
          return Array.isArray(value) ? value : this.bool(value) ? [value] : [];
        },
        add: function add(a, b) {
          var typeA = this.type(a);
          var typeB = this.type(b);

          if (typeA !== TYPE_ARRAY) {
            if (typeB === TYPE_ARRAY) {
              var _ref = [b, a];
              a = _ref[0];
              b = _ref[1];
            }
          }

          switch (this.type(a)) {
            case TYPE_ARRAY:
              return _toConsumableArray(new Set([].concat(a, b)));

            case TYPE_OBJECT:
              return Object.assign({}, a, b);

            default:
              return a + b;
          }
        },
        sub: function sub(a, b) {
          switch (this.type(a)) {
            case TYPE_ARRAY:
              var result = new Set(a); // filter b items from a

              if (Array.isArray(b)) {
                b.forEach(function (item) {
                  return result.delete(item);
                });
              } else {
                result.delete(b);
              }

              return _toConsumableArray(result);

            case TYPE_OBJECT: // not sure what we need do here:
            // - just filter keys from a
            // - or filter key+value pairs?
            // - take in account type of b? (array, Object.keys(b), scalar as a key)

            default:
              return a - b;
          }
        },
        eq: function eq(a, b) {
          return a === b;
        },
        ne: function ne(a, b) {
          return a !== b;
        },
        lt: function lt(a, b) {
          return a < b;
        },
        lte: function lte(a, b) {
          return a <= b;
        },
        gt: function gt(a, b) {
          return a > b;
        },
        gte: function gte(a, b) {
          return a >= b;
        },
        in: function _in(a, b) {
          if (this.type(b) !== TYPE_ARRAY) {
            return false;
          }

          switch (this.type(a)) {
            // case TYPE_ARRAY:
            //     break;
            default:
              return b.indexOf(a) !== -1;
          }
        },
        regexp: function regexp(data, rx) {
          switch (this.type(data)) {
            case TYPE_ARRAY:
              return this.filter(data, function (current) {
                return rx.test(current);
              });

            default:
              return rx.test(data);
          }
        },
        get: function get(data, getter) {
          var fn = typeof getter === 'function' ? getter : function (current) {
            return getPropertyValue(current, getter);
          };

          switch (this.type(data)) {
            case TYPE_ARRAY:
              var result = new Set();

              for (var i = 0; i < data.length; i++) {
                addToSet(fn(data[i]), result);
              }

              return _toConsumableArray(result);

            default:
              return data !== undefined ? fn(data) : data;
          }
        },
        recursive: function recursive(data, getter) {
          var _this = this;

          var result = new Set();
          addToSet(this.get(data, getter), result);
          result.forEach(function (current) {
            return addToSet(_this.get(current, getter), result);
          });
          return _toConsumableArray(result);
        },
        filter: function filter(data, query) {
          var _this2 = this;

          switch (this.type(data)) {
            case TYPE_ARRAY:
              return data.filter(function (current) {
                return _this2.bool(query(current));
              });

            default:
              return [];
          }
        }
      });
      var methods = Object.freeze({
        bool: function bool(current) {
          return buildin.bool(current);
        },
        keys: function keys(current) {
          return Object.keys(current || {});
        },
        values: function values(current) {
          var values = new Set();
          Object.values(current || {}).forEach(function (value) {
            return addToSet(value, values);
          });
          return _toConsumableArray(values);
        },
        entries: function entries(current) {
          if (!current) {
            return [];
          }

          return Object.keys(current).map(function (key) {
            return {
              key: key,
              value: current[key]
            };
          });
        },
        mapToArray: function mapToArray(current) {
          var keyProperty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key';
          var result = [];

          for (var key in current) {
            if (hasOwnProperty.call(current, key)) {
              result.push(Object.assign(_defineProperty({}, keyProperty, key), current[key]));
            }
          }

          return result;
        },
        size: function size(current) {
          return current && current.length || 0;
        },
        sort: function sort(current, fn) {
          if (buildin.type(current) !== TYPE_ARRAY) {
            return current;
          }

          if (typeof fn === 'function') {
            return current.slice().sort(function (a, b) {
              a = fn(a);
              b = fn(b);

              if (Array.isArray(a) && Array.isArray(b)) {
                if (a.length !== b.length) {
                  return a.length < b.length ? -1 : 1;
                }

                for (var i = 0; i < a.length; i++) {
                  if (a[i] < b[i]) {
                    return -1;
                  } else if (a[i] > b[i]) {
                    return 1;
                  }
                }

                return 0;
              }

              return a < b ? -1 : a > b;
            });
          }

          return current.slice().sort();
        },
        reverse: function reverse(current) {
          if (buildin.type(current) !== TYPE_ARRAY) {
            return current;
          }

          return current.slice().reverse();
        },
        group: function group(current, keyFetcher, valueFetcher) {
          if (typeof keyFetcher !== 'function') {
            keyFetcher = noop;
          }

          if (typeof valueFetcher !== 'function') {
            valueFetcher = self;
          }

          if (buildin.type(current) !== TYPE_ARRAY) {
            current = [current];
          }

          var map = new Map();
          var result = [];
          current.forEach(function (item) {
            var key = keyFetcher(item);

            if (map.has(key)) {
              map.get(key).add(valueFetcher(item));
            } else {
              map.set(key, new Set([valueFetcher(item)]));
            }
          });
          map.forEach(function (value, key) {
            return result.push({
              key: key,
              value: _toConsumableArray(value)
            });
          });
          return result;
        },
        filter: function filter(current, fn) {
          return buildin.filter(current, fn);
        },
        map: function map(current, fn) {
          return buildin.get(current, fn);
        }
      });

      function compileFunction(expression, debug) {
        var tree = parser.parse(expression);
        var js = [];

        if (debug) {
          console.log('\n==== compile ===');
          console.log('expression:', expression);
          console.log('tree:', tree);
        }

        tree.forEach(function toJs(node) {
          if (Array.isArray(node)) {
            node.forEach(toJs);
          } else {
            js.push(node);
          }
        });

        if (debug) {
          console.log('js', js.join(''));
        }

        return cache[expression] = new Function('fn', 'method', 'data', 'subject', 'self', 'var current = data;\nreturn ' + js.join(''));
      }

      module.exports = function createQuery(expression, extraFunctions, debug) {
        expression = String(expression).trim();
        var localMethods = extraFunctions ? Object.assign({}, methods, extraFunctions) : methods;
        var func = cache[expression] || compileFunction(expression, debug);

        if (debug) {
          console.log('fn', func.toString());
        }

        return function query(data, subject) {
          return func(buildin, localMethods, data, subject, query);
        };
      };

      module.exports.buildin = buildin;
      module.exports.methods = methods;
    }, {
      "./parser": 1
    }]
  }, {}, [2])(2);
});

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = jora;

},{"./parser":undefined}],57:[function(require,module,exports){
"use strict";

var global = {};
var _module = undefined;
var Prism;

var _define = function define() {
  var fn = arguments[arguments.length - 1];
  Prism = fn();
  _define = undefined;
};

_define.amd = true;
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = typeof window !== 'undefined' ? window // if in browser
: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self // if in worker
: {} // if in node js
;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */


var Prism = function () {
  // Private helper vars
  var lang = /\blang(?:uage)?-([\w-]+)\b/i;
  var uniqueId = 0;

  var _ = _self.Prism = {
    manual: _self.Prism && _self.Prism.manual,
    disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
    util: {
      encode: function encode(tokens) {
        if (tokens instanceof Token) {
          return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
        } else if (_.util.type(tokens) === 'Array') {
          return tokens.map(_.util.encode);
        } else {
          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
        }
      },
      type: function type(o) {
        return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
      },
      objId: function objId(obj) {
        if (!obj['__id']) {
          Object.defineProperty(obj, '__id', {
            value: ++uniqueId
          });
        }

        return obj['__id'];
      },
      // Deep clone a language definition (e.g. to extend it)
      clone: function clone(o, visited) {
        var type = _.util.type(o);

        visited = visited || {};

        switch (type) {
          case 'Object':
            if (visited[_.util.objId(o)]) {
              return visited[_.util.objId(o)];
            }

            var clone = {};
            visited[_.util.objId(o)] = clone;

            for (var key in o) {
              if (o.hasOwnProperty(key)) {
                clone[key] = _.util.clone(o[key], visited);
              }
            }

            return clone;

          case 'Array':
            if (visited[_.util.objId(o)]) {
              return visited[_.util.objId(o)];
            }

            var clone = [];
            visited[_.util.objId(o)] = clone;
            o.forEach(function (v, i) {
              clone[i] = _.util.clone(v, visited);
            });
            return clone;
        }

        return o;
      }
    },
    languages: {
      extend: function extend(id, redef) {
        var lang = _.util.clone(_.languages[id]);

        for (var key in redef) {
          lang[key] = redef[key];
        }

        return lang;
      },

      /**
       * Insert a token before another token in a language literal
       * As this needs to recreate the object (we cannot actually insert before keys in object literals),
       * we cannot just provide an object, we need anobject and a key.
       * @param inside The key (or language id) of the parent
       * @param before The key to insert before. If not provided, the function appends instead.
       * @param insert Object with the key/value pairs to insert
       * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
       */
      insertBefore: function insertBefore(inside, before, insert, root) {
        root = root || _.languages;
        var grammar = root[inside];

        if (arguments.length == 2) {
          insert = arguments[1];

          for (var newToken in insert) {
            if (insert.hasOwnProperty(newToken)) {
              grammar[newToken] = insert[newToken];
            }
          }

          return grammar;
        }

        var ret = {};

        for (var token in grammar) {
          if (grammar.hasOwnProperty(token)) {
            if (token == before) {
              for (var newToken in insert) {
                if (insert.hasOwnProperty(newToken)) {
                  ret[newToken] = insert[newToken];
                }
              }
            }

            ret[token] = grammar[token];
          }
        } // Update references in other language definitions


        _.languages.DFS(_.languages, function (key, value) {
          if (value === root[inside] && key != inside) {
            this[key] = ret;
          }
        });

        return root[inside] = ret;
      },
      // Traverse a language definition with Depth First Search
      DFS: function DFS(o, callback, type, visited) {
        visited = visited || {};

        for (var i in o) {
          if (o.hasOwnProperty(i)) {
            callback.call(o, i, o[i], type || i);

            if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
              visited[_.util.objId(o[i])] = true;

              _.languages.DFS(o[i], callback, null, visited);
            } else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
              visited[_.util.objId(o[i])] = true;

              _.languages.DFS(o[i], callback, i, visited);
            }
          }
        }
      }
    },
    plugins: {},
    highlightAll: function highlightAll(async, callback) {
      _.highlightAllUnder(document, async, callback);
    },
    highlightAllUnder: function highlightAllUnder(container, async, callback) {
      var env = {
        callback: callback,
        selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
      };

      _.hooks.run("before-highlightall", env);

      var elements = env.elements || container.querySelectorAll(env.selector);

      for (var i = 0, element; element = elements[i++];) {
        _.highlightElement(element, async === true, env.callback);
      }
    },
    highlightElement: function highlightElement(element, async, callback) {
      // Find language
      var language,
          grammar,
          parent = element;

      while (parent && !lang.test(parent.className)) {
        parent = parent.parentNode;
      }

      if (parent) {
        language = (parent.className.match(lang) || [, ''])[1].toLowerCase();
        grammar = _.languages[language];
      } // Set language on the element, if not present


      element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

      if (element.parentNode) {
        // Set language on the parent, for styling
        parent = element.parentNode;

        if (/pre/i.test(parent.nodeName)) {
          parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
        }
      }

      var code = element.textContent;
      var env = {
        element: element,
        language: language,
        grammar: grammar,
        code: code
      };

      _.hooks.run('before-sanity-check', env);

      if (!env.code || !env.grammar) {
        if (env.code) {
          _.hooks.run('before-highlight', env);

          env.element.textContent = env.code;

          _.hooks.run('after-highlight', env);
        }

        _.hooks.run('complete', env);

        return;
      }

      _.hooks.run('before-highlight', env);

      if (async && _self.Worker) {
        var worker = new Worker(_.filename);

        worker.onmessage = function (evt) {
          env.highlightedCode = evt.data;

          _.hooks.run('before-insert', env);

          env.element.innerHTML = env.highlightedCode;
          callback && callback.call(env.element);

          _.hooks.run('after-highlight', env);

          _.hooks.run('complete', env);
        };

        worker.postMessage(JSON.stringify({
          language: env.language,
          code: env.code,
          immediateClose: true
        }));
      } else {
        env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

        _.hooks.run('before-insert', env);

        env.element.innerHTML = env.highlightedCode;
        callback && callback.call(element);

        _.hooks.run('after-highlight', env);

        _.hooks.run('complete', env);
      }
    },
    highlight: function highlight(text, grammar, language) {
      var env = {
        code: text,
        grammar: grammar,
        language: language
      };

      _.hooks.run('before-tokenize', env);

      env.tokens = _.tokenize(env.code, env.grammar);

      _.hooks.run('after-tokenize', env);

      return Token.stringify(_.util.encode(env.tokens), env.language);
    },
    matchGrammar: function matchGrammar(text, strarr, grammar, index, startPos, oneshot, target) {
      var Token = _.Token;

      for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }

        if (token == target) {
          return;
        }

        var patterns = grammar[token];
        patterns = _.util.type(patterns) === "Array" ? patterns : [patterns];

        for (var j = 0; j < patterns.length; ++j) {
          var pattern = patterns[j],
              inside = pattern.inside,
              lookbehind = !!pattern.lookbehind,
              greedy = !!pattern.greedy,
              lookbehindLength = 0,
              alias = pattern.alias;

          if (greedy && !pattern.pattern.global) {
            // Without the global flag, lastIndex won't work
            var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
            pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
          }

          pattern = pattern.pattern || pattern; // Dont cache length as it changes during the loop

          for (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {
            var str = strarr[i];

            if (strarr.length > text.length) {
              // Something went terribly wrong, ABORT, ABORT!
              return;
            }

            if (str instanceof Token) {
              continue;
            }

            if (greedy && i != strarr.length - 1) {
              pattern.lastIndex = pos;
              var match = pattern.exec(text);

              if (!match) {
                break;
              }

              var from = match.index + (lookbehind ? match[1].length : 0),
                  to = match.index + match[0].length,
                  k = i,
                  p = pos;

              for (var len = strarr.length; k < len && (p < to || !strarr[k].type && !strarr[k - 1].greedy); ++k) {
                p += strarr[k].length; // Move the index i to the element in strarr that is closest to from

                if (from >= p) {
                  ++i;
                  pos = p;
                }
              } // If strarr[i] is a Token, then the match starts inside another Token, which is invalid


              if (strarr[i] instanceof Token) {
                continue;
              } // Number of tokens to delete and replace with the new match


              delNum = k - i;
              str = text.slice(pos, p);
              match.index -= pos;
            } else {
              pattern.lastIndex = 0;
              var match = pattern.exec(str),
                  delNum = 1;
            }

            if (!match) {
              if (oneshot) {
                break;
              }

              continue;
            }

            if (lookbehind) {
              lookbehindLength = match[1] ? match[1].length : 0;
            }

            var from = match.index + lookbehindLength,
                match = match[0].slice(lookbehindLength),
                to = from + match.length,
                before = str.slice(0, from),
                after = str.slice(to);
            var args = [i, delNum];

            if (before) {
              ++i;
              pos += before.length;
              args.push(before);
            }

            var wrapped = new Token(token, inside ? _.tokenize(match, inside) : match, alias, match, greedy);
            args.push(wrapped);

            if (after) {
              args.push(after);
            }

            Array.prototype.splice.apply(strarr, args);
            if (delNum != 1) _.matchGrammar(text, strarr, grammar, i, pos, true, token);
            if (oneshot) break;
          }
        }
      }
    },
    tokenize: function tokenize(text, grammar, language) {
      var strarr = [text];
      var rest = grammar.rest;

      if (rest) {
        for (var token in rest) {
          grammar[token] = rest[token];
        }

        delete grammar.rest;
      }

      _.matchGrammar(text, strarr, grammar, 0, 0, false);

      return strarr;
    },
    hooks: {
      all: {},
      add: function add(name, callback) {
        var hooks = _.hooks.all;
        hooks[name] = hooks[name] || [];
        hooks[name].push(callback);
      },
      run: function run(name, env) {
        var callbacks = _.hooks.all[name];

        if (!callbacks || !callbacks.length) {
          return;
        }

        for (var i = 0, callback; callback = callbacks[i++];) {
          callback(env);
        }
      }
    }
  };

  var Token = _.Token = function (type, content, alias, matchedStr, greedy) {
    this.type = type;
    this.content = content;
    this.alias = alias; // Copy of the full string this token was created from

    this.length = (matchedStr || "").length | 0;
    this.greedy = !!greedy;
  };

  Token.stringify = function (o, language, parent) {
    if (typeof o == 'string') {
      return o;
    }

    if (_.util.type(o) === 'Array') {
      return o.map(function (element) {
        return Token.stringify(element, language, o);
      }).join('');
    }

    var env = {
      type: o.type,
      content: Token.stringify(o.content, language, parent),
      tag: 'span',
      classes: ['token', o.type],
      attributes: {},
      language: language,
      parent: parent
    };

    if (o.alias) {
      var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
      Array.prototype.push.apply(env.classes, aliases);
    }

    _.hooks.run('wrap', env);

    var attributes = Object.keys(env.attributes).map(function (name) {
      return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
    }).join(' ');
    return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';
  };

  if (!_self.document) {
    if (!_self.addEventListener) {
      // in Node.js
      return _self.Prism;
    }

    if (!_.disableWorkerMessageHandler) {
      // In worker
      _self.addEventListener('message', function (evt) {
        var message = JSON.parse(evt.data),
            lang = message.language,
            code = message.code,
            immediateClose = message.immediateClose;

        _self.postMessage(_.highlight(code, _.languages[lang], lang));

        if (immediateClose) {
          _self.close();
        }
      }, false);
    }

    return _self.Prism;
  } //Get current script and highlight


  var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

  if (script) {
    _.filename = script.src;

    if (!_.manual && !script.hasAttribute('data-manual')) {
      if (document.readyState !== "loading") {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(_.highlightAll);
        } else {
          window.setTimeout(_.highlightAll, 16);
        }
      } else {
        document.addEventListener('DOMContentLoaded', _.highlightAll);
      }
    }
  }

  return _self.Prism;
}();

if (typeof _module !== 'undefined' && _module.exports) {
  _module.exports = Prism;
} // hack for components to work correctly in node.js


if (typeof global !== 'undefined') {
  global.Prism = Prism;
}
/* **********************************************
     Begin prism-markup.js
********************************************** */


Prism.languages.markup = {
  'comment': /<!--[\s\S]*?-->/,
  'prolog': /<\?[\s\S]+?\?>/,
  'doctype': /<!DOCTYPE[\s\S]+?>/i,
  'cdata': /<!\[CDATA\[[\s\S]*?]]>/i,
  'tag': {
    pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,
    greedy: true,
    inside: {
      'tag': {
        pattern: /^<\/?[^\s>\/]+/i,
        inside: {
          'punctuation': /^<\/?/,
          'namespace': /^[^\s>\/:]+:/
        }
      },
      'attr-value': {
        pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,
        inside: {
          'punctuation': [/^=/, {
            pattern: /(^|[^\\])["']/,
            lookbehind: true
          }]
        }
      },
      'punctuation': /\/?>/,
      'attr-name': {
        pattern: /[^\s>\/]+/,
        inside: {
          'namespace': /^[^\s>\/:]+:/
        }
      }
    }
  },
  'entity': /&#?[\da-z]{1,8};/i
};
Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] = Prism.languages.markup['entity']; // Plugin to make entity title show the real entity, idea by Roman Komarov

Prism.hooks.add('wrap', function (env) {
  if (env.type === 'entity') {
    env.attributes['title'] = env.content.replace(/&amp;/, '&');
  }
});
Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
  'comment': /\/\*[\s\S]*?\*\//,
  'atrule': {
    pattern: /@[\w-]+?.*?(?:;|(?=\s*\{))/i,
    inside: {
      'rule': /@[\w-]+/ // See rest below

    }
  },
  'url': /url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
  'selector': /[^{}\s][^{};]*?(?=\s*\{)/,
  'string': {
    pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  'property': /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,
  'important': /\B!important\b/i,
  'function': /[-a-z0-9]+(?=\()/i,
  'punctuation': /[(){};:]/
};
Prism.languages.css['atrule'].inside.rest = Prism.languages.css;

if (Prism.languages.markup) {
  Prism.languages.insertBefore('markup', 'tag', {
    'style': {
      pattern: /(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,
      lookbehind: true,
      inside: Prism.languages.css,
      alias: 'language-css',
      greedy: true
    }
  });
  Prism.languages.insertBefore('inside', 'attr-value', {
    'style-attr': {
      pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,
      inside: {
        'attr-name': {
          pattern: /^\s*style/i,
          inside: Prism.languages.markup.tag.inside
        },
        'punctuation': /^\s*=\s*['"]|['"]\s*$/,
        'attr-value': {
          pattern: /.+/i,
          inside: Prism.languages.css
        }
      },
      alias: 'language-css'
    }
  }, Prism.languages.markup.tag);
}
/* **********************************************
     Begin prism-clike.js
********************************************** */


Prism.languages.clike = {
  'comment': [{
    pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
    lookbehind: true
  }, {
    pattern: /(^|[^\\:])\/\/.*/,
    lookbehind: true,
    greedy: true
  }],
  'string': {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  'class-name': {
    pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,
    lookbehind: true,
    inside: {
      punctuation: /[.\\]/
    }
  },
  'keyword': /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
  'boolean': /\b(?:true|false)\b/,
  'function': /[a-z0-9_]+(?=\()/i,
  'number': /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,
  'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
  'punctuation': /[{}[\];(),.:]/
};
/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
  'keyword': /\b(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
  'number': /\b(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  'function': /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\()/i,
  'operator': /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/
});
Prism.languages.insertBefore('javascript', 'keyword', {
  'regex': {
    pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[[^\]\r\n]+]|\\.|[^/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})\]]))/,
    lookbehind: true,
    greedy: true
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  'function-variable': {
    pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=\s*(?:function\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,
    alias: 'function'
  },
  'constant': /\b[A-Z][A-Z\d_]*\b/
});
Prism.languages.insertBefore('javascript', 'string', {
  'template-string': {
    pattern: /`(?:\\[\s\S]|\${[^}]+}|[^\\`])*`/,
    greedy: true,
    inside: {
      'interpolation': {
        pattern: /\${[^}]+}/,
        inside: {
          'interpolation-punctuation': {
            pattern: /^\${|}$/,
            alias: 'punctuation'
          },
          rest: null // See below

        }
      },
      'string': /[\s\S]+/
    }
  }
});
Prism.languages.javascript['template-string'].inside['interpolation'].inside.rest = Prism.languages.javascript;

if (Prism.languages.markup) {
  Prism.languages.insertBefore('markup', 'tag', {
    'script': {
      pattern: /(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript,
      alias: 'language-javascript',
      greedy: true
    }
  });
}

Prism.languages.js = Prism.languages.javascript;
/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
  if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
    return;
  }

  self.Prism.fileHighlight = function () {
    var Extensions = {
      'js': 'javascript',
      'py': 'python',
      'rb': 'ruby',
      'ps1': 'powershell',
      'psm1': 'powershell',
      'sh': 'bash',
      'bat': 'batch',
      'h': 'c',
      'tex': 'latex'
    };
    Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
      var src = pre.getAttribute('data-src');
      var language,
          parent = pre;
      var lang = /\blang(?:uage)?-([\w-]+)\b/i;

      while (parent && !lang.test(parent.className)) {
        parent = parent.parentNode;
      }

      if (parent) {
        language = (pre.className.match(lang) || [, ''])[1];
      }

      if (!language) {
        var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
        language = Extensions[extension] || extension;
      }

      var code = document.createElement('code');
      code.className = 'language-' + language;
      pre.textContent = '';
      code.textContent = 'Loading';
      pre.appendChild(code);
      var xhr = new XMLHttpRequest();
      xhr.open('GET', src, true);

      xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText) {
            code.textContent = xhr.responseText;
            Prism.highlightElement(code);
          } else if (xhr.status >= 400) {
            code.textContent = ' Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
          } else {
            code.textContent = ' Error: File does not exist or is empty';
          }
        }
      };

      xhr.send(null);
    });

    if (Prism.plugins.toolbar) {
      Prism.plugins.toolbar.registerButton('download-file', function (env) {
        var pre = env.element.parentNode;

        if (!pre || !/pre/i.test(pre.nodeName) || !pre.hasAttribute('data-src') || !pre.hasAttribute('data-download-link')) {
          return;
        }

        var src = pre.getAttribute('data-src');
        var a = document.createElement('a');
        a.textContent = pre.getAttribute('data-download-link-label') || 'Download';
        a.setAttribute('download', '');
        a.href = src;
        return a;
      });
    }
  };

  document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);
})();

Prism.languages.json = {
  'property': /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/i,
  'string': {
    pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    greedy: true
  },
  'number': /\b0x[\dA-Fa-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,
  'punctuation': /[{}[\]);,]/,
  'operator': /:/g,
  'boolean': /\b(?:true|false)\b/i,
  'null': /\bnull\b/i
};
Prism.languages.jsonp = Prism.languages.json;
/**
 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
 * Modified by Miles Johnson: http://milesj.me
 *
 * Supports the following:
 * 		- Extends clike syntax
 * 		- Support for PHP 5.3+ (namespaces, traits, generators, etc)
 * 		- Smarter constant and function matching
 *
 * Adds the following new token classes:
 * 		constant, delimiter, variable, function, package
 */

(function (Prism) {
  Prism.languages.php = Prism.languages.extend('clike', {
    'keyword': /\b(?:and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
    'constant': /\b[A-Z0-9_]{2,}\b/,
    'comment': {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    }
  });
  Prism.languages.insertBefore('php', 'string', {
    'shell-comment': {
      pattern: /(^|[^\\])#.*/,
      lookbehind: true,
      alias: 'comment'
    }
  });
  Prism.languages.insertBefore('php', 'keyword', {
    'delimiter': {
      pattern: /\?>|<\?(?:php|=)?/i,
      alias: 'important'
    },
    'variable': /\$+(?:\w+\b|(?={))/i,
    'package': {
      pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
      lookbehind: true,
      inside: {
        punctuation: /\\/
      }
    }
  }); // Must be defined after the function pattern

  Prism.languages.insertBefore('php', 'operator', {
    'property': {
      pattern: /(->)[\w]+/,
      lookbehind: true
    }
  });
  Prism.languages.insertBefore('php', 'string', {
    'nowdoc-string': {
      pattern: /<<<'([^']+)'(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;/,
      greedy: true,
      alias: 'string',
      inside: {
        'delimiter': {
          pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
          alias: 'symbol',
          inside: {
            'punctuation': /^<<<'?|[';]$/
          }
        }
      }
    },
    'heredoc-string': {
      pattern: /<<<(?:"([^"]+)"(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\1;|([a-z_]\w*)(?:\r\n?|\n)(?:.*(?:\r\n?|\n))*?\2;)/i,
      greedy: true,
      alias: 'string',
      inside: {
        'delimiter': {
          pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
          alias: 'symbol',
          inside: {
            'punctuation': /^<<<"?|[";]$/
          }
        },
        'interpolation': null // See below

      }
    },
    'single-quoted-string': {
      pattern: /'(?:\\[\s\S]|[^\\'])*'/,
      greedy: true,
      alias: 'string'
    },
    'double-quoted-string': {
      pattern: /"(?:\\[\s\S]|[^\\"])*"/,
      greedy: true,
      alias: 'string',
      inside: {
        'interpolation': null // See below

      }
    }
  }); // The different types of PHP strings "replace" the C-like standard string

  delete Prism.languages.php['string'];
  var string_interpolation = {
    pattern: /{\$(?:{(?:{[^{}]+}|[^{}]+)}|[^{}])+}|(^|[^\\{])\$+(?:\w+(?:\[.+?]|->\w+)*)/,
    lookbehind: true,
    inside: {
      rest: Prism.languages.php
    }
  };
  Prism.languages.php['heredoc-string'].inside['interpolation'] = string_interpolation;
  Prism.languages.php['double-quoted-string'].inside['interpolation'] = string_interpolation;
  Prism.hooks.add('before-tokenize', function (env) {
    if (!/(?:<\?php|<\?)/ig.test(env.code)) {
      return;
    }

    var phpPattern = /(?:<\?php|<\?)[\s\S]*?(?:\?>|$)/ig;
    Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
  });
  Prism.hooks.add('after-tokenize', function (env) {
    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');
  });
})(Prism);

Prism.languages.twig = {
  'comment': /\{#[\s\S]*?#\}/,
  'tag': {
    pattern: /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}/,
    inside: {
      'ld': {
        pattern: /^(?:\{\{-?|\{%-?\s*\w+)/,
        inside: {
          'punctuation': /^(?:\{\{|\{%)-?/,
          'keyword': /\w+/
        }
      },
      'rd': {
        pattern: /-?(?:%\}|\}\})$/,
        inside: {
          'punctuation': /.*/
        }
      },
      'string': {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          'punctuation': /^['"]|['"]$/
        }
      },
      'keyword': /\b(?:even|if|odd)\b/,
      'boolean': /\b(?:true|false|null)\b/,
      'number': /\b0x[\dA-Fa-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      'operator': [{
        pattern: /(\s)(?:and|b-and|b-xor|b-or|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
        lookbehind: true
      }, /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/],
      'property': /\b[a-zA-Z_]\w*\b/,
      'punctuation': /[()\[\]{}:.,]/
    }
  },
  // The rest can be parsed as HTML
  'other': {
    // We want non-blank matches
    pattern: /\S(?:[\s\S]*\S)?/,
    inside: Prism.languages.markup
  }
};
Prism.languages.yaml = {
  'scalar': {
    pattern: /([\-:]\s*(?:![^\s]+)?[ \t]*[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)[^\r\n]+(?:\2[^\r\n]+)*)/,
    lookbehind: true,
    alias: 'string'
  },
  'comment': /#.*/,
  'key': {
    pattern: /(\s*(?:^|[:\-,[{\r\n?])[ \t]*(?:![^\s]+)?[ \t]*)[^\r\n{[\]},#\s]+?(?=\s*:\s)/,
    lookbehind: true,
    alias: 'atrule'
  },
  'directive': {
    pattern: /(^[ \t]*)%.+/m,
    lookbehind: true,
    alias: 'important'
  },
  'datetime': {
    pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?)?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?)(?=[ \t]*(?:$|,|]|}))/m,
    lookbehind: true,
    alias: 'number'
  },
  'boolean': {
    pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:true|false)[ \t]*(?=$|,|]|})/im,
    lookbehind: true,
    alias: 'important'
  },
  'null': {
    pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)(?:null|~)[ \t]*(?=$|,|]|})/im,
    lookbehind: true,
    alias: 'important'
  },
  'string': {
    pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)("|')(?:(?!\2)[^\\\r\n]|\\.)*\2(?=[ \t]*(?:$|,|]|}))/m,
    lookbehind: true,
    greedy: true
  },
  'number': {
    pattern: /([:\-,[{]\s*(?:![^\s]+)?[ \t]*)[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+\.?\d*|\.?\d+)(?:e[+-]?\d+)?|\.inf|\.nan)[ \t]*(?=$|,|]|})/im,
    lookbehind: true
  },
  'tag': /![^\s]+/,
  'important': /[&*][\w]+/,
  'punctuation': /---|[:[\]{}\-,|>?]|\.\.\./
};

(function (Prism) {
  var inside = {
    'url': /url\((["']?).*?\1\)/i,
    'string': {
      pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
      greedy: true
    },
    'interpolation': null,
    // See below
    'func': null,
    // See below
    'important': /\B!(?:important|optional)\b/i,
    'keyword': {
      pattern: /(^|\s+)(?:(?:if|else|for|return|unless)(?=\s+|$)|@[\w-]+)/,
      lookbehind: true
    },
    'hexcode': /#[\da-f]{3,6}/i,
    'number': /\b\d+(?:\.\d+)?%?/,
    'boolean': /\b(?:true|false)\b/,
    'operator': [// We want non-word chars around "-" because it is
    // accepted in property names.
    /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.+|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/],
    'punctuation': /[{}()\[\];:,]/
  };
  inside['interpolation'] = {
    pattern: /\{[^\r\n}:]+\}/,
    alias: 'variable',
    inside: {
      'delimiter': {
        pattern: /^{|}$/,
        alias: 'punctuation'
      },
      rest: inside
    }
  };
  inside['func'] = {
    pattern: /[\w-]+\([^)]*\).*/,
    inside: {
      'function': /^[^(]+/,
      rest: inside
    }
  };
  Prism.languages.stylus = {
    'comment': {
      pattern: /(^|[^\\])(\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    'atrule-declaration': {
      pattern: /(^\s*)@.+/m,
      lookbehind: true,
      inside: {
        'atrule': /^@[\w-]+/,
        rest: inside
      }
    },
    'variable-declaration': {
      pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:(?:\{[^}]*\}|.+)|$)/m,
      lookbehind: true,
      inside: {
        'variable': /^\S+/,
        rest: inside
      }
    },
    'statement': {
      pattern: /(^[ \t]*)(?:if|else|for|return|unless)[ \t]+.+/m,
      lookbehind: true,
      inside: {
        keyword: /^\S+/,
        rest: inside
      }
    },
    // A property/value pair cannot end with a comma or a brace
    // It cannot have indented content unless it ended with a semicolon
    'property-declaration': {
      pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)[^{\r\n]*(?:;|[^{\r\n,](?=$)(?!(\r?\n|\r)(?:\{|\2[ \t]+)))/m,
      lookbehind: true,
      inside: {
        'property': {
          pattern: /^[^\s:]+/,
          inside: {
            'interpolation': inside.interpolation
          }
        },
        rest: inside
      }
    },
    // A selector can contain parentheses only as part of a pseudo-element
    // It can span multiple lines.
    // It must end with a comma or an accolade or have indented content.
    'selector': {
      pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\))?|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\))?|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t]+)))/m,
      lookbehind: true,
      inside: {
        'interpolation': inside.interpolation,
        'punctuation': /[{},]/
      }
    },
    'func': inside.func,
    'string': inside.string,
    'interpolation': inside.interpolation,
    'punctuation': /[{}()\[\];:.]/
  };
})(Prism);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Prism;

},{}]},{},[13])(13)
});
